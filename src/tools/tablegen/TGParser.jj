/**
 * This is a grammar description file as the input of JavaCC, then the JavaCC
 * would generates several source files which used for parsing table gen file.
 */

/**
 * option illustration.
 */
options
{
    STATIC = false;
    DEBUG_PARSER = true;
    UNICODE_INPUT = false;
    JDK_VERSION = "1.8";
}

PARSER_BEGIN(TGParser)
package tools.tablegen;
import gnu.trove.list.array.TIntArrayList;
import tools.Pair;
import tools.tablegen.Init.*;
import tools.tablegen.RecTy.*;

import java.io.*;
import java.util.ArrayList;
import java.util.Stack;

import static tools.tablegen.Record.records;

public final class TGParser
{
    public static final class LetRecord
    {
        String name;
        TIntArrayList bits;
        Init value;
        boolean hasBits;
        LetRecord(String name, TIntArrayList bits, Init val)
        {
            this.name = name;
            value = val;
            hasBits = bits != null;
            if (hasBits)
                this.bits = bits;
        }
    }

    public static final class SubClassReference
    {
        Record rec;
        ArrayList<Init> templateArgs;
        SubClassReference(Record rec, ArrayList<Init> templateArgs)
        {
            this.rec = rec;
            this.templateArgs = templateArgs;
        }
        boolean isInvalid() { return rec == null; }
    }

    private final Stack<ArrayList<LetRecord>> letStack = new Stack<ArrayList<LetRecord>>();
    private boolean parseTemplateArgs = false;

    private int anonCounter = 0;
    private Record curRec = null;

    /**
     * This method is called when an error needed to be reported.
     */
    public boolean tokError(String msg)
    {
        System.err.println(msg);
        return true;
    }
    /**
     * This is the entry point for parsing a table-gen grammar file.
     */
    public void parse()
    {
        try
        {
            parseObjectList();
        }
        catch (ParseException e)
        {
            e.printStackTrace();
        }
    }

    private void addValue(RecordVal rv)
    {
        RecordVal rval = curRec.getValue(rv.getName());
        if (rval != null)
        {
            tokError("New definition of '"+rv.getName()
                    + "' of type '" + rv.getType().toString() +
                    "' is incompatible with previous definition of type '"
                    + rval.getType().toString() + "'!\u005cn");
            System.exit(-1);
        }
        else
            curRec.addValue(rv);
    }

    private void addSuperClass(Record rc)
    {
        if (curRec.isSubClassOf(rc))
        {
            tokError("Already subclass of '" + rc.getName()+"'!\u005cn");
            System.exit(-1);
        }
        curRec.addSuperClass(rc);
    }

    private void setValue(String valName, TIntArrayList bitlist, Init val)
    {
        if (val == null) return;

        RecordVal rv = curRec.getValue(valName);
        if (rv == null)
        {
            tokError("Value '" + valName + "' Unknown!\u005cn");
            System.exit(-1);
        }

        // Do not allow assignments like 'X = X'.  This will just cause infinite loops
        // in the resolution machinery.
        if (bitlist == null)
        {
            if (val instanceof VarInit)
            {
                VarInit vi = (VarInit)val;
                if (vi.getName().equals(valName))
                    return;
            }
        }

        // If we are assigning to a subset of the bits in the value... then we must be
        // assigning to a field of BitsRecTy, which must have a BitsInit initializer.
        if (bitlist != null)
        {
            if (!(rv.getValue() instanceof BitsInit))
            {
                tokError("Value '" + valName + "' is not a bits type!\u005cn");
                System.exit(-1);
            }

            BitsInit curVal = (BitsInit)rv.getValue();
            // Convert the incoming value to a bits type of the appropriate size...
            Init bi = val.convertInitializerTo(new BitsRecTy(bitlist.size()));
            if (bi == null)
            {
                val.convertInitializerTo(new BitsRecTy(bitlist.size()));
                tokError("Initializer '" + val.toString() + "' not compatible with bit range!\u005cn");
                System.exit(-1);
            }

            // We should have a BitsInit type now...
            assert bi instanceof BitsInit;
            BitsInit binit = (BitsInit)bi;

            BitsInit newVal = new BitsInit(curVal.getNumBits());
            for (int i = 0, e = bitlist.size(); i < e; i++)
            {
                int b = bitlist.get(i);
                if (newVal.getBit(b) != null)
                {
                    tokError("Cannot set bit #"+b+" of value '"+valName
                            +"' more than once!\u005cn");
                    System.exit(-1);
                }
                newVal.setBit(b, binit.getBit(i));
            }

            for (int i = 0, e = curVal.getNumBits(); i < e; i++)
            {
                if (newVal.getBit(i) == null)
                {
                    newVal.setBit(i, curVal.getBit(i));
                }
            }
            val = newVal;
        }
        if (rv.setValue(val))
        {
            tokError("Value '"+valName+"' of type '"+rv.getType().toString()
                    + "' is incompatible with initializer '"+val.toString()+"'!\u005cn");
            System.exit(-1);
        }
    }

    /**
     * Add {@code rec} as a subclass to curRec, resolving templateArgs as
     * rec's template arguments.
     */
    private void addSubClass(Record rec, ArrayList<Init> templateArgs)
    {
        ArrayList<RecordVal> vals = rec.getValues();
        for (RecordVal rv : vals)
            addValue(rv);

        ArrayList<String> targs = rec.getTemplateArgs();
        if (targs.size() < templateArgs.size())
        {
            tokError("ERROR: More template args specified than expected!\u005cn");
            System.exit(-1);
        }
        else
        {
            for (int i = 0, e = targs.size(); i < e; i++)
            {
                String arg = targs.get(i);
                if (i < templateArgs.size())
                {
                    setValue(arg, null, templateArgs.get(i));
                    curRec.resolveReferencesTo(curRec.getValue(arg));

                    curRec.removeValue(arg);
                }
                else if (!curRec.getValue(arg).getValue().isComplete())
                {
                    tokError("ERROR: Value not specified for template argument #"
                            +i+ " ("+ arg+") of suclass '"+rec.getName() + "'!\u005cn");
                    System.exit(-1);
                }
            }
        }

        // Since everything went well, we can now set the "superclass" list for the
        // current record.
        ArrayList<Record> supers = rec.getSuperClasses();
        for (Record sc : supers)
            addSuperClass(sc);

        addSuperClass(rec);
    }


    /**
     * This is the entry point to parsing a single file.
     * @filename The input file name.
     */
    public static void parseFile(String filename)
    {
        parseFile(filename, false);
    }
    /**
     * This is the entry point to parsing a single file.
     * @filename The input file name.
     * @debug   The flag to indicating whether enable debug.
     */
    public static void parseFile(String filename, boolean debug)
    {
        BufferedReader r = null;
        try
        {
            r = new BufferedReader(new InputStreamReader(new FileInputStream(filename)));
            new TGParser(r, debug).parse();
        }
        catch (FileNotFoundException ex) {
            ex.printStackTrace();
        }
        finally
        {
            if (r != null)
            {
                try
                {
                    r.close();
                }
                catch (IOException e)
                {
                    e.printStackTrace();
                }
            }
        }
    }
    /**
     * Constructor method.
     */
    private TGParser(Reader r, boolean debug)
    {
        this(r);
        if (debug)
        {
            enable_tracing();
        }
        else
        {
            disable_tracing();
        }
    }
}

PARSER_END(TGParser)

/**
 * Lexical Rules.
 */

// Special token.
SPECIAL_TOKEN:
{
      <SPACES: ([" ", "\t", "\n", "r", "\f"])+>  // white spaces.
    | <LINE_COMMENT :"//" (~["\n", "\r"])* ("\n" | "\r\n" | "\r")> // single line coment
    | <BLOCK_COMMENT : "/*" (~["*"])* "*" ("*" | (~["*","/"] (~["*"])* "*"))* "/">    // block comment.
}

// Keywords
TOKEN:
{
      <BIT    :     "bit">
    | <BITS   :    "bits">
    | <INT    :     "int">
    | <STRING :  "string">
    | <LIST   :    "list">
    | <CODE   :    "code">
    | <DAG    :    "dag">
    | <CLASS  :   "class">
    | <DEF    :     "def">
    | <FIELD  :   "field">
    | <LET    :     "let">
    | <IN     :      "in">
    | <SRATOK :    "!sra">
    | <SRLTOK :    "!srl">
    | <SHLTOK :    "!shl">
    | <STRCONCATTOK: "!strconcat">
}

// Any legal alpha character or '_'.
TOKEN:
{
    <ALPHA: ["a"-"z", "A"-"Z", "_"]>
}

TOKEN:
{
    <DIGIT: ["0"-"9"]>
}

// Integer literal.
TOKEN:
{
    <INTVAL: (["+", "-"])? ["1"-"9"] (<DIGIT>)* | "0" ["X","x"] (<DIGIT> | ["a"-"f","A"-"F"])+ | "0b" (["0","1"])+ >
}

// Identifier.
TOKEN:
{
    <IDENTIFIER: <ALPHA> (<ALPHA> | <DIGIT>)*>
}

// VarName.
TOKEN:
{
    <VARNAME: "$" <ALPHA> (<ALPHA>| <DIGIT>)*>
}

// String literal.
TOKEN:
{
    <STRINGVAL: "\"" (~["\"", "\\", "\n", "\r"])* "\"">
}

// include string.
TOKEN:
{
    <INCLUDE_STR: "include" (" "|"\t"|"\n")+ "\"" (~["\""])* "\"">
}

// code fragment.
TOKEN:
{
    <CODE_FRAGMENT: "[" "{" ( (~["}"])+ | "}" ~["}"] )* "}" "]">
}

// punctuation tokens.
TOKEN:
{
     <PLUS: "+">
    |<MINUS: "-">
    |<LBRAKET: "[">
    |<RBRAKET: "]">
    |<LBRACE: "{">
    |<RBRACE: "}">
    |<LPAREN: "(">
    |<RPAREN: ")">
    |<COLON: ":">
    |<SEMI: ";">
    |<DOT: ".">
    |<COMMA: ",">
    |<EQ: "=">
    |<QUESTION: "?">
    |<POUND: "#">
}

Record parseClassID():
{
    Token t;
    Record ret;
}
{
    t = <IDENTIFIER>
    {
        ret = records.getClass(t.image);
        if (ret == null)
        {
            tokError("Couldn't find class '" + t.image+"'!\n");
            System.exit(-1);
        }
        return ret;
    }
}

RecTy parseType():
{
    Token t;
    RecTy ty;
    Record res;
}
{
    <STRING> { return new StringRecTy(); }
    | <BIT> { return new BitRecTy(); }
    | <BITS> "<" t = <INTVAL> ">"{ return new BitsRecTy(Integer.parseInt(t.image));}
    | <INT> { return new IntRecTy(); }
    | <LIST> "<" ty = parseType() ">" { return new ListRecTy(ty); }
    | <CODE> { return new CodeRecTy(); }
    | <DAG> { return new DagRecTy(); }
    | res = parseClassID() {return new RecordRecTy(res);}
}

int parseOptPrefix():{}
{
    {}{return 0;}
    <FIELD> { return 1;}
}

Init parseOptValue():{Init val;}
{
    <EQ> val = parseValue() { return val; }
    // empty.
    | {} {return null;}
}

Init parseIDValue():
{
  Token t;
}
{
  t = <IDENTIFIER>
  {
    Record d;
    RecordVal rv = (curRec != null ? curRec.getValue(t.image) : null);
    if (rv != null)
      return new VarInit(t.image, rv.getType());
    else if (curRec != null && curRec.isTemplateArg(curRec.getName()+":"+t.image))
    {
        rv = curRec.getValue(curRec.getName()+":"+t.image);
        assert rv != null:"Template arg does not exist!";
        return new VarInit(curRec.getName() + ":"+t.image, rv.getType());
    }
    else if ((d = records.getDef(t.image)) != null)
    {
        return new DefInit(d);
    }
    else
    {
        tokError("Variable not defined: '" + t.image + "'!\n");
        System.exit(-1);
    }
  }
}

Init parseValueHead():
{
    Init res, res2;
    Token t;
    ArrayList<Init> list;
    ArrayList<Pair<Init, String>> dagList;
}
{
    LOOKAHEAD(<IDENTIFIER>)
    res = parseIDValue()
    {
        return res;
    }
    | t = <INTVAL>
    {
        return new IntInit(Integer.parseInt(t.image));
    }
    | t = <STRINGVAL>
    {
        return new StringInit(t.image);
    }
    |t = <CODE_FRAGMENT>
    {
        return new CodeInit(t.image);
    }
    | <QUESTION>
    {
        return UnsetInit.getInstance();
    }
    | <LBRACE> list = parseValueList() <RBRACE>
    {
        int sz = list.size();
        BitsInit init = new BitsInit(sz);
        for (int i = 0; i < sz; i++)
        {
            Init bit = list.get(i).convertInitializerTo(new BitRecTy());
            if (bit == null)
            {
                tokError("Element #" + i + " (" + bit.toString() + ") is not convertable to a bit!\n");
                System.exit(-1);
            }
            init.setBit(sz - i - 1, bit);
        }
        return init;
    }
    | t = <IDENTIFIER> "<" list = parseValueListNE() ">"
    {
        // This is a CLASS<initvalslist> expression.  This is supposed to synthesize
        // a new anonymous definition, deriving from CLASS<initvalslist> with no
        // body.
        Record klass = records.getClass(t.image);
        if (klass == null)
        {
            tokError("Expected a class, got '"+t.image+"'!\n");
            System.exit(-1);
        }
        Record oldRec = curRec;
        // Create the new record, set it as CurRec temporarily.
        curRec = new Record("anonymous.val."+(anonCounter++));
        addSubClass(klass, list); // Add info about the subclass to the curRec.

        curRec.resolveReferences();

        records.addDef(curRec);
        // The result of the expression is a reference to the new record.
        Init ret = new DefInit(curRec);

        // Restore the old CurRec
        curRec = oldRec;
        return ret;
    }
    | <LBRAKET> list = parseValueList() <RBRAKET>
    {
        return new ListInit(list);
    }
    | <LPAREN> res = parseIDValue() dagList = parseDagArgList() <RPAREN>
    {
        return new DagInit(res, dagList);
    }
    | <SHLTOK> <LPAREN> res = parseValue() <COMMA> res2 = parseValue() <RPAREN>
    {
        return new BinOpInit(BinOpInit.BinaryOp.SHL, res, res2).fold();
    }
    | <SRATOK> <LPAREN> res = parseValue() <COMMA> res2 = parseValue() <RPAREN>
    {
        return new BinOpInit(BinOpInit.BinaryOp.SRA, res, res2).fold();
    }
    | <SRLTOK> <LPAREN> res = parseValue() <COMMA> res2 = parseValue() <RPAREN>
    {
        return new BinOpInit(BinOpInit.BinaryOp.SRL, res, res2).fold();
    }
    | <STRCONCATTOK> <LPAREN> res = parseValue() <COMMA> res2 = parseValue() <RPAREN>
    {
        return new BinOpInit(BinOpInit.BinaryOp.STRCONCAT, res, res2).fold();
    }
}

Init parseValueRest(Init res):
{
    Token t;
    ArrayList<Init> list;
    TIntArrayList bitlist;
}
{
    "." t = <IDENTIFIER>
    {
        if (res.getFieldType(t.image) == null)
        {
            tokError("Cannot access field '" + t.image + "' of value '" + res.toString() + "'!\n");
            System.exit(-1);
        }
        res = new FieldInit(res, t.image);
    }
    | "{" bitlist = parseBitList() "}"
    {
        Init ret = res.convertInitializerBitRange(bitlist);
        if (ret == null)
        {
            tokError("Invalid bit range for value '"+res.toString() + "'!\n");
            System.exit(-1);
        }
        res = ret;
    }
    |
    "[" bitlist = parseBitList() "]"
    {
        Init ret = res.convertIntListSlice(bitlist);
        if (ret == null)
        {
            tokError("Invalid list slice for value '" + res.toString() + "'!\n");
            System.exit(-1);
        }
        res = ret;
    }
    {
        return res;
    }
}

Init parseValue():
{
    Init res;
    Token t;
    ArrayList<Init> list;
    TIntArrayList bitlist;
}
{
    res = parseValueHead()
    (
        res = parseValueRest(res)
    )*
    {
        return res;
    }
}

String parseOptVarName():
{
    Token t;
}
{
    <COLON> t = <VARNAME>
    {
        return t.image;
    }
    |
    // empty.
    {return new String();}
}

ArrayList<Pair<Init, String>> parseDagArgListNE():
{
    Init res;
    String varname;
    ArrayList<Pair<Init, String>> ret = new ArrayList<Pair<Init, String>>();
}
{
    res = parseValue() varname = parseOptVarName()
    {
        ret.add(new Pair<Init, String>(res, varname));
    }
    (res = parseValue() varname = parseOptVarName()
    {
        ret.add(new Pair<Init, String>(res, varname));
    }
    )*
    {
        return ret;
    }
}

ArrayList<Pair<Init, String>> parseDagArgList():
{
    ArrayList<Pair<Init, String>> ret;
}
{
    ret = parseDagArgListNE()
    {
        return ret;
    }
    |// empty.
    { return new ArrayList<Pair<Init, String>>();}
}

void parseRBitListRest(TIntArrayList list):
{
    Token t, t2;
}
{
    LOOKAHEAD(<INTVAL> "-")
    t=<INTVAL> "-" t2=<INTVAL>
    {
        int x = Integer.parseInt(t.image);
        int y = Integer.parseInt(t2.image);
        if (x < 0 || y < 0)
        {
            tokError("Invalid range: " + x + "-" + y + "!\n");
            System.exit(-1);
        }
        if (x < y)
        {
            for (int i = x; i <= y; i++)
                list.add(i);
        }
        else
        {
            for (int i = x; i >=y; i--)
                list.add(i);
        }
    }
    |LOOKAHEAD(2) t =<INTVAL> t2=<INTVAL>
    {
        int x = Integer.parseInt(t.image);
        int y = Integer.parseInt(t2.image);
        y = -y;
        if (x < 0 || y < 0)
        {
            tokError("Invalid range: " + x + "-" + y + "!\n");
            System.exit(-1);
        }

        if (x < y)
        {
            for (int i = x; i <= y; i++)
                list.add(i);
        }
        else
        {
            for (int i = x; i >= y; i--)
                list.add(i);
        }
    }
    |
    t = <INTVAL>
    {
        list.add(Integer.parseInt(t.image));
    }
}

TIntArrayList parseRBitList():
{
    Token t, t2;
    TIntArrayList list = new TIntArrayList();
}
{
    parseRBitListRest(list)
    (<COMMA> parseRBitListRest(list))*
    {
        return list;
    }
}

TIntArrayList parseBitList():
{
    TIntArrayList ret;
}
{
    ret = parseRBitList() { return ret;}
}

TIntArrayList parseOptBitList():
{
    TIntArrayList ret;
}
{
    "{" ret = parseBitList() "}" {return ret;}
    |
    // empty.
    {return null;}
}

ArrayList<Init> parseValueList():
{
    ArrayList<Init> res;
}
{
    res = parseValueListNE() { return res; }
    |
    // empty.
    { return new ArrayList<Init>(); }

}

ArrayList<Init> parseValueListNE():
{
    Init ii;
    ArrayList<Init> ret = new ArrayList<Init>();
}
{
    ii = parseValue()
    {
        ret.add(ii);
    }
    ("," ii = parseValue()
    {
        ret.add(ii);
    })*
    {
        return ret;
    }
}

String parseDeclaration():
{
    Token t;
    int prefix;
    RecTy ty;
    Init ii;
}
{
    prefix = parseOptPrefix() ty = parseType() t = <IDENTIFIER> ii = parseOptValue()
    {
        String decName = t.image;
        if (parseTemplateArgs)
            decName = curRec.getName()+ ":" + decName;
        addValue(new RecordVal(decName, ty, prefix));
        setValue(decName, null, ii);
        return decName;
    }
}

void parseBodyItem():
{
    Token t;
    TIntArrayList bits;
    Init val;
}
{
    parseDeclaration() ";" {}
    | <LET> t = <IDENTIFIER> bits = parseOptBitList() <EQ> val=parseValue() <SEMI>
    {
        setValue(t.image, bits, val);
    }
}

void parseBodyList():{}
{
    {}{/*empty*/} (parseBodyItem())*
}

void parseBody():{}
{
    <SEMI>
    | <LBRACE> parseBodyList() <RBRACE> {}
}

SubClassReference parseSubClassReference():
{
    Record rec;
    SubClassReference ret;
    ArrayList<Init> templateArgs;
}
{
    LOOKAHEAD(2)
    rec = parseClassID() "<" templateArgs = parseValueListNE() ">"
    {
        return new SubClassReference(rec, templateArgs);
    }

    | rec = parseClassID()
    {
        return new SubClassReference(rec, new ArrayList<Init>());
    }
}

ArrayList<SubClassReference> parseClassListNE():
{
    ArrayList<SubClassReference> ret = new ArrayList<SubClassReference>();
    SubClassReference res;
}
{
    res = parseSubClassReference()
    {
        ret.add(res);
    }
    (
        <COMMA> res = parseSubClassReference()
        {
            ret.add(res);
        }
    )*
    {
        return ret;
    }
}

ArrayList<SubClassReference> parseClassList():
{
    ArrayList<SubClassReference> ret;
}
{
    <COLON> ret = parseClassListNE()
    {
        return ret;
    }
    | // empty.
    {
        return new ArrayList<SubClassReference>();
    }
}

void parseDeclListNE():
{
    String arg;
}
{
    arg = parseDeclaration()
    {
        curRec.addTemplateArg(arg);
    }
    (
        <COMMA> arg = parseDeclaration()
        {
            curRec.addTemplateArg(arg);
        }
    )*
}

void parseTemplateArgList():{}
{
    "<" parseDeclListNE()">"
}

void parseOptTemplateArgList():{}
{
    parseTemplateArgList() {}
    |
    // empty.
    {}
}

String parseOptID():
{
    Token t;
}
{
    t = <IDENTIFIER> {return t.image; }
    | // empty.
    {
        return "anonymous."+ (anonCounter++);
    }
}

String parseObjectName():
{
    String id;
}
{
    id = parseOptID()
    {
        return id;
    }
}

void parseClassName():
{
    String name;
}
{
    name = parseObjectName()
    {
        // If a class of this name already exists, it must be a forward ref.
        if ((curRec = records.getClass(name)) != null)
        {
            // If the body was previously defined, this is an error.
            if (!(curRec.getValues().isEmpty()
&& !curRec.getSuperClasses().isEmpty() &&
curRec.getTemplateArgs().isEmpty()))
            {
                tokError("Class '" + curRec.getName() + "' already defined!\n");
                System.exit(-1);
            }
        }
        else
        {
            // If this is the first reference to this class, create and add it.
            curRec = new Record(name);
            records.addClass(curRec);
        }
    }
}

void parseDefName():
{
    String name;
}
{
    name = parseObjectName()
    {
        curRec = new Record(name);

        // Ensure redefinition doesn't happen.
        if (records.getDef(curRec.getName()) != null)
        {
            tokError("Def '" + name + "' already defined!\n");
            System.exit(-1);
        }
        records.addDef(curRec);
    }
}

Record parseObjectBody():
{
    ArrayList<SubClassReference> subs;
    Record ret;
}
{
    subs = parseClassList()
    {
        for (SubClassReference sub : subs)
        {
            addSubClass(sub.rec, sub.templateArgs);
        }

        // Process any variables on the set stack.
        for (ArrayList<LetRecord> list : letStack)
        {
            for (LetRecord letCmd : list)
            {
                setValue(letCmd.name, letCmd.hasBits? letCmd.bits : null, letCmd.value);
            }
        }
    }
    parseBody()
    {
        ret = curRec;
        curRec = null;
        return ret;
    }
}

Record parseClassInst():
{
    Record ret;
}
{
    <CLASS> parseClassName()
    {
        parseTemplateArgs = true;
    } parseOptTemplateArgList()
    {
        parseTemplateArgs = false;
    } ret = parseObjectBody()
    {
        return ret;
    }
}

Record parseDefInst():
{
    Record ret;
}
{
    <DEF> parseDefName() ret = parseObjectBody()
    {
        ret.resolveReferences();
        // If ObjectBody has template arguments, it's an error.
        assert ret.getTemplateArgs().isEmpty() :"How does this get template args?";
        return ret;
    }
}

void parseLetItem():
{
    Token t;
    TIntArrayList bits;
    Init val;
}
{
    t = <IDENTIFIER> bits = parseOptBitList() <EQ> val = parseValue()
    {
        letStack.peek().add(new LetRecord(t.image, bits, val));
    }
}

void parseLetList():{}
{
    parseLetItem() (<COMMA> parseLetItem())*
}

/**
 * // LETCommand - A 'LET' statement start.
 */
void parseLetCommand():{}
{
    <LET>
    {
        letStack.push(new ArrayList<LetRecord>());
    }
    parseLetList() <IN>
}

void parseLetRest():{}
{
    <LBRACE> parseObjectList() <RBRACE>
    {
        letStack.pop();
    }
    | parseObject()
    {
        letStack.pop();
    }
}

void parseLetInst():{}
{
    parseLetCommand() parseLetRest()
}
void parseObject():{}
{
    parseClassInst()
    | parseDefInst()
    | parseLetInst()
}

void parseObjectList():{}
{
    parseObject() {} (parseObject())* <EOF>
}

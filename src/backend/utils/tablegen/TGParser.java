/* TGParser.java */
/* Generated By:JavaCC: Do not edit this line. TGParser.java */
package backend.utils.tablegen;

import gnu.trove.list.array.TIntArrayList;
import tools.Pair;
import backend.utils.tablegen.Init.*;
import backend.utils.tablegen.RecTy.*;

import java.io.*;
import java.util.ArrayList;
import java.util.Stack;

import static backend.utils.tablegen.Record.records;

public final class TGParser implements TGParserConstants
{
    public static final class LetRecord
    {
        String name;
        TIntArrayList bits;
        Init value;
        boolean hasBits;

        LetRecord(String name, TIntArrayList bits, Init val)
        {
            this.name = name;
            value = val;
            hasBits = bits != null;
            if (hasBits)
                this.bits = bits;
        }
    }

    public static final class SubClassReference
    {
        Record rec;
        ArrayList<Init> templateArgs;

        SubClassReference(Record rec, ArrayList<Init> templateArgs)
        {
            this.rec = rec;
            this.templateArgs = templateArgs;
        }
    }

    /**
     * This class is used for saving the status of current parsing file, contains
     * filename, r (the Reader object to reading filename),
     * inputStream(currently at the last character consumed for include str),
     * fileLineNo (the current line no when encountering include str.)
     */
    public static final class IncludeRec
    {
        String filename;
        Reader r;
        SimpleCharStream inputStream;
        int startLine, startColumn;

        IncludeRec(String filename, Reader r)
        {
            this.filename = filename;
            this.r = r;
        }
    }

    private final Stack<ArrayList<LetRecord>> letStack = new Stack<ArrayList<LetRecord>>();
    private boolean parseTemplateArgs = false;

    private int anonCounter = 0;
    private Record curRec = null;

    static ArrayList<String> includeDirectories;
    static final Stack<IncludeRec> includeStack = new Stack<IncludeRec>();

    /**
     * This method is called when an error needed to be reported.
     */
    static void tokError(String msg)
    {
        System.err.println(msg);
    }

    /**
     * This is the entry point for parsing a table-gen grammar file.
     */
    public void parse()
    {
        try
        {
            parseObjectList();
        }
        catch (ParseException e)
        {
            e.printStackTrace();
        }
    }

    private void addValue(RecordVal rv)
    {
        RecordVal rval = curRec.getValue(rv.getName());
        if (rval != null)
        {
            tokError("New definition of '" + rv.getName() + "' of type '" + rv
                    .getType().toString()
                    + "' is incompatible with previous definition of type '"
                    + rval.getType().toString() + "'!\u005cn");
            System.exit(-1);
        }
        else
            curRec.addValue(rv);
    }

    private void addSuperClass(Record rc)
    {
        if (curRec.isSubClassOf(rc))
        {
            tokError("Already subclass of '" + rc.getName() + "'!\u005cn");
            System.exit(-1);
        }
        curRec.addSuperClass(rc);
    }

    private void setValue(String valName, TIntArrayList bitlist, Init val)
    {
        if (val == null)
            return;

        RecordVal rv = curRec.getValue(valName);
        if (rv == null)
        {
            tokError("Value '" + valName + "' Unknown!\u005cn");
            System.exit(-1);
        }

        // Do not allow assignments like 'X = X'.  This will just cause infinite loops
        // in the resolution machinery.
        if (bitlist == null)
        {
            if (val instanceof VarInit)
            {
                VarInit vi = (VarInit) val;
                if (vi.getName().equals(valName))
                    return;
            }
        }

        // If we are assigning to a subset of the bits in the value... then we must be
        // assigning to a field of BitsRecTy, which must have a BitsInit initializer.
        if (bitlist != null)
        {
            if (!(rv.getValue() instanceof BitsInit))
            {
                tokError("Value '" + valName + "' is not a bits type!\u005cn");
                System.exit(-1);
            }

            BitsInit curVal = (BitsInit) rv.getValue();
            // Convert the incoming value to a bits type of the appropriate size...
            Init bi = val.convertInitializerTo(new BitsRecTy(bitlist.size()));
            if (bi == null)
            {
                val.convertInitializerTo(new BitsRecTy(bitlist.size()));
                tokError("Initializer '" + val.toString()
                        + "' not compatible with bit range!\u005cn");
                System.exit(-1);
            }

            // We should have a BitsInit type now...
            assert bi instanceof BitsInit;
            BitsInit binit = (BitsInit) bi;

            BitsInit newVal = new BitsInit(curVal.getNumBits());
            for (int i = 0, e = bitlist.size(); i < e; i++)
            {
                int b = bitlist.get(i);
                if (newVal.getBit(b) != null)
                {
                    tokError("Cannot set bit #" + b + " of value '" + valName
                            + "' more than once!\u005cn");
                    System.exit(-1);
                }
                newVal.setBit(b, binit.getBit(i));
            }

            for (int i = 0, e = curVal.getNumBits(); i < e; i++)
            {
                if (newVal.getBit(i) == null)
                {
                    newVal.setBit(i, curVal.getBit(i));
                }
            }
            val = newVal;
        }
        if (rv.setValue(val))
        {
            tokError("Value '" + valName + "' of type '" + rv.getType()
                    .toString() + "' is incompatible with initializer '" + val
                    .toString() + "'!\u005cn");
            System.exit(-1);
        }
    }

    /**
     * Add {@code rec} as a subclass to curRec, resolving templateArgs as
     * rec's template arguments.
     */
    private void addSubClass(Record rec, ArrayList<Init> templateArgs)
    {
        ArrayList<RecordVal> vals = rec.getValues();
        for (RecordVal rv : vals)
            addValue(rv);

        ArrayList<String> targs = rec.getTemplateArgs();
        if (targs.size() < templateArgs.size())
        {
            tokError(
                    "ERROR: More template args specified than expected!\u005cn");
            System.exit(-1);
        }
        else
        {
            for (int i = 0, e = targs.size(); i < e; i++)
            {
                String arg = targs.get(i);
                if (i < templateArgs.size())
                {
                    // set the value for template argument.
                    setValue(arg, null, templateArgs.get(i));

                    // resolve any reference to this template arg as the targ's value.
                    curRec.resolveReferencesTo(curRec.getValue(arg));

                    curRec.removeValue(arg);
                }
                else if (!curRec.getValue(arg).getValue().isComplete())
                {
                    tokError(
                            "ERROR: Value not specified for template argument #"
                                    + i + " (" + arg + ") of suclass '" + rec
                                    .getName() + "'!\u005cn");
                    System.exit(-1);
                }
            }
        }

        // Since everything went well, we can now set the "superclass" list for the
        // current record.
        ArrayList<Record> supers = rec.getSuperClasses();
        for (Record sc : supers)
            addSuperClass(sc);

        addSuperClass(rec);
    }

    /**
     * This is the entry point to parsing a single file.
     *
     * @filename The input file name.
     */
    public static void parseFile(String filename, ArrayList<String> includeDirs)
    {
        parseFile(filename, includeDirs, false);
    }

    /**
     * This is the entry point to parsing a single file.
     *
     * @filename The input file name.
     * @debug The flag to indicating whether enable debug.
     */
    public static void parseFile(String filename, ArrayList<String> includeDirs,
            boolean debug)
    {
        BufferedReader r = null;
        try
        {
            IncludeRec incRec = null;
            if (!filename.equals("-"))
            {
                r = new BufferedReader(
                        new InputStreamReader(new FileInputStream(filename)));
                incRec = new IncludeRec(filename, r);
            }
            else
            {
                r = new BufferedReader(new InputStreamReader(System.in));
                incRec = new IncludeRec("stdin", r);
            }

            new TGParser(r, incRec, includeDirs, debug).parse();
        }
        catch (FileNotFoundException ex)
        {
            System.err.println("Could not open file '" + filename + "'!");
            System.exit(-1);
        }
        finally
        {
            if (r != null)
            {
                try
                {
                    r.close();
                }
                catch (IOException e)
                {
                    System.err.println(e.toString());
                    System.exit(-1);
                }
            }
        }
    }

    /**
     * Constructor method.
     */
    private TGParser(Reader r, IncludeRec incRec, ArrayList<String> includeDirs,
            boolean debug)
    {
        this(r);
        includeStack.push(incRec);
        includeDirectories = includeDirs;
        if (debug)
        {
            enable_tracing();
        }
        else
        {
            disable_tracing();
        }
    }

    final public Record parseClassID() throws ParseException
    {
        trace_call("parseClassID");
        try
        {
            Token t;
            Record ret;
            t = jj_consume_token(IDENTIFIER);
            ret = records.getClass(t.image);
            if (ret == null)
            {
                tokError("Couldn't find class '" + t.image + "'!\u005cn");
                System.exit(-1);
            }
            {
                if ("" != null)
                    return ret;
            }
            throw new Error("Missing return statement in function");
        }
        finally
        {
            trace_return("parseClassID");
        }
    }

    final public RecTy parseType() throws ParseException
    {
        trace_call("parseType");
        try
        {
            Token t;
            RecTy ty;
            Record res;
            switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk)
            {
                case STRING:
                {
                    jj_consume_token(STRING);
                    {
                        if ("" != null)
                            return new StringRecTy();
                    }
                    break;
                }
                case BIT:
                {
                    jj_consume_token(BIT);
                    {
                        if ("" != null)
                            return new BitRecTy();
                    }
                    break;
                }
                case BITS:
                {
                    jj_consume_token(BITS);
                    jj_consume_token(43);
                    t = jj_consume_token(INTVAL);
                    jj_consume_token(44);
                    {
                        if ("" != null)
                            return new BitsRecTy(Integer.parseInt(t.image));
                    }
                    break;
                }
                case INT:
                {
                    jj_consume_token(INT);
                    {
                        if ("" != null)
                            return new IntRecTy();
                    }
                    break;
                }
                case LIST:
                {
                    jj_consume_token(LIST);
                    jj_consume_token(43);
                    ty = parseType();
                    jj_consume_token(44);
                    {
                        if ("" != null)
                            return new ListRecTy(ty);
                    }
                    break;
                }
                case CODE:
                {
                    jj_consume_token(CODE);
                    {
                        if ("" != null)
                            return new CodeRecTy();
                    }
                    break;
                }
                case DAG:
                {
                    jj_consume_token(DAG);
                    {
                        if ("" != null)
                            return new DagRecTy();
                    }
                    break;
                }
                case IDENTIFIER:
                {
                    res = parseClassID();
                    {
                        if ("" != null)
                            return new RecordRecTy(res);
                    }
                    break;
                }
                default:
                    jj_la1[0] = jj_gen;
                    jj_consume_token(-1);
                    throw new ParseException();
            }
            throw new Error("Missing return statement in function");
        }
        finally
        {
            trace_return("parseType");
        }
    }

    final public int parseOptPrefix() throws ParseException
    {
        trace_call("parseOptPrefix");
        try
        {
            switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk)
            {
                case FIELD:
                {
                    jj_consume_token(FIELD);
                    {
                        if ("" != null)
                            return 1;
                    }
                    break;
                }
                default:
                    jj_la1[1] = jj_gen;

                {
                    if ("" != null)
                        return 0;
                }
            }
            throw new Error("Missing return statement in function");
        }
        finally
        {
            trace_return("parseOptPrefix");
        }
    }

    final public Init parseOptValue() throws ParseException
    {
        trace_call("parseOptValue");
        try
        {
            Init val;
            switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk)
            {
                case EQ:
                {
                    jj_consume_token(EQ);
                    val = parseValue();
                    {
                        if ("" != null)
                            return val;
                    }
                    break;
                }
                default:
                    jj_la1[2] = jj_gen;

                {
                    if ("" != null)
                        return null;
                }
            }
            throw new Error("Missing return statement in function");
        }
        finally
        {
            trace_return("parseOptValue");
        }
    }

    final public Init parseIDValue() throws ParseException
    {
        trace_call("parseIDValue");
        try
        {
            Token t;
            t = jj_consume_token(IDENTIFIER);
            Record d;
            RecordVal rv = (curRec != null ? curRec.getValue(t.image) : null);
            if (rv != null)
            {
                if ("" != null)
                    return new VarInit(t.image, rv.getType());
            }
            else if (curRec != null && curRec
                    .isTemplateArg(curRec.getName() + ":" + t.image))
            {
                rv = curRec.getValue(curRec.getName() + ":" + t.image);
                assert rv != null : "Template arg does not exist!";
                {
                    if ("" != null)
                        return new VarInit(curRec.getName() + ":" + t.image,
                                rv.getType());
                }
            }
            else if ((d = records.getDef(t.image)) != null)
            {
                {
                    if ("" != null)
                        return new DefInit(d);
                }
            }
            else
            {
                tokError("Variable not defined: '" + t.image + "'!\u005cn");
                System.exit(-1);
            }
            throw new Error("Missing return statement in function");
        }
        finally
        {
            trace_return("parseIDValue");
        }
    }

    final public Init parseValueHead() throws ParseException
    {
        trace_call("parseValueHead");
        try
        {
            Init res, res2;
            Token t;
            ArrayList<Init> list;
            ArrayList<Pair<Init, String>> dagList;
            switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk)
            {
                case INTVAL:
                {
                    t = jj_consume_token(INTVAL);
                    {
                        if ("" != null)
                            return new IntInit(Integer.parseInt(t.image));
                    }
                    break;
                }
                case STRINGVAL:
                {
                    t = jj_consume_token(STRINGVAL);
                    {
                        if ("" != null)
                            return new StringInit(t.image);
                    }
                    break;
                }
                case CODE_FRAGMENT:
                {
                    t = jj_consume_token(CODE_FRAGMENT);
                    {
                        if ("" != null)
                            return new CodeInit(t.image);
                    }
                    break;
                }
                case QUESTION:
                {
                    jj_consume_token(QUESTION);
                    {
                        if ("" != null)
                            return UnsetInit.getInstance();
                    }
                    break;
                }
                case LBRACE:
                {
                    jj_consume_token(LBRACE);
                    list = parseValueList();
                    jj_consume_token(RBRACE);
                    int sz = list.size();
                    BitsInit init = new BitsInit(sz);
                    for (int i = 0; i < sz; i++)
                    {
                        Init bit = list.get(i)
                                .convertInitializerTo(new BitRecTy());
                        if (bit == null)
                        {
                            tokError("Element #" + i + " (" + bit.toString()
                                    + ") is not convertable to a bit!\u005cn");
                            System.exit(-1);
                        }
                        init.setBit(sz - i - 1, bit);
                    }
                    {
                        if ("" != null)
                            return init;
                    }
                    break;
                }
                default:
                    jj_la1[3] = jj_gen;
                    if (jj_2_1(2147483647))
                    {
                        t = jj_consume_token(IDENTIFIER);
                        jj_consume_token(43);
                        list = parseValueListNE();
                        jj_consume_token(44);
                        // This is a CLASS<initvalslist> expression.  This is supposed to synthesize
                        // a new anonymous definition, deriving from CLASS<initvalslist> with no
                        // body.
                        Record klass = records.getClass(t.image);
                        if (klass == null)
                        {
                            tokError("Expected a class, got '" + t.image
                                    + "'!\u005cn");
                            System.exit(-1);
                        }
                        Record oldRec = curRec;
                        // Create the new record, set it as CurRec temporarily.
                        curRec = new Record("anonymous.val." + (anonCounter++));
                        addSubClass(klass,
                                list); // Add info about the subclass to the curRec.

                        curRec.resolveReferences();

                        records.addDef(curRec);
                        // The result of the expression is a reference to the new record.
                        Init ret = new DefInit(curRec);

                        // Restore the old CurRec
                        curRec = oldRec;
                        {
                            if ("" != null)
                                return ret;
                        }
                    }
                    else
                    {
                        switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk)
                        {
                            case LBRAKET:
                            {
                                jj_consume_token(LBRAKET);
                                list = parseValueList();
                                jj_consume_token(RBRAKET);
                                {
                                    if ("" != null)
                                        return new ListInit(list);
                                }
                                break;
                            }
                            case LPAREN:
                            {
                                jj_consume_token(LPAREN);
                                res = parseIDValue();
                                dagList = parseDagArgList();
                                jj_consume_token(RPAREN);
                                {
                                    if ("" != null)
                                        return new DagInit(res, dagList);
                                }
                                break;
                            }
                            case SHLTOK:
                            {
                                jj_consume_token(SHLTOK);
                                jj_consume_token(LPAREN);
                                res = parseValue();
                                jj_consume_token(COMMA);
                                res2 = parseValue();
                                jj_consume_token(RPAREN);
                                {
                                    if ("" != null)
                                        return new BinOpInit(
                                                BinOpInit.BinaryOp.SHL, res,
                                                res2).fold();
                                }
                                break;
                            }
                            case SRATOK:
                            {
                                jj_consume_token(SRATOK);
                                jj_consume_token(LPAREN);
                                res = parseValue();
                                jj_consume_token(COMMA);
                                res2 = parseValue();
                                jj_consume_token(RPAREN);
                                {
                                    if ("" != null)
                                        return new BinOpInit(
                                                BinOpInit.BinaryOp.SRA, res,
                                                res2).fold();
                                }
                                break;
                            }
                            case SRLTOK:
                            {
                                jj_consume_token(SRLTOK);
                                jj_consume_token(LPAREN);
                                res = parseValue();
                                jj_consume_token(COMMA);
                                res2 = parseValue();
                                jj_consume_token(RPAREN);
                                {
                                    if ("" != null)
                                        return new BinOpInit(
                                                BinOpInit.BinaryOp.SRL, res,
                                                res2).fold();
                                }
                                break;
                            }
                            case STRCONCATTOK:
                            {
                                jj_consume_token(STRCONCATTOK);
                                jj_consume_token(LPAREN);
                                res = parseValue();
                                jj_consume_token(COMMA);
                                res2 = parseValue();
                                jj_consume_token(RPAREN);
                                {
                                    if ("" != null)
                                        return new BinOpInit(
                                                BinOpInit.BinaryOp.STRCONCAT,
                                                res, res2).fold();
                                }
                                break;
                            }
                            case IDENTIFIER:
                            {
                                res = parseIDValue();
                                {
                                    if ("" != null)
                                        return res;
                                }
                                break;
                            }
                            default:
                                jj_la1[4] = jj_gen;
                                jj_consume_token(-1);
                                throw new ParseException();
                        }
                    }
            }
            throw new Error("Missing return statement in function");
        }
        finally
        {
            trace_return("parseValueHead");
        }
    }

    final public Init parseValueRest(Init res) throws ParseException
    {
        trace_call("parseValueRest");
        try
        {
            Token t;
            ArrayList<Init> list;
            TIntArrayList bitlist;
            switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk)
            {
                case DOT:
                {
                    jj_consume_token(DOT);
                    t = jj_consume_token(IDENTIFIER);
                    if (res.getFieldType(t.image) == null)
                    {
                        tokError("Cannot access field '" + t.image
                                + "' of value '" + res.toString()
                                + "'!\u005cn");
                        System.exit(-1);
                    }
                    {
                        if ("" != null)
                            return new FieldInit(res, t.image);
                    }
                    break;
                }
                case LBRACE:
                {
                    jj_consume_token(LBRACE);
                    bitlist = parseBitList();
                    jj_consume_token(RBRACE);
                    Init ret = res.convertInitializerBitRange(bitlist);
                    if (ret == null)
                    {
                        tokError(
                                "Invalid bit range for value '" + res.toString()
                                        + "'!\u005cn");
                        System.exit(-1);
                    }
                    {
                        if ("" != null)
                            return ret;
                    }
                    break;
                }
                case LBRAKET:
                {
                    jj_consume_token(LBRAKET);
                    bitlist = parseBitList();
                    jj_consume_token(RBRAKET);
                    Init ret = res.convertIntListSlice(bitlist);
                    if (ret == null)
                    {
                        tokError("Invalid list slice for value '" + res
                                .toString() + "'!\u005cn");
                        System.exit(-1);
                    }
                    {
                        if ("" != null)
                            return ret;
                    }
                    break;
                }
                default:
                    jj_la1[5] = jj_gen;
                    jj_consume_token(-1);
                    throw new ParseException();
            }
            throw new Error("Missing return statement in function");
        }
        finally
        {
            trace_return("parseValueRest");
        }
    }

    final public Init parseValue() throws ParseException
    {
        trace_call("parseValue");
        try
        {
            Init res;
            Token t;
            ArrayList<Init> list;
            TIntArrayList bitlist;
            res = parseValueHead();
            label_1:
            while (true)
            {
                switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk)
                {
                    case LBRAKET:
                    case LBRACE:
                    case DOT:
                    {
                        ;
                        break;
                    }
                    default:
                        jj_la1[6] = jj_gen;
                        break label_1;
                }
                res = parseValueRest(res);
            }
            {
                if ("" != null)
                    return res;
            }
            throw new Error("Missing return statement in function");
        }
        finally
        {
            trace_return("parseValue");
        }
    }

    final public String parseOptVarName() throws ParseException
    {
        trace_call("parseOptVarName");
        try
        {
            Token t;
            switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk)
            {
                case COLON:
                {
                    jj_consume_token(COLON);
                    t = jj_consume_token(VARNAME);
                    {
                        if ("" != null)
                            return t.image;
                    }
                    break;
                }
                default:
                    jj_la1[7] = jj_gen;
                {
                    if ("" != null)
                        return new String();
                }
            }
            throw new Error("Missing return statement in function");
        }
        finally
        {
            trace_return("parseOptVarName");
        }
    }

    final public ArrayList<Pair<Init, String>> parseDagArgListNE()
            throws ParseException
    {
        trace_call("parseDagArgListNE");
        try
        {
            Init res;
            String varname;
            ArrayList<Pair<Init, String>> ret = new ArrayList<Pair<Init, String>>();
            res = parseValue();
            varname = parseOptVarName();
            ret.add(new Pair<Init, String>(res, varname));
            label_2:
            while (true)
            {
                switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk)
                {
                    case COMMA:
                    {
                        ;
                        break;
                    }
                    default:
                        jj_la1[8] = jj_gen;
                        break label_2;
                }
                jj_consume_token(COMMA);
                res = parseValue();
                varname = parseOptVarName();
                ret.add(new Pair<Init, String>(res, varname));
            }
            {
                if ("" != null)
                    return ret;
            }
            throw new Error("Missing return statement in function");
        }
        finally
        {
            trace_return("parseDagArgListNE");
        }
    }

    final public ArrayList<Pair<Init, String>> parseDagArgList()
            throws ParseException
    {
        trace_call("parseDagArgList");
        try
        {
            ArrayList<Pair<Init, String>> ret;
            switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk)
            {
                case SRATOK:
                case SRLTOK:
                case SHLTOK:
                case STRCONCATTOK:
                case INTVAL:
                case IDENTIFIER:
                case STRINGVAL:
                case CODE_FRAGMENT:
                case LBRAKET:
                case LBRACE:
                case LPAREN:
                case QUESTION:
                {
                    ret = parseDagArgListNE();
                    {
                        if ("" != null)
                            return ret;
                    }
                    break;
                }
                default:
                    jj_la1[9] = jj_gen;
                {
                    if ("" != null)
                        return new ArrayList<Pair<Init, String>>();
                }
            }
            throw new Error("Missing return statement in function");
        }
        finally
        {
            trace_return("parseDagArgList");
        }
    }

    final public void parseRBitListRest(TIntArrayList list)
            throws ParseException
    {
        trace_call("parseRBitListRest");
        try
        {
            Token t, t2;
            if (jj_2_2(2147483647))
            {
                t = jj_consume_token(INTVAL);
                jj_consume_token(MINUS);
                t2 = jj_consume_token(INTVAL);
                int x = Integer.parseInt(t.image);
                int y = Integer.parseInt(t2.image);
                if (x < 0 || y < 0)
                {
                    tokError("Invalid range: " + x + "-" + y + "!\u005cn");
                    System.exit(-1);
                }
                if (x < y)
                {
                    for (int i = x; i <= y; i++)
                        list.add(i);
                }
                else
                {
                    for (int i = x; i >= y; i--)
                        list.add(i);
                }
            }
            else if (jj_2_3(2))
            {
                t = jj_consume_token(INTVAL);
                t2 = jj_consume_token(INTVAL);
                int x = Integer.parseInt(t.image);
                int y = Integer.parseInt(t2.image);
                y = -y;
                if (x < 0 || y < 0)
                {
                    tokError("Invalid range: " + x + "-" + y + "!\u005cn");
                    System.exit(-1);
                }

                if (x < y)
                {
                    for (int i = x; i <= y; i++)
                        list.add(i);
                }
                else
                {
                    for (int i = x; i >= y; i--)
                        list.add(i);
                }
            }
            else
            {
                switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk)
                {
                    case INTVAL:
                    {
                        t = jj_consume_token(INTVAL);
                        list.add(Integer.parseInt(t.image));
                        break;
                    }
                    default:
                        jj_la1[10] = jj_gen;
                        jj_consume_token(-1);
                        throw new ParseException();
                }
            }
        }
        finally
        {
            trace_return("parseRBitListRest");
        }
    }

    final public TIntArrayList parseRBitList() throws ParseException
    {
        trace_call("parseRBitList");
        try
        {
            Token t, t2;
            TIntArrayList list = new TIntArrayList();
            parseRBitListRest(list);
            label_3:
            while (true)
            {
                switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk)
                {
                    case COMMA:
                    {
                        ;
                        break;
                    }
                    default:
                        jj_la1[11] = jj_gen;
                        break label_3;
                }
                jj_consume_token(COMMA);
                parseRBitListRest(list);
            }
            {
                if ("" != null)
                    return list;
            }
            throw new Error("Missing return statement in function");
        }
        finally
        {
            trace_return("parseRBitList");
        }
    }

    final public TIntArrayList parseBitList() throws ParseException
    {
        trace_call("parseBitList");
        try
        {
            TIntArrayList ret;
            ret = parseRBitList();
            {
                if ("" != null)
                    return ret;
            }
            throw new Error("Missing return statement in function");
        }
        finally
        {
            trace_return("parseBitList");
        }
    }

    final public TIntArrayList parseOptBitList() throws ParseException
    {
        trace_call("parseOptBitList");
        try
        {
            TIntArrayList ret;
            switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk)
            {
                case LBRACE:
                {
                    jj_consume_token(LBRACE);
                    ret = parseBitList();
                    jj_consume_token(RBRACE);
                    {
                        if ("" != null)
                            return ret;
                    }
                    break;
                }
                default:
                    jj_la1[12] = jj_gen;
                {
                    if ("" != null)
                        return null;
                }
            }
            throw new Error("Missing return statement in function");
        }
        finally
        {
            trace_return("parseOptBitList");
        }
    }

    final public ArrayList<Init> parseValueList() throws ParseException
    {
        trace_call("parseValueList");
        try
        {
            ArrayList<Init> res;
            switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk)
            {
                case SRATOK:
                case SRLTOK:
                case SHLTOK:
                case STRCONCATTOK:
                case INTVAL:
                case IDENTIFIER:
                case STRINGVAL:
                case CODE_FRAGMENT:
                case LBRAKET:
                case LBRACE:
                case LPAREN:
                case QUESTION:
                {
                    res = parseValueListNE();
                    {
                        if ("" != null)
                            return res;
                    }
                    break;
                }
                default:
                    jj_la1[13] = jj_gen;
                {
                    if ("" != null)
                        return new ArrayList<Init>();
                }
            }
            throw new Error("Missing return statement in function");
        }
        finally
        {
            trace_return("parseValueList");
        }
    }

    final public ArrayList<Init> parseValueListNE() throws ParseException
    {
        trace_call("parseValueListNE");
        try
        {
            Init ii;
            ArrayList<Init> ret = new ArrayList<Init>();
            ii = parseValue();
            ret.add(ii);
            label_4:
            while (true)
            {
                switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk)
                {
                    case COMMA:
                    {
                        ;
                        break;
                    }
                    default:
                        jj_la1[14] = jj_gen;
                        break label_4;
                }
                jj_consume_token(COMMA);
                ii = parseValue();
                ret.add(ii);
            }
            {
                if ("" != null)
                    return ret;
            }
            throw new Error("Missing return statement in function");
        }
        finally
        {
            trace_return("parseValueListNE");
        }
    }

    final public String parseDeclaration() throws ParseException
    {
        trace_call("parseDeclaration");
        try
        {
            Token t;
            int prefix;
            RecTy ty;
            Init ii;
            prefix = parseOptPrefix();
            ty = parseType();
            t = jj_consume_token(IDENTIFIER);
            ii = parseOptValue();
            String decName = t.image;
            if (parseTemplateArgs)
                decName = curRec.getName() + ":" + decName;
            addValue(new RecordVal(decName, ty, prefix));
            setValue(decName, null, ii);
            {
                if ("" != null)
                    return decName;
            }
            throw new Error("Missing return statement in function");
        }
        finally
        {
            trace_return("parseDeclaration");
        }
    }

    final public void parseBodyItem() throws ParseException
    {
        trace_call("parseBodyItem");
        try
        {
            Token t;
            TIntArrayList bits;
            Init val;
            switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk)
            {
                case BIT:
                case BITS:
                case INT:
                case STRING:
                case LIST:
                case CODE:
                case DAG:
                case FIELD:
                case IDENTIFIER:
                {
                    parseDeclaration();
                    jj_consume_token(SEMI);

                    break;
                }
                case LET:
                {
                    jj_consume_token(LET);
                    t = jj_consume_token(IDENTIFIER);
                    bits = parseOptBitList();
                    jj_consume_token(EQ);
                    val = parseValue();
                    jj_consume_token(SEMI);
                    setValue(t.image, bits, val);
                    break;
                }
                default:
                    jj_la1[15] = jj_gen;
                    jj_consume_token(-1);
                    throw new ParseException();
            }
        }
        finally
        {
            trace_return("parseBodyItem");
        }
    }

    final public void parseBodyList() throws ParseException
    {
        trace_call("parseBodyList");
        try
        {
            switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk)
            {
                case BIT:
                case BITS:
                case INT:
                case STRING:
                case LIST:
                case CODE:
                case DAG:
                case FIELD:
                case LET:
                case IDENTIFIER:
                {
                    label_5:
                    while (true)
                    {
                        parseBodyItem();
                        switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk)
                        {
                            case BIT:
                            case BITS:
                            case INT:
                            case STRING:
                            case LIST:
                            case CODE:
                            case DAG:
                            case FIELD:
                            case LET:
                            case IDENTIFIER:
                            {
                                ;
                                break;
                            }
                            default:
                                jj_la1[16] = jj_gen;
                                break label_5;
                        }
                    }
                    break;
                }
                default:
                    jj_la1[17] = jj_gen;

            }
        }
        finally
        {
            trace_return("parseBodyList");
        }
    }

    final public void parseBody() throws ParseException
    {
        trace_call("parseBody");
        try
        {
            switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk)
            {
                case SEMI:
                {
                    jj_consume_token(SEMI);
                    break;
                }
                case LBRACE:
                {
                    jj_consume_token(LBRACE);
                    parseBodyList();
                    jj_consume_token(RBRACE);

                    break;
                }
                default:
                    jj_la1[18] = jj_gen;
                    jj_consume_token(-1);
                    throw new ParseException();
            }
        }
        finally
        {
            trace_return("parseBody");
        }
    }

    final public SubClassReference parseSubClassReference()
            throws ParseException
    {
        trace_call("parseSubClassReference");
        try
        {
            Record rec;
            SubClassReference ret;
            ArrayList<Init> templateArgs;
            if (jj_2_4(2))
            {
                rec = parseClassID();
                jj_consume_token(43);
                templateArgs = parseValueListNE();
                jj_consume_token(44);
                {
                    if ("" != null)
                        return new SubClassReference(rec, templateArgs);
                }
            }
            else
            {
                switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk)
                {
                    case IDENTIFIER:
                    {
                        rec = parseClassID();
                        {
                            if ("" != null)
                                return new SubClassReference(rec,
                                        new ArrayList<Init>());
                        }
                        break;
                    }
                    default:
                        jj_la1[19] = jj_gen;
                        jj_consume_token(-1);
                        throw new ParseException();
                }
            }
            throw new Error("Missing return statement in function");
        }
        finally
        {
            trace_return("parseSubClassReference");
        }
    }

    final public ArrayList<SubClassReference> parseClassListNE()
            throws ParseException
    {
        trace_call("parseClassListNE");
        try
        {
            ArrayList<SubClassReference> ret = new ArrayList<SubClassReference>();
            SubClassReference res;
            res = parseSubClassReference();
            ret.add(res);
            label_6:
            while (true)
            {
                switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk)
                {
                    case COMMA:
                    {
                        ;
                        break;
                    }
                    default:
                        jj_la1[20] = jj_gen;
                        break label_6;
                }
                jj_consume_token(COMMA);
                res = parseSubClassReference();
                ret.add(res);
            }
            {
                if ("" != null)
                    return ret;
            }
            throw new Error("Missing return statement in function");
        }
        finally
        {
            trace_return("parseClassListNE");
        }
    }

    final public ArrayList<SubClassReference> parseClassList()
            throws ParseException
    {
        trace_call("parseClassList");
        try
        {
            ArrayList<SubClassReference> ret;
            switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk)
            {
                case COLON:
                {
                    jj_consume_token(COLON);
                    ret = parseClassListNE();
                    {
                        if ("" != null)
                            return ret;
                    }
                    break;
                }
                default:
                    jj_la1[21] = jj_gen;
                {
                    if ("" != null)
                        return new ArrayList<SubClassReference>();
                }
            }
            throw new Error("Missing return statement in function");
        }
        finally
        {
            trace_return("parseClassList");
        }
    }

    final public void parseDeclListNE() throws ParseException
    {
        trace_call("parseDeclListNE");
        try
        {
            String arg;
            arg = parseDeclaration();
            curRec.addTemplateArg(arg);
            label_7:
            while (true)
            {
                switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk)
                {
                    case COMMA:
                    {
                        ;
                        break;
                    }
                    default:
                        jj_la1[22] = jj_gen;
                        break label_7;
                }
                jj_consume_token(COMMA);
                arg = parseDeclaration();
                curRec.addTemplateArg(arg);
            }
        }
        finally
        {
            trace_return("parseDeclListNE");
        }
    }

    final public void parseTemplateArgList() throws ParseException
    {
        trace_call("parseTemplateArgList");
        try
        {
            jj_consume_token(43);
            parseDeclListNE();
            jj_consume_token(44);
        }
        finally
        {
            trace_return("parseTemplateArgList");
        }
    }

    final public void parseOptTemplateArgList() throws ParseException
    {
        trace_call("parseOptTemplateArgList");
        try
        {
            switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk)
            {
                case 43:
                {
                    parseTemplateArgList();

                    break;
                }
                default:
                    jj_la1[23] = jj_gen;

            }
        }
        finally
        {
            trace_return("parseOptTemplateArgList");
        }
    }

    final public String parseOptID() throws ParseException
    {
        trace_call("parseOptID");
        try
        {
            Token t;
            switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk)
            {
                case IDENTIFIER:
                {
                    t = jj_consume_token(IDENTIFIER);
                    {
                        if ("" != null)
                            return t.image;
                    }
                    break;
                }
                default:
                    jj_la1[24] = jj_gen;
                {
                    if ("" != null)
                        return "anonymous." + (anonCounter++);
                }
            }
            throw new Error("Missing return statement in function");
        }
        finally
        {
            trace_return("parseOptID");
        }
    }

    final public String parseObjectName() throws ParseException
    {
        trace_call("parseObjectName");
        try
        {
            String id;
            id = parseOptID();
            {
                if ("" != null)
                    return id;
            }
            throw new Error("Missing return statement in function");
        }
        finally
        {
            trace_return("parseObjectName");
        }
    }

    final public void parseClassName() throws ParseException
    {
        trace_call("parseClassName");
        try
        {
            String name;
            name = parseObjectName();
            // If a class of this name already exists, it must be a forward ref.
            if ((curRec = records.getClass(name)) != null)
            {
                // If the body was previously defined, this is an error.
                if (!(curRec.getValues().isEmpty() && !curRec.getSuperClasses()
                        .isEmpty() && curRec.getTemplateArgs().isEmpty()))
                {
                    tokError("Class '" + curRec.getName()
                            + "' already defined!\u005cn");
                    System.exit(-1);
                }
            }
            else
            {
                // If this is the first reference to this class, create and add it.
                curRec = new Record(name);
                records.addClass(curRec);
            }
        }
        finally
        {
            trace_return("parseClassName");
        }
    }

    final public void parseDefName() throws ParseException
    {
        trace_call("parseDefName");
        try
        {
            String name;
            name = parseObjectName();
            curRec = new Record(name);

            // Ensure redefinition doesn't happen.
            if (records.getDef(curRec.getName()) != null)
            {
                tokError("Def '" + name + "' already defined!\u005cn");
                System.exit(-1);
            }
            records.addDef(curRec);
        }
        finally
        {
            trace_return("parseDefName");
        }
    }

    final public Record parseObjectBody() throws ParseException
    {
        trace_call("parseObjectBody");
        try
        {
            ArrayList<SubClassReference> subs;
            Record ret;
            subs = parseClassList();
            for (SubClassReference sub : subs)
            {
                addSubClass(sub.rec, sub.templateArgs);
            }

            // Process any variables on the set stack.
            for (ArrayList<LetRecord> list : letStack)
            {
                for (LetRecord letCmd : list)
                {
                    setValue(letCmd.name, letCmd.hasBits ? letCmd.bits : null,
                            letCmd.value);
                }
            }
            parseBody();
            ret = curRec;
            curRec = null;
            {
                if ("" != null)
                    return ret;
            }
            throw new Error("Missing return statement in function");
        }
        finally
        {
            trace_return("parseObjectBody");
        }
    }

    final public Record parseClassInst() throws ParseException
    {
        trace_call("parseClassInst");
        try
        {
            Record ret;
            jj_consume_token(CLASS);
            parseClassName();
            parseTemplateArgs = true;
            parseOptTemplateArgList();
            parseTemplateArgs = false;
            ret = parseObjectBody();
            {
                if ("" != null)
                    return ret;
            }
            throw new Error("Missing return statement in function");
        }
        finally
        {
            trace_return("parseClassInst");
        }
    }

    final public Record parseDefInst() throws ParseException
    {
        trace_call("parseDefInst");
        try
        {
            Record ret;
            jj_consume_token(DEF);
            parseDefName();
            ret = parseObjectBody();

            ret.resolveReferences();
            // If ObjectBody has template arguments, it's an error.
            assert ret.getTemplateArgs()
                    .isEmpty() : "How does this get template args?";
            {
                if ("" != null)
                    return ret;
            }
            throw new Error("Missing return statement in function");
        }
        finally
        {
            trace_return("parseDefInst");
        }
    }

    final public void parseLetItem() throws ParseException
    {
        trace_call("parseLetItem");
        try
        {
            Token t;
            TIntArrayList bits;
            Init val;
            t = jj_consume_token(IDENTIFIER);
            bits = parseOptBitList();
            jj_consume_token(EQ);
            val = parseValue();
            letStack.peek().add(new LetRecord(t.image, bits, val));
        }
        finally
        {
            trace_return("parseLetItem");
        }
    }

    final public void parseLetList() throws ParseException
    {
        trace_call("parseLetList");
        try
        {
            parseLetItem();
            label_8:
            while (true)
            {
                switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk)
                {
                    case COMMA:
                    {
                        ;
                        break;
                    }
                    default:
                        jj_la1[25] = jj_gen;
                        break label_8;
                }
                jj_consume_token(COMMA);
                parseLetItem();
            }
        }
        finally
        {
            trace_return("parseLetList");
        }
    }

    /**
     * // LETCommand - A 'LET' statement start.
     */
    final public void parseLetCommand() throws ParseException
    {
        trace_call("parseLetCommand");
        try
        {
            jj_consume_token(LET);
            letStack.push(new ArrayList<LetRecord>());
            parseLetList();
            jj_consume_token(IN);
        }
        finally
        {
            trace_return("parseLetCommand");
        }
    }

    final public void parseLetRest() throws ParseException
    {
        trace_call("parseLetRest");
        try
        {
            switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk)
            {
                case LBRACE:
                {
                    jj_consume_token(LBRACE);
                    parseObjectList();
                    jj_consume_token(RBRACE);
                    letStack.pop();
                    break;
                }
                case CLASS:
                case DEF:
                case LET:
                {
                    parseObject();
                    letStack.pop();
                    break;
                }
                default:
                    jj_la1[26] = jj_gen;
                    jj_consume_token(-1);
                    throw new ParseException();
            }
        }
        finally
        {
            trace_return("parseLetRest");
        }
    }

    final public void parseLetInst() throws ParseException
    {
        trace_call("parseLetInst");
        try
        {
            parseLetCommand();
            parseLetRest();
        }
        finally
        {
            trace_return("parseLetInst");
        }
    }

    final public void parseObject() throws ParseException
    {
        trace_call("parseObject");
        try
        {
            switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk)
            {
                case CLASS:
                {
                    parseClassInst();
                    break;
                }
                case DEF:
                {
                    parseDefInst();
                    break;
                }
                case LET:
                {
                    parseLetInst();
                    break;
                }
                default:
                    jj_la1[27] = jj_gen;
                    jj_consume_token(-1);
                    throw new ParseException();
            }
        }
        finally
        {
            trace_return("parseObject");
        }
    }

    final public void parseObjectList() throws ParseException
    {
        trace_call("parseObjectList");
        try
        {
            parseObject();

            label_9:
            while (true)
            {
                switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk)
                {
                    case CLASS:
                    case DEF:
                    case LET:
                    {
                        ;
                        break;
                    }
                    default:
                        jj_la1[28] = jj_gen;
                        break label_9;
                }
                parseObject();
            }
            jj_consume_token(0);
        }
        finally
        {
            trace_return("parseObjectList");
        }
    }

    private boolean jj_2_1(int xla)
    {
        jj_la = xla;
        jj_lastpos = jj_scanpos = token;
        try { return !jj_3_1(); }
        catch (LookaheadSuccess ls) { return true; }
        finally { jj_save(0, xla); }
    }

    private boolean jj_2_2(int xla)
    {
        jj_la = xla;
        jj_lastpos = jj_scanpos = token;
        try { return !jj_3_2(); }
        catch (LookaheadSuccess ls) { return true; }
        finally { jj_save(1, xla); }
    }

    private boolean jj_2_3(int xla)
    {
        jj_la = xla;
        jj_lastpos = jj_scanpos = token;
        try { return !jj_3_3(); }
        catch (LookaheadSuccess ls) { return true; }
        finally { jj_save(2, xla); }
    }

    private boolean jj_2_4(int xla)
    {
        jj_la = xla;
        jj_lastpos = jj_scanpos = token;
        try { return !jj_3_4(); }
        catch (LookaheadSuccess ls) { return true; }
        finally { jj_save(3, xla); }
    }

    private boolean jj_3_1()
    {
        if (jj_scan_token(IDENTIFIER))
            return true;
        if (jj_scan_token(43))
            return true;
        return false;
    }

    private boolean jj_3_4()
    {
        if (jj_3R_10())
            return true;
        if (jj_scan_token(43))
            return true;
        return false;
    }

    private boolean jj_3_3()
    {
        if (jj_scan_token(INTVAL))
            return true;
        if (jj_scan_token(INTVAL))
            return true;
        return false;
    }

    private boolean jj_3_2()
    {
        if (jj_scan_token(INTVAL))
            return true;
        if (jj_scan_token(MINUS))
            return true;
        return false;
    }

    private boolean jj_3R_10()
    {
        if (jj_scan_token(IDENTIFIER))
            return true;
        return false;
    }

    /**
     * Generated Token Manager.
     */
    public TGParserTokenManager token_source;
    SimpleCharStream jj_input_stream;
    /**
     * Current token.
     */
    public Token token;
    /**
     * Next token.
     */
    public Token jj_nt;
    private int jj_ntk;
    private Token jj_scanpos, jj_lastpos;
    private int jj_la;
    private int jj_gen;
    final private int[] jj_la1 = new int[29];
    static private int[] jj_la1_0;
    static private int[] jj_la1_1;

    static
    {
        jj_la1_init_0();
        jj_la1_init_1();
    }

    private static void jj_la1_init_0()
    {
        jj_la1_0 = new int[] { 0x2007f0, 0x2000, 0x0, 0xa100000, 0x402f0000,
                0x40000000, 0x40000000, 0x0, 0x0, 0x4a3f0000, 0x100000, 0x0,
                0x0, 0x4a3f0000, 0x0, 0x2067f0, 0x2067f0, 0x2067f0, 0x0,
                0x200000, 0x0, 0x0, 0x0, 0x0, 0x200000, 0x0, 0x5800, 0x5800,
                0x5800, };
    }

    private static void jj_la1_init_1()
    {
        jj_la1_1 = new int[] { 0x0, 0x0, 0x100, 0x201, 0x4, 0x41, 0x41, 0x10,
                0x80, 0x205, 0x0, 0x80, 0x1, 0x205, 0x80, 0x0, 0x0, 0x0, 0x21,
                0x0, 0x80, 0x10, 0x80, 0x800, 0x0, 0x80, 0x1, 0x0, 0x0, };
    }

    final private JJCalls[] jj_2_rtns = new JJCalls[4];
    private boolean jj_rescan = false;
    private int jj_gc = 0;

    /**
     * Constructor with InputStream.
     */
    public TGParser(java.io.InputStream stream)
    {
        this(stream, null);
    }

    /**
     * Constructor with InputStream and supplied encoding
     */
    public TGParser(java.io.InputStream stream, String encoding)
    {
        try
        {
            jj_input_stream = new SimpleCharStream(stream, encoding, 1, 1);
        }
        catch (java.io.UnsupportedEncodingException e)
        {
            throw new RuntimeException(e);
        }
        token_source = new TGParserTokenManager(jj_input_stream);
        token = new Token();
        jj_ntk = -1;
        jj_gen = 0;
        for (int i = 0; i < 29; i++)
            jj_la1[i] = -1;
        for (int i = 0; i < jj_2_rtns.length; i++)
            jj_2_rtns[i] = new JJCalls();
    }

    /**
     * Reinitialise.
     */
    public void ReInit(java.io.InputStream stream)
    {
        ReInit(stream, null);
    }

    /**
     * Reinitialise.
     */
    public void ReInit(java.io.InputStream stream, String encoding)
    {
        try
        {
            jj_input_stream.ReInit(stream, encoding, 1, 1);
        }
        catch (java.io.UnsupportedEncodingException e)
        {
            throw new RuntimeException(e);
        }
        token_source.ReInit(jj_input_stream);
        token = new Token();
        jj_ntk = -1;
        jj_gen = 0;
        for (int i = 0; i < 29; i++)
            jj_la1[i] = -1;
        for (int i = 0; i < jj_2_rtns.length; i++)
            jj_2_rtns[i] = new JJCalls();
    }

    /**
     * Constructor.
     */
    public TGParser(java.io.Reader stream)
    {
        jj_input_stream = new SimpleCharStream(stream, 1, 1);
        token_source = new TGParserTokenManager(jj_input_stream);
        token = new Token();
        jj_ntk = -1;
        jj_gen = 0;
        for (int i = 0; i < 29; i++)
            jj_la1[i] = -1;
        for (int i = 0; i < jj_2_rtns.length; i++)
            jj_2_rtns[i] = new JJCalls();
    }

    /**
     * Reinitialise.
     */
    public void ReInit(java.io.Reader stream)
    {
        jj_input_stream.ReInit(stream, 1, 1);
        token_source.ReInit(jj_input_stream);
        token = new Token();
        jj_ntk = -1;
        jj_gen = 0;
        for (int i = 0; i < 29; i++)
            jj_la1[i] = -1;
        for (int i = 0; i < jj_2_rtns.length; i++)
            jj_2_rtns[i] = new JJCalls();
    }

    /**
     * Constructor with generated Token Manager.
     */
    public TGParser(TGParserTokenManager tm)
    {
        token_source = tm;
        token = new Token();
        jj_ntk = -1;
        jj_gen = 0;
        for (int i = 0; i < 29; i++)
            jj_la1[i] = -1;
        for (int i = 0; i < jj_2_rtns.length; i++)
            jj_2_rtns[i] = new JJCalls();
    }

    /**
     * Reinitialise.
     */
    public void ReInit(TGParserTokenManager tm)
    {
        token_source = tm;
        token = new Token();
        jj_ntk = -1;
        jj_gen = 0;
        for (int i = 0; i < 29; i++)
            jj_la1[i] = -1;
        for (int i = 0; i < jj_2_rtns.length; i++)
            jj_2_rtns[i] = new JJCalls();
    }

    private Token jj_consume_token(int kind) throws ParseException
    {
        Token oldToken;
        if ((oldToken = token).next != null)
            token = token.next;
        else
            token = token.next = token_source.getNextToken();
        jj_ntk = -1;

        // for debug.
        //System.err.println(token.image);

        if (token.kind == kind)
        {
            jj_gen++;
            if (++jj_gc > 100)
            {
                jj_gc = 0;
                for (int i = 0; i < jj_2_rtns.length; i++)
                {
                    JJCalls c = jj_2_rtns[i];
                    while (c != null)
                    {
                        if (c.gen < jj_gen)
                            c.first = null;
                        c = c.next;
                    }
                }
            }
            trace_token(token, "");
            return token;
        }
        token = oldToken;
        jj_kind = kind;
        throw generateParseException();
    }

    @SuppressWarnings("serial") static private final class LookaheadSuccess
            extends java.lang.Error
    {
    }

    final private LookaheadSuccess jj_ls = new LookaheadSuccess();

    private boolean jj_scan_token(int kind)
    {
        if (jj_scanpos == jj_lastpos)
        {
            jj_la--;
            if (jj_scanpos.next == null)
            {
                jj_lastpos = jj_scanpos = jj_scanpos.next = token_source
                        .getNextToken();
            }
            else
            {
                jj_lastpos = jj_scanpos = jj_scanpos.next;
            }
        }
        else
        {
            jj_scanpos = jj_scanpos.next;
        }
        if (jj_rescan)
        {
            int i = 0;
            Token tok = token;
            while (tok != null && tok != jj_scanpos)
            {
                i++;
                tok = tok.next;
            }
            if (tok != null)
                jj_add_error_token(kind, i);
        }
        if (jj_scanpos.kind != kind)
            return true;
        if (jj_la == 0 && jj_scanpos == jj_lastpos)
            throw jj_ls;
        return false;
    }

    /**
     * Get the next Token.
     */
    final public Token getNextToken()
    {
        if (token.next != null)
            token = token.next;
        else
            token = token.next = token_source.getNextToken();
        jj_ntk = -1;
        jj_gen++;
        trace_token(token, " (in getNextToken)");
        return token;
    }

    /**
     * Get the specific Token.
     */
    final public Token getToken(int index)
    {
        Token t = token;
        for (int i = 0; i < index; i++)
        {
            if (t.next != null)
                t = t.next;
            else
                t = t.next = token_source.getNextToken();
        }
        return t;
    }

    private int jj_ntk_f()
    {
        if ((jj_nt = token.next) == null)
            return (jj_ntk = (token.next = token_source.getNextToken()).kind);
        else
            return (jj_ntk = jj_nt.kind);
    }

    private java.util.List<int[]> jj_expentries = new java.util.ArrayList<int[]>();
    private int[] jj_expentry;
    private int jj_kind = -1;
    private int[] jj_lasttokens = new int[100];
    private int jj_endpos;

    private void jj_add_error_token(int kind, int pos)
    {
        if (pos >= 100)
            return;
        if (pos == jj_endpos + 1)
        {
            jj_lasttokens[jj_endpos++] = kind;
        }
        else if (jj_endpos != 0)
        {
            jj_expentry = new int[jj_endpos];
            for (int i = 0; i < jj_endpos; i++)
            {
                jj_expentry[i] = jj_lasttokens[i];
            }
            jj_entries_loop:
            for (java.util.Iterator<?> it = jj_expentries.iterator(); it
                    .hasNext(); )
            {
                int[] oldentry = (int[]) (it.next());
                if (oldentry.length == jj_expentry.length)
                {
                    for (int i = 0; i < jj_expentry.length; i++)
                    {
                        if (oldentry[i] != jj_expentry[i])
                        {
                            continue jj_entries_loop;
                        }
                    }
                    jj_expentries.add(jj_expentry);
                    break jj_entries_loop;
                }
            }
            if (pos != 0)
                jj_lasttokens[(jj_endpos = pos) - 1] = kind;
        }
    }

    /**
     * Generate ParseException.
     */
    public ParseException generateParseException()
    {
        jj_expentries.clear();
        boolean[] la1tokens = new boolean[45];
        if (jj_kind >= 0)
        {
            la1tokens[jj_kind] = true;
            jj_kind = -1;
        }
        for (int i = 0; i < 29; i++)
        {
            if (jj_la1[i] == jj_gen)
            {
                for (int j = 0; j < 32; j++)
                {
                    if ((jj_la1_0[i] & (1 << j)) != 0)
                    {
                        la1tokens[j] = true;
                    }
                    if ((jj_la1_1[i] & (1 << j)) != 0)
                    {
                        la1tokens[32 + j] = true;
                    }
                }
            }
        }
        for (int i = 0; i < 45; i++)
        {
            if (la1tokens[i])
            {
                jj_expentry = new int[1];
                jj_expentry[0] = i;
                jj_expentries.add(jj_expentry);
            }
        }
        jj_endpos = 0;
        jj_rescan_token();
        jj_add_error_token(0, 0);
        int[][] exptokseq = new int[jj_expentries.size()][];
        for (int i = 0; i < jj_expentries.size(); i++)
        {
            exptokseq[i] = jj_expentries.get(i);
        }
        return new ParseException(token, exptokseq, tokenImage);
    }

    private int trace_indent = 0;
    private boolean trace_enabled = true;

    /**
     * Enable tracing.
     */
    final public void enable_tracing()
    {
        trace_enabled = true;
    }

    /**
     * Disable tracing.
     */
    final public void disable_tracing()
    {
        trace_enabled = false;
    }

    private void trace_call(String s)
    {
        if (trace_enabled)
        {
            for (int i = 0; i < trace_indent; i++) { System.out.print(" "); }
            System.out.println("Call:   " + s);
        }
        trace_indent = trace_indent + 2;
    }

    private void trace_return(String s)
    {
        trace_indent = trace_indent - 2;
        if (trace_enabled)
        {
            for (int i = 0; i < trace_indent; i++) { System.out.print(" "); }
            System.out.println("Return: " + s);
        }
    }

    private void trace_token(Token t, String where)
    {
        if (trace_enabled)
        {
            for (int i = 0; i < trace_indent; i++) { System.out.print(" "); }
            System.out.print("Consumed token: <" + tokenImage[t.kind]);
            if (t.kind != 0 && !tokenImage[t.kind]
                    .equals("\"" + t.image + "\""))
            {
                System.out.print(": \"" + t.image + "\"");
            }
            System.out.println(
                    " at line " + t.beginLine + " column " + t.beginColumn + ">"
                            + where);
        }
    }

    private void trace_scan(Token t1, int t2)
    {
        if (trace_enabled)
        {
            for (int i = 0; i < trace_indent; i++) { System.out.print(" "); }
            System.out.print("Visited token: <" + tokenImage[t1.kind]);
            if (t1.kind != 0 && !tokenImage[t1.kind]
                    .equals("\"" + t1.image + "\""))
            {
                System.out.print(": \"" + t1.image + "\"");
            }
            System.out.println(
                    " at line " + t1.beginLine + " column " + t1.beginColumn
                            + ">; Expected token: <" + tokenImage[t2] + ">");
        }
    }

    private void jj_rescan_token()
    {
        jj_rescan = true;
        for (int i = 0; i < 4; i++)
        {
            try
            {
                JJCalls p = jj_2_rtns[i];
                do
                {
                    if (p.gen > jj_gen)
                    {
                        jj_la = p.arg;
                        jj_lastpos = jj_scanpos = p.first;
                        switch (i)
                        {
                            case 0:
                                jj_3_1();
                                break;
                            case 1:
                                jj_3_2();
                                break;
                            case 2:
                                jj_3_3();
                                break;
                            case 3:
                                jj_3_4();
                                break;
                        }
                    }
                    p = p.next;
                } while (p != null);
            }
            catch (LookaheadSuccess ls) { }
        }
        jj_rescan = false;
    }

    private void jj_save(int index, int xla)
    {
        JJCalls p = jj_2_rtns[index];
        while (p.gen > jj_gen)
        {
            if (p.next == null)
            {
                p = p.next = new JJCalls();
                break;
            }
            p = p.next;
        }
        p.gen = jj_gen + xla - jj_la;
        p.first = token;
        p.arg = xla;
    }

    static final class JJCalls
    {
        int gen;
        Token first;
        int arg;
        JJCalls next;
    }

}

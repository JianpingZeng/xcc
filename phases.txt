*** IR Dump After Module Verifier ***
; Function Attrs: noinline nounwind
define i32 @foo(i32 %x, i32 %y) #0 {
  %x.addr = alloca i32, align 4
  %y.addr = alloca i32, align 4
  %res = alloca i32, align 4
  store i32 %x, i32* %x.addr, align 4
  store i32 %y, i32* %y.addr, align 4
  %1 = load i32, i32* %x.addr, align 4
  %2 = load i32, i32* %y.addr, align 4
  %add = add nsw i32 %1, %2
  store i32 %add, i32* %res, align 4
  %3 = load i32, i32* %res, align 4
  ret i32 %3
}
*** IR Dump After Add DWARF path discriminators ***
; Function Attrs: noinline nounwind
define i32 @foo(i32 %x, i32 %y) #0 {
  %x.addr = alloca i32, align 4
  %y.addr = alloca i32, align 4
  %res = alloca i32, align 4
  store i32 %x, i32* %x.addr, align 4
  store i32 %y, i32* %y.addr, align 4
  %1 = load i32, i32* %x.addr, align 4
  %2 = load i32, i32* %y.addr, align 4
  %add = add nsw i32 %1, %2
  store i32 %add, i32* %res, align 4
  %3 = load i32, i32* %res, align 4
  ret i32 %3
}
*** IR Dump After Force set function attributes ***; ModuleID = '../compiler/xcc/java/test/jlang/CodeGen/asm.c'
source_filename = "../compiler/xcc/java/test/jlang/CodeGen/asm.c"
target datalayout = "e-m:o-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-apple-darwin16.7.0"

; Function Attrs: noinline nounwind
define i32 @foo(i32 %x, i32 %y) #0 {
  %x.addr = alloca i32, align 4
  %y.addr = alloca i32, align 4
  %res = alloca i32, align 4
  store i32 %x, i32* %x.addr, align 4
  store i32 %y, i32* %y.addr, align 4
  %1 = load i32, i32* %x.addr, align 4
  %2 = load i32, i32* %y.addr, align 4
  %add = add nsw i32 %1, %2
  store i32 %add, i32* %res, align 4
  %3 = load i32, i32* %res, align 4
  ret i32 %3
}

attributes #0 = { noinline nounwind "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-features"="+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }

!llvm.ident = !{!0}

!0 = !{!"Apple LLVM version 9.0.0 (clang-900.0.37)"}
*** IR Dump After Inliner for always_inline functions ***
; Function Attrs: noinline nounwind
define i32 @foo(i32 %x, i32 %y) #0 {
  %x.addr = alloca i32, align 4
  %y.addr = alloca i32, align 4
  %res = alloca i32, align 4
  store i32 %x, i32* %x.addr, align 4
  store i32 %y, i32* %y.addr, align 4
  %1 = load i32, i32* %x.addr, align 4
  %2 = load i32, i32* %y.addr, align 4
  %add = add nsw i32 %1, %2
  store i32 %add, i32* %res, align 4
  %3 = load i32, i32* %res, align 4
  ret i32 %3
}
*** IR Dump After Inliner for always_inline functions ***
Printing <null> Function
*** IR Dump After A No-Op Barrier Pass ***; ModuleID = '../compiler/xcc/java/test/jlang/CodeGen/asm.c'
source_filename = "../compiler/xcc/java/test/jlang/CodeGen/asm.c"
target datalayout = "e-m:o-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-apple-darwin16.7.0"

; Function Attrs: noinline nounwind
define i32 @foo(i32 %x, i32 %y) #0 {
  %x.addr = alloca i32, align 4
  %y.addr = alloca i32, align 4
  %res = alloca i32, align 4
  store i32 %x, i32* %x.addr, align 4
  store i32 %y, i32* %y.addr, align 4
  %1 = load i32, i32* %x.addr, align 4
  %2 = load i32, i32* %y.addr, align 4
  %add = add nsw i32 %1, %2
  store i32 %add, i32* %res, align 4
  %3 = load i32, i32* %res, align 4
  ret i32 %3
}

attributes #0 = { noinline nounwind "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-features"="+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }

!llvm.ident = !{!0}

!0 = !{!"Apple LLVM version 9.0.0 (clang-900.0.37)"}
*** IR Dump After Expand Atomic instructions ***
; Function Attrs: noinline nounwind
define i32 @foo(i32 %x, i32 %y) #0 {
  %x.addr = alloca i32, align 4
  %y.addr = alloca i32, align 4
  %res = alloca i32, align 4
  store i32 %x, i32* %x.addr, align 4
  store i32 %y, i32* %y.addr, align 4
  %1 = load i32, i32* %x.addr, align 4
  %2 = load i32, i32* %y.addr, align 4
  %add = add nsw i32 %1, %2
  store i32 %add, i32* %res, align 4
  %3 = load i32, i32* %res, align 4
  ret i32 %3
}
*** IR Dump After Module Verifier ***
; Function Attrs: noinline nounwind
define i32 @foo(i32 %x, i32 %y) #0 {
  %x.addr = alloca i32, align 4
  %y.addr = alloca i32, align 4
  %res = alloca i32, align 4
  store i32 %x, i32* %x.addr, align 4
  store i32 %y, i32* %y.addr, align 4
  %1 = load i32, i32* %x.addr, align 4
  %2 = load i32, i32* %y.addr, align 4
  %add = add nsw i32 %1, %2
  store i32 %add, i32* %res, align 4
  %3 = load i32, i32* %res, align 4
  ret i32 %3
}
*** IR Dump After Lower Garbage Collection Instructions ***
; Function Attrs: noinline nounwind
define i32 @foo(i32 %x, i32 %y) #0 {
  %x.addr = alloca i32, align 4
  %y.addr = alloca i32, align 4
  %res = alloca i32, align 4
  store i32 %x, i32* %x.addr, align 4
  store i32 %y, i32* %y.addr, align 4
  %1 = load i32, i32* %x.addr, align 4
  %2 = load i32, i32* %y.addr, align 4
  %add = add nsw i32 %1, %2
  store i32 %add, i32* %res, align 4
  %3 = load i32, i32* %res, align 4
  ret i32 %3
}
*** IR Dump After Shadow Stack GC Lowering ***
; Function Attrs: noinline nounwind
define i32 @foo(i32 %x, i32 %y) #0 {
  %x.addr = alloca i32, align 4
  %y.addr = alloca i32, align 4
  %res = alloca i32, align 4
  store i32 %x, i32* %x.addr, align 4
  store i32 %y, i32* %y.addr, align 4
  %1 = load i32, i32* %x.addr, align 4
  %2 = load i32, i32* %y.addr, align 4
  %add = add nsw i32 %1, %2
  store i32 %add, i32* %res, align 4
  %3 = load i32, i32* %res, align 4
  ret i32 %3
}
*** IR Dump After Remove unreachable blocks from the CFG ***
; Function Attrs: noinline nounwind
define i32 @foo(i32 %x, i32 %y) #0 {
  %x.addr = alloca i32, align 4
  %y.addr = alloca i32, align 4
  %res = alloca i32, align 4
  store i32 %x, i32* %x.addr, align 4
  store i32 %y, i32* %y.addr, align 4
  %1 = load i32, i32* %x.addr, align 4
  %2 = load i32, i32* %y.addr, align 4
  %add = add nsw i32 %1, %2
  store i32 %add, i32* %res, align 4
  %3 = load i32, i32* %res, align 4
  ret i32 %3
}
*** IR Dump After Inserts calls to mcount-like functions ***
; Function Attrs: noinline nounwind
define i32 @foo(i32 %x, i32 %y) #0 {
  %x.addr = alloca i32, align 4
  %y.addr = alloca i32, align 4
  %res = alloca i32, align 4
  store i32 %x, i32* %x.addr, align 4
  store i32 %y, i32* %y.addr, align 4
  %1 = load i32, i32* %x.addr, align 4
  %2 = load i32, i32* %y.addr, align 4
  %add = add nsw i32 %1, %2
  store i32 %add, i32* %res, align 4
  %3 = load i32, i32* %res, align 4
  ret i32 %3
}
*** IR Dump After Rewrite Symbols ***; ModuleID = '../compiler/xcc/java/test/jlang/CodeGen/asm.c'
source_filename = "../compiler/xcc/java/test/jlang/CodeGen/asm.c"
target datalayout = "e-m:o-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-apple-darwin16.7.0"

; Function Attrs: noinline nounwind
define i32 @foo(i32 %x, i32 %y) #0 {
  %x.addr = alloca i32, align 4
  %y.addr = alloca i32, align 4
  %res = alloca i32, align 4
  store i32 %x, i32* %x.addr, align 4
  store i32 %y, i32* %y.addr, align 4
  %1 = load i32, i32* %x.addr, align 4
  %2 = load i32, i32* %y.addr, align 4
  %add = add nsw i32 %1, %2
  store i32 %add, i32* %res, align 4
  %3 = load i32, i32* %res, align 4
  ret i32 %3
}

attributes #0 = { noinline nounwind "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="false" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-features"="+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }

!llvm.ident = !{!0}

!0 = !{!"Apple LLVM version 9.0.0 (clang-900.0.37)"}
*** IR Dump After Exception handling preparation ***
; Function Attrs: noinline nounwind
define i32 @foo(i32 %x, i32 %y) #0 {
  %x.addr = alloca i32, align 4
  %y.addr = alloca i32, align 4
  %res = alloca i32, align 4
  store i32 %x, i32* %x.addr, align 4
  store i32 %y, i32* %y.addr, align 4
  %1 = load i32, i32* %x.addr, align 4
  %2 = load i32, i32* %y.addr, align 4
  %add = add nsw i32 %1, %2
  store i32 %add, i32* %res, align 4
  %3 = load i32, i32* %res, align 4
  ret i32 %3
}
*** IR Dump After Safe Stack instrumentation pass ***
; Function Attrs: noinline nounwind
define i32 @foo(i32 %x, i32 %y) #0 {
  %x.addr = alloca i32, align 4
  %y.addr = alloca i32, align 4
  %res = alloca i32, align 4
  store i32 %x, i32* %x.addr, align 4
  store i32 %y, i32* %y.addr, align 4
  %1 = load i32, i32* %x.addr, align 4
  %2 = load i32, i32* %y.addr, align 4
  %add = add nsw i32 %1, %2
  store i32 %add, i32* %res, align 4
  %3 = load i32, i32* %res, align 4
  ret i32 %3
}
*** IR Dump After Module Verifier ***
; Function Attrs: noinline nounwind
define i32 @foo(i32 %x, i32 %y) #0 {
  %x.addr = alloca i32, align 4
  %y.addr = alloca i32, align 4
  %res = alloca i32, align 4
  store i32 %x, i32* %x.addr, align 4
  store i32 %y, i32* %y.addr, align 4
  %1 = load i32, i32* %x.addr, align 4
  %2 = load i32, i32* %y.addr, align 4
  %add = add nsw i32 %1, %2
  store i32 %add, i32* %res, align 4
  %3 = load i32, i32* %res, align 4
  ret i32 %3
}
# *** IR Dump After Expand ISel Pseudo-instructions ***:
# Machine code for function foo: IsSSA, TracksLiveness
Frame Objects:
  fi#0: size=4, align=4, at location [SP+8]
  fi#1: size=4, align=4, at location [SP+8]
  fi#2: size=4, align=4, at location [SP+8]
Function Live Ins: %EDI in %vreg0, %ESI in %vreg2

BB#0: derived from LLVM BB %0
    Live Ins: %EDI %ESI
	%vreg2<def> = COPY %ESI; GR32:%vreg2
	%vreg0<def> = COPY %EDI; GR32:%vreg0
	%vreg1<def> = COPY %vreg0<kill>; GR32:%vreg1,%vreg0
	%vreg3<def> = COPY %vreg2<kill>; GR32:%vreg3,%vreg2
	MOV32mr <fi#0>, 1, %noreg, 0, %noreg, %vreg1; mem:ST4[%x.addr] GR32:%vreg1
	MOV32mr <fi#1>, 1, %noreg, 0, %noreg, %vreg3; mem:ST4[%y.addr] GR32:%vreg3
	%vreg10<def> = MOV32rm <fi#0>, 1, %noreg, 0, %noreg; mem:LD4[%x.addr] GR32:%vreg10
	%vreg9<def,tied1> = ADD32rm %vreg10<kill,tied0>, <fi#1>, 1, %noreg, 0, %noreg, %EFLAGS<imp-def>; mem:LD4[%y.addr] GR32:%vreg9,%vreg10
	MOV32mr <fi#2>, 1, %noreg, 0, %noreg, %vreg9<kill>; mem:ST4[%res] GR32:%vreg9
	%vreg5<def> = MOV32rm <fi#2>, 1, %noreg, 0, %noreg; mem:LD4[%res] GR32:%vreg5
	%EAX<def> = COPY %vreg5; GR32:%vreg5
	RETQ %EAX<imp-use>

# End machine code for function foo.

# *** IR Dump After Local Stack Slot Allocation ***:
# Machine code for function foo: IsSSA, TracksLiveness
Frame Objects:
  fi#0: size=4, align=4, at location [SP+8]
  fi#1: size=4, align=4, at location [SP+8]
  fi#2: size=4, align=4, at location [SP+8]
Function Live Ins: %EDI in %vreg0, %ESI in %vreg2

BB#0: derived from LLVM BB %0
    Live Ins: %EDI %ESI
	%vreg2<def> = COPY %ESI; GR32:%vreg2
	%vreg0<def> = COPY %EDI; GR32:%vreg0
	%vreg1<def> = COPY %vreg0<kill>; GR32:%vreg1,%vreg0
	%vreg3<def> = COPY %vreg2<kill>; GR32:%vreg3,%vreg2
	MOV32mr <fi#0>, 1, %noreg, 0, %noreg, %vreg1; mem:ST4[%x.addr] GR32:%vreg1
	MOV32mr <fi#1>, 1, %noreg, 0, %noreg, %vreg3; mem:ST4[%y.addr] GR32:%vreg3
	%vreg10<def> = MOV32rm <fi#0>, 1, %noreg, 0, %noreg; mem:LD4[%x.addr] GR32:%vreg10
	%vreg9<def,tied1> = ADD32rm %vreg10<kill,tied0>, <fi#1>, 1, %noreg, 0, %noreg, %EFLAGS<imp-def>; mem:LD4[%y.addr] GR32:%vreg9,%vreg10
	MOV32mr <fi#2>, 1, %noreg, 0, %noreg, %vreg9<kill>; mem:ST4[%res] GR32:%vreg9
	%vreg5<def> = MOV32rm <fi#2>, 1, %noreg, 0, %noreg; mem:LD4[%res] GR32:%vreg5
	%EAX<def> = COPY %vreg5; GR32:%vreg5
	RETQ %EAX<imp-use>

# End machine code for function foo.

# *** IR Dump After Eliminate PHI nodes for register allocation ***:
# Machine code for function foo: NoPHIs, TracksLiveness
Frame Objects:
  fi#0: size=4, align=4, at location [SP+8]
  fi#1: size=4, align=4, at location [SP+8]
  fi#2: size=4, align=4, at location [SP+8]
Function Live Ins: %EDI in %vreg0, %ESI in %vreg2

BB#0: derived from LLVM BB %0
    Live Ins: %EDI %ESI
	%vreg2<def> = COPY %ESI; GR32:%vreg2
	%vreg0<def> = COPY %EDI; GR32:%vreg0
	%vreg1<def> = COPY %vreg0<kill>; GR32:%vreg1,%vreg0
	%vreg3<def> = COPY %vreg2<kill>; GR32:%vreg3,%vreg2
	MOV32mr <fi#0>, 1, %noreg, 0, %noreg, %vreg1; mem:ST4[%x.addr] GR32:%vreg1
	MOV32mr <fi#1>, 1, %noreg, 0, %noreg, %vreg3; mem:ST4[%y.addr] GR32:%vreg3
	%vreg10<def> = MOV32rm <fi#0>, 1, %noreg, 0, %noreg; mem:LD4[%x.addr] GR32:%vreg10
	%vreg9<def,tied1> = ADD32rm %vreg10<kill,tied0>, <fi#1>, 1, %noreg, 0, %noreg, %EFLAGS<imp-def>; mem:LD4[%y.addr] GR32:%vreg9,%vreg10
	MOV32mr <fi#2>, 1, %noreg, 0, %noreg, %vreg9<kill>; mem:ST4[%res] GR32:%vreg9
	%vreg5<def> = MOV32rm <fi#2>, 1, %noreg, 0, %noreg; mem:LD4[%res] GR32:%vreg5
	%EAX<def> = COPY %vreg5; GR32:%vreg5
	RETQ %EAX<imp-use>

# End machine code for function foo.

# *** IR Dump After Two-Address instruction pass ***:
# Machine code for function foo: NoPHIs, TracksLiveness
Frame Objects:
  fi#0: size=4, align=4, at location [SP+8]
  fi#1: size=4, align=4, at location [SP+8]
  fi#2: size=4, align=4, at location [SP+8]
Function Live Ins: %EDI in %vreg0, %ESI in %vreg2

BB#0: derived from LLVM BB %0
    Live Ins: %EDI %ESI
	%vreg2<def> = COPY %ESI; GR32:%vreg2
	%vreg0<def> = COPY %EDI; GR32:%vreg0
	%vreg1<def> = COPY %vreg0<kill>; GR32:%vreg1,%vreg0
	%vreg3<def> = COPY %vreg2<kill>; GR32:%vreg3,%vreg2
	MOV32mr <fi#0>, 1, %noreg, 0, %noreg, %vreg1; mem:ST4[%x.addr] GR32:%vreg1
	MOV32mr <fi#1>, 1, %noreg, 0, %noreg, %vreg3; mem:ST4[%y.addr] GR32:%vreg3
	%vreg10<def> = MOV32rm <fi#0>, 1, %noreg, 0, %noreg; mem:LD4[%x.addr] GR32:%vreg10
	%vreg9<def> = COPY %vreg10; GR32:%vreg9,%vreg10
	%vreg9<def,tied1> = ADD32rm %vreg9<tied0>, <fi#1>, 1, %noreg, 0, %noreg, %EFLAGS<imp-def>; mem:LD4[%y.addr] GR32:%vreg9
	MOV32mr <fi#2>, 1, %noreg, 0, %noreg, %vreg9<kill>; mem:ST4[%res] GR32:%vreg9
	%vreg5<def> = MOV32rm <fi#2>, 1, %noreg, 0, %noreg; mem:LD4[%res] GR32:%vreg5
	%EAX<def> = COPY %vreg5; GR32:%vreg5
	RETQ %EAX<imp-use>

# End machine code for function foo.

# *** IR Dump After Prologue/Epilogue Insertion & Frame Finalization ***:
# Machine code for function foo: NoPHIs, TracksLiveness, NoVRegs
Frame Objects:
  fi#0: size=4, align=4, at location [SP-4]
  fi#1: size=4, align=4, at location [SP-8]
  fi#2: size=4, align=4, at location [SP-12]
Function Live Ins: %EDI, %ESI

BB#0: derived from LLVM BB %0
    Live Ins: %EDI %ESI
	MOV32mr %RSP, 1, %noreg, -4, %noreg, %EDI<kill>; mem:ST4[%x.addr]
	MOV32mr %RSP, 1, %noreg, -8, %noreg, %ESI<kill>; mem:ST4[%y.addr]
	%ESI<def> = MOV32rm %RSP, 1, %noreg, -4, %noreg; mem:LD4[%x.addr]
	%ESI<def,tied1> = ADD32rm %ESI<tied0>, %RSP, 1, %noreg, -8, %noreg, %EFLAGS<imp-def>; mem:LD4[%y.addr]
	MOV32mr %RSP, 1, %noreg, -12, %noreg, %ESI<kill>; mem:ST4[%res]
	%EAX<def> = MOV32rm %RSP, 1, %noreg, -12, %noreg; mem:LD4[%res]
	RETQ %EAX<imp-use,kill>

# End machine code for function foo.

# *** IR Dump After Post-RA pseudo instruction expansion pass ***:
# Machine code for function foo: NoPHIs, TracksLiveness, NoVRegs
Frame Objects:
  fi#0: size=4, align=4, at location [SP-4]
  fi#1: size=4, align=4, at location [SP-8]
  fi#2: size=4, align=4, at location [SP-12]
Function Live Ins: %EDI, %ESI

BB#0: derived from LLVM BB %0
    Live Ins: %EDI %ESI
	MOV32mr %RSP, 1, %noreg, -4, %noreg, %EDI<kill>; mem:ST4[%x.addr]
	MOV32mr %RSP, 1, %noreg, -8, %noreg, %ESI<kill>; mem:ST4[%y.addr]
	%ESI<def> = MOV32rm %RSP, 1, %noreg, -4, %noreg; mem:LD4[%x.addr]
	%ESI<def,tied1> = ADD32rm %ESI<tied0>, %RSP, 1, %noreg, -8, %noreg, %EFLAGS<imp-def>; mem:LD4[%y.addr]
	MOV32mr %RSP, 1, %noreg, -12, %noreg, %ESI<kill>; mem:ST4[%res]
	%EAX<def> = MOV32rm %RSP, 1, %noreg, -12, %noreg; mem:LD4[%res]
	RETQ %EAX<imp-use,kill>

# End machine code for function foo.

# *** IR Dump After Analyze Machine Code For Garbage Collection ***:
# Machine code for function foo: NoPHIs, TracksLiveness, NoVRegs
Frame Objects:
  fi#0: size=4, align=4, at location [SP-4]
  fi#1: size=4, align=4, at location [SP-8]
  fi#2: size=4, align=4, at location [SP-12]
Function Live Ins: %EDI, %ESI

BB#0: derived from LLVM BB %0
    Live Ins: %EDI %ESI
	MOV32mr %RSP, 1, %noreg, -4, %noreg, %EDI<kill>; mem:ST4[%x.addr]
	MOV32mr %RSP, 1, %noreg, -8, %noreg, %ESI<kill>; mem:ST4[%y.addr]
	%ESI<def> = MOV32rm %RSP, 1, %noreg, -4, %noreg; mem:LD4[%x.addr]
	%ESI<def,tied1> = ADD32rm %ESI<tied0>, %RSP, 1, %noreg, -8, %noreg, %EFLAGS<imp-def>; mem:LD4[%y.addr]
	MOV32mr %RSP, 1, %noreg, -12, %noreg, %ESI<kill>; mem:ST4[%res]
	%EAX<def> = MOV32rm %RSP, 1, %noreg, -12, %noreg; mem:LD4[%res]
	RETQ %EAX<imp-use,kill>

# End machine code for function foo.

# *** IR Dump After Contiguously Lay Out Funclets ***:
# Machine code for function foo: NoPHIs, TracksLiveness, NoVRegs
Frame Objects:
  fi#0: size=4, align=4, at location [SP-4]
  fi#1: size=4, align=4, at location [SP-8]
  fi#2: size=4, align=4, at location [SP-12]
Function Live Ins: %EDI, %ESI

BB#0: derived from LLVM BB %0
    Live Ins: %EDI %ESI
	MOV32mr %RSP, 1, %noreg, -4, %noreg, %EDI<kill>; mem:ST4[%x.addr]
	MOV32mr %RSP, 1, %noreg, -8, %noreg, %ESI<kill>; mem:ST4[%y.addr]
	%ESI<def> = MOV32rm %RSP, 1, %noreg, -4, %noreg; mem:LD4[%x.addr]
	%ESI<def,tied1> = ADD32rm %ESI<tied0>, %RSP, 1, %noreg, -8, %noreg, %EFLAGS<imp-def>; mem:LD4[%y.addr]
	MOV32mr %RSP, 1, %noreg, -12, %noreg, %ESI<kill>; mem:ST4[%res]
	%EAX<def> = MOV32rm %RSP, 1, %noreg, -12, %noreg; mem:LD4[%res]
	RETQ %EAX<imp-use,kill>

# End machine code for function foo.

# *** IR Dump After StackMap Liveness Analysis ***:
# Machine code for function foo: NoPHIs, TracksLiveness, NoVRegs
Frame Objects:
  fi#0: size=4, align=4, at location [SP-4]
  fi#1: size=4, align=4, at location [SP-8]
  fi#2: size=4, align=4, at location [SP-12]
Function Live Ins: %EDI, %ESI

BB#0: derived from LLVM BB %0
    Live Ins: %EDI %ESI
	MOV32mr %RSP, 1, %noreg, -4, %noreg, %EDI<kill>; mem:ST4[%x.addr]
	MOV32mr %RSP, 1, %noreg, -8, %noreg, %ESI<kill>; mem:ST4[%y.addr]
	%ESI<def> = MOV32rm %RSP, 1, %noreg, -4, %noreg; mem:LD4[%x.addr]
	%ESI<def,tied1> = ADD32rm %ESI<tied0>, %RSP, 1, %noreg, -8, %noreg, %EFLAGS<imp-def>; mem:LD4[%y.addr]
	MOV32mr %RSP, 1, %noreg, -12, %noreg, %ESI<kill>; mem:ST4[%res]
	%EAX<def> = MOV32rm %RSP, 1, %noreg, -12, %noreg; mem:LD4[%res]
	RETQ %EAX<imp-use,kill>

# End machine code for function foo.

# *** IR Dump After Live DEBUG_VALUE analysis ***:
# Machine code for function foo: NoPHIs, TracksLiveness, NoVRegs
Frame Objects:
  fi#0: size=4, align=4, at location [SP-4]
  fi#1: size=4, align=4, at location [SP-8]
  fi#2: size=4, align=4, at location [SP-12]
Function Live Ins: %EDI, %ESI

BB#0: derived from LLVM BB %0
    Live Ins: %EDI %ESI
	MOV32mr %RSP, 1, %noreg, -4, %noreg, %EDI<kill>; mem:ST4[%x.addr]
	MOV32mr %RSP, 1, %noreg, -8, %noreg, %ESI<kill>; mem:ST4[%y.addr]
	%ESI<def> = MOV32rm %RSP, 1, %noreg, -4, %noreg; mem:LD4[%x.addr]
	%ESI<def,tied1> = ADD32rm %ESI<tied0>, %RSP, 1, %noreg, -8, %noreg, %EFLAGS<imp-def>; mem:LD4[%y.addr]
	MOV32mr %RSP, 1, %noreg, -12, %noreg, %ESI<kill>; mem:ST4[%res]
	%EAX<def> = MOV32rm %RSP, 1, %noreg, -12, %noreg; mem:LD4[%res]
	RETQ %EAX<imp-use,kill>

# End machine code for function foo.

# *** IR Dump After Insert XRay ops ***:
# Machine code for function foo: NoPHIs, TracksLiveness, NoVRegs
Frame Objects:
  fi#0: size=4, align=4, at location [SP-4]
  fi#1: size=4, align=4, at location [SP-8]
  fi#2: size=4, align=4, at location [SP-12]
Function Live Ins: %EDI, %ESI

BB#0: derived from LLVM BB %0
    Live Ins: %EDI %ESI
	MOV32mr %RSP, 1, %noreg, -4, %noreg, %EDI<kill>; mem:ST4[%x.addr]
	MOV32mr %RSP, 1, %noreg, -8, %noreg, %ESI<kill>; mem:ST4[%y.addr]
	%ESI<def> = MOV32rm %RSP, 1, %noreg, -4, %noreg; mem:LD4[%x.addr]
	%ESI<def,tied1> = ADD32rm %ESI<tied0>, %RSP, 1, %noreg, -8, %noreg, %EFLAGS<imp-def>; mem:LD4[%y.addr]
	MOV32mr %RSP, 1, %noreg, -12, %noreg, %ESI<kill>; mem:ST4[%res]
	%EAX<def> = MOV32rm %RSP, 1, %noreg, -12, %noreg; mem:LD4[%res]
	RETQ %EAX<imp-use,kill>

# End machine code for function foo.

# *** IR Dump After Implement the 'patchable-function' attribute ***:
# Machine code for function foo: NoPHIs, TracksLiveness, NoVRegs
Frame Objects:
  fi#0: size=4, align=4, at location [SP-4]
  fi#1: size=4, align=4, at location [SP-8]
  fi#2: size=4, align=4, at location [SP-12]
Function Live Ins: %EDI, %ESI

BB#0: derived from LLVM BB %0
    Live Ins: %EDI %ESI
	MOV32mr %RSP, 1, %noreg, -4, %noreg, %EDI<kill>; mem:ST4[%x.addr]
	MOV32mr %RSP, 1, %noreg, -8, %noreg, %ESI<kill>; mem:ST4[%y.addr]
	%ESI<def> = MOV32rm %RSP, 1, %noreg, -4, %noreg; mem:LD4[%x.addr]
	%ESI<def,tied1> = ADD32rm %ESI<tied0>, %RSP, 1, %noreg, -8, %noreg, %EFLAGS<imp-def>; mem:LD4[%y.addr]
	MOV32mr %RSP, 1, %noreg, -12, %noreg, %ESI<kill>; mem:ST4[%res]
	%EAX<def> = MOV32rm %RSP, 1, %noreg, -12, %noreg; mem:LD4[%res]
	RETQ %EAX<imp-use,kill>

# End machine code for function foo.


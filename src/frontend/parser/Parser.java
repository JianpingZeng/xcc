/* Parser.java */
/* Generated By:JavaCC: Do not edit this line. Parser.java */
package frontend.parser;

import frontend.ast.Flags;
import frontend.ast.Tree;
import frontend.ast.Tree.CaseStmt;
import frontend.ast.Tree.Literal;
import frontend.ast.Tree.VarDef;
import frontend.type.Type;
import tools.Context;
import tools.Log;
import tools.Name;
import tools.Position;

import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.InputStream;
import java.io.UnsupportedEncodingException;
import java.util.ArrayList;
import java.util.List;

/**
 * The frontend.parser that parses the micro-c source file.
 * It maps a token sequence into an abstract syntax
 * tree which operates by LR grammar.
 *
 * @version 1.0
 */
public class Parser implements ParserConstants
{

	/**
	 * The factory to be used for construction of abstract syntax tree.
	 */
	private TreeMaker F;

	/**
	 * Default supported character encoding style.
	 */
	static final public String SOURCE_ENCODING = "UTF-8";

	/**
	 * A name table.
	 */
	private Name.Table names;

	/**
	 * A logger to be error reporting.
	 */
	private Log log;

	/**
	 * The current token.
	 */
	private Token t;

	private static final Context.Key parserKey = new Context.Key();

	/**
	 * Constructs a frontend.parser.
	 *
	 * @param input   the input stream
	 * @param debug   whether debug  or not
	 * @param context A context object
	 */
	public Parser(InputStream input, boolean debug, Context context)
	{
		this(input, SOURCE_ENCODING);
		context.put(parserKey, this);
		this.F = TreeMaker.instance(context);
		this.log = Log.instance(context);
		this.names = Name.Table.instance(context);
		if (debug)
		{
			enable_tracing();
		}
		else
		{
			disable_tracing();
		}
	}

	/**
	 * Constructor with specifid file.
	 *
	 * @throws FileNotFoundException
	 * @throws UnsupportedEncodingException
	 */
	public Parser(String filename, boolean debug, Context context)
			throws UnsupportedEncodingException, FileNotFoundException
	{
		this(new FileInputStream(filename), debug, context);
	}

	/**
	 * Constructs a Integer literal node.
	 */
	private Literal integerNode(int pos, String image)
	{
		long i = integerValue(image);
		if (image.endsWith("L"))
		{
			return F.at(pos).Literal(Type.LongInteger, new Long(i));
		}
		else
		{
			return F.at(pos).Literal(Type.Int, new Integer((int) i));
		}
	}

	/**
	 * A auxiliary method for extracting a integer or long value.
	 */
	private long integerValue(String image)
	{
		String s = image.replaceFirst("[UL]+", "");
		if (s.startsWith("0x") || s.startsWith("0X"))
		{
			return Long.parseLong(s.substring(2), 16);
		}
		else if (s.startsWith("0") && !s.equals("0"))
		{
			return Long.parseLong(s.substring(1), 8);
		}
		else
		{
			return Long.parseLong(s, 10);
		}
	}

	/**
	 * A auxiliary method for extracting a string value.
	 */
	private String stringValue(String _image) throws ParseException
	{
		int pos = 0;
		int idx;
		StringBuffer buf = new StringBuffer();
		String image = _image.substring(1, _image.length() - 1);

		while ((idx = image.indexOf("\u005c\u005c", pos)) >= 0)
		{
			buf.append(image.substring(pos, idx));
			if (image.length() >= idx + 4 && Character
					.isDigit(image.charAt(idx + 1)) && Character
					.isDigit(image.charAt(idx + 2)) && Character
					.isDigit(image.charAt(idx + 3)))
			{
				buf.append(unescapeOctal(image.substring(idx + 1, idx + 4)));
				pos = idx + 4;
			}
			else
			{
				buf.append(unescapeSeq(image.charAt(idx + 1)));
				pos = idx + 2;
			}
		}
		if (pos < image.length())
		{
			buf.append(image.substring(pos, image.length()));
		}
		return buf.toString();
	}

	private static final int charMax = 255;

	private char unescapeOctal(String digits) throws ParseException
	{
		int i = Integer.parseInt(digits, 8);
		if (i > charMax)
		{
			throw new ParseException(
					"octal character sequence too big: \u005c\u005c" + digits);
		}
		return (char) i;
	}

	private static final char bell = 7;
	private static final char backspace = 8;
	private static final char escape = 27;
	private static final char vt = 11;

	private char unescapeSeq(char c) throws ParseException
	{
		switch (c)
		{
			case '0':
				return '\0';
			case '"':
				return '"';

			// there is a bug exist in below code caused by Javacc 6.0
			// this bug is that there is redundancy white space in the end
			// of character literal encoded by utf-8.
			case '\'': return '\'';
			case 'a':
				return bell;
			case 'b':
				return backspace;
			case 'e':
				return escape;
			case 'f':
				return '\f';
			case 'n':
				return '\n';
			case 'r':
				return '\r';
			case 't':
				return '\t';
			case 'v':
				return vt;
			default:
				throw new ParseException("unknown escape sequence: \"\\" + c);
		}
	}

	/**
	 * Acquires the current position of current token.
	 */
	private int position()
	{
		// get the current token
		Token current = getToken(0);
		return Position.make(current.beginLine, current.beginColumn);
	}

	final public Tree.TopLevel compilationUnit() throws ParseException
	{
		trace_call("compilationUnit");
		try
		{// two list that contain import clauses or frontend.type definition respectively
			List<Tree> importdecls, typedecls;
			t = getToken(1);
			importdecls = importDeclarations();
			typedecls = top_defs();
			jj_consume_token(0);
			importdecls.addAll(typedecls);
			int pos = position();
			{

				return F.at(pos).TopLevel(importdecls);
			}

		}
		finally
		{
			trace_return("compilationUnit");
		}
	}

	/**
	 * <p>Parses the import clauses and returns a abstract syntax tree which served as
	 * representation of import clauses.
	 * <p> Extended BNF grammer;
	 * <pre>
	 * importDeclarations::
	 * 				import_stmt;
	 * 				importDeclarations
	 * </pre>
	 *
	 * @return
	 */
	final public List<Tree> importDeclarations() throws ParseException
	{
		trace_call("importDeclarations");
		try
		{
			List<Tree> imports = new ArrayList<Tree>();
			Tree impt;
			label_1:
			while (true)
			{
				switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk)
				{
					case IMPORT:
					{
						break;
					}
					default:
						jj_la1[0] = jj_gen;
						break label_1;
				}
				impt = import_statement();
				imports.add(impt);
			}
			{

				return imports;
			}

		}
		finally
		{
			trace_return("importDeclarations");
		}
	}

	/**
	 * Handles single import statement and returns a string representing the import
	 * statement which consists of path name relative to directory of current project.
	 * <pre>
	 * import_statement::= ImportStmtClass name SEMICOLON
	 * 						| ImportStmtClass name DOT MULT SEMICOLON
	 *
	 * name	::=	simple_name
	 * 	|	qualified_name
	 * 	;
	 * simple_name ::=	IDENTIFIER
	 * 	;
	 * qualified_name ::=
	 * 		name DOT IDENTIFIER
	 * 	;
	 * </pre>
	 *
	 * @return
	 */
	final public Tree import_statement() throws ParseException
	{
		trace_call("import_statement");
		try
		{
			Tree pid;
			Name n;
			int pos;
			jj_consume_token(IMPORT);
			n = name();
			pos = position();
			pid = F.at(pos).Ident(n);
			label_2:
			while (true)
			{
				switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk)
				{
					case 52:
					{
						break;
					}
					default:
						jj_la1[1] = jj_gen;
						break label_2;
				}
				jj_consume_token(52);
				n = name();
				pos = position();
				pid = F.at(pos).Select(pid, n);
			}
			jj_consume_token(53);
			{

				return F.at(pos).Import(pid);
			}

		}
		finally
		{
			trace_return("import_statement");
		}
	}

	/**
	 * Gets a Name instance from a token.
	 */
	final public Name name() throws ParseException
	{
		trace_call("name");
		try
		{
			t = jj_consume_token(IDENTIFIER);
			{

				return Name.fromString(names, t.image);
			}

		}
		finally
		{
			trace_return("name");
		}
	}

	/**
	 * A sequence of definition or declaration of variable and function.
	 * <pre>
	 * type_declarations_opt   ::= type_declarations   | ;
	 * type_declarations ::=
	 * 		type_declaration
	 * 	|	type_declarations type_declaration
	 *
	 * type_declaration ::=
	 * 		Function_declaration
	 * 	|	variable_declaration (包括结构体和普�?�变量声明，以及类型重定义typedef)
	 * 	|	SEMICOLON
	 * </pre>
	 *
	 * @return
	 */
	final public List<Tree> top_defs() throws ParseException
	{
		trace_call("top_defs");
		try
		{
			List<Tree> res;
			List<Tree> decls = new ArrayList<Tree>();
			label_3:
			while (true)
			{
				switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk)
				{
					case VOID:
					case CHAR:
					case SHORT:
					case INT:
					case LONG:
					case BOOL:
					case STATIC:
					case CONST:
					{
						break;
					}
					default:
						jj_la1[2] = jj_gen;
						break label_3;
				}
				res = declaration();
				decls.addAll(res);
			}
			{

				return decls;
			}

		}
		finally
		{
			trace_return("top_defs");
		}
	}

	final public List<Tree> declaration() throws ParseException
	{
		trace_call("declaration");
		try
		{/**
		 * the definition of various of variables.
		 */
			Tree methodDef;
			List<Tree> defvars;

			List<Tree> defs = new ArrayList<Tree>();
			if (jj_2_1(2147483647))
			{
				methodDef = functionDecl();
				defs.add(methodDef);
			}
			else
			{
				switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk)
				{
					case VOID:
					case CHAR:
					case SHORT:
					case INT:
					case LONG:
					case BOOL:
					case STATIC:
					case CONST:
					{
						defvars = variableDefinitions();
						defs.addAll(defvars);

						return defs;

					}
					default:
						jj_la1[3] = jj_gen;
						jj_consume_token(-1);
						throw new ParseException();
				}
			}
			throw new Error("Missing return statement in function");
		}
		finally
		{
			trace_return("declaration");
		}
	}

	/**
	 * A sequence of variable definition.
	 * <pre>
	 * variable_def ::=
	 * 					storage_class_qualifier type_specifier ID
	 * 				|   storage_class_qualifier type_specifier ID = variable_initializer
	 * rariable_initializer ::= subExpr
	 * </pre>
	 *
	 * @return
	 */
	final public List<Tree> variableDefinitions() throws ParseException
	{
		trace_call("variableDefinitions");
		try
		{// a list at which a large amounts of various of definition storages. 
			List<Tree> defs = new ArrayList<Tree>();
			long flags = 0;
			long flag = 0;
			Tree type;
			Name name;
			Tree init = null;
			int pos = Position.NOPOS;
			label_4:
			while (true)
			{
				switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk)
				{
					case STATIC:
					case CONST:
					{
						break;
					}
					default:
						jj_la1[4] = jj_gen;
						break label_4;
				}
				switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk)
				{
					case STATIC:
					{
						t = jj_consume_token(STATIC);
						if ((flags & Flags.STATIC) != 0)
						{
							if (true)
								throw generateParseException();
						}
						else
							flags |= Flags.STATIC;
						break;
					}
					case CONST:
					{
						t = jj_consume_token(CONST);
						if ((flags & Flags.CONST) != 0)
						{
							if (true)
								throw generateParseException();
						}
						else
							flags |= Flags.CONST;
						break;
					}
					default:
						jj_la1[5] = jj_gen;
						jj_consume_token(-1);
						throw new ParseException();
				}
			}
			if (flags != 0)
				pos = position();
			type = type();
			if (flags == 0)
				pos = position();
			name = name();
			switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk)
			{
				case 55:
				{
					jj_consume_token(55);
					init = expr();
					break;
				}
				default:
					jj_la1[6] = jj_gen;
			}
			VarDef result = F.at(pos).VarDef(flags, name, type, init);
			defs.add(result);
			init = null;
			label_5:
			while (true)
			{
				switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk)
				{
					case 56:
					{
						break;
					}
					default:
						jj_la1[7] = jj_gen;
						break label_5;
				}
				jj_consume_token(56);
				name = name();
				switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk)
				{
					case 55:
					{
						jj_consume_token(55);
						init = expr();
						break;
					}
					default:
						jj_la1[8] = jj_gen;
				}
				result = F.at(pos).VarDef(flags, name, type, init);
				defs.add(result);
				init = null;
			}
			jj_consume_token(53);
			{

				return defs;
			}

		}
		finally
		{
			trace_return("variableDefinitions");
		}
	}

	/**
	 * Handles the initialization portion of variable definition statement.
	 */
	final public Tree variableInit() throws ParseException
	{
		trace_call("variableInit");
		try
		{
			Tree expr;
			if (jj_2_2(2147483647))
			{
				jj_consume_token(57);
				{

					return arrayInit(null);
				}
			}
			else
			{
				switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk)
				{
					case TRUE_:
					case FALSE_:
					case IDENTIFIER:
					case INTEGER:
					case CHARACTER:
					case 54:
					case 63:
					case 64:
					case 89:
					case 90:
					case 94:
					case 95:
					{
						expr = expr();
						{

							return expr;
						}

					}
					default:
						jj_la1[9] = jj_gen;
						jj_consume_token(-1);
						throw new ParseException();
				}
			}
		}
		finally
		{
			trace_return("variableInit");
		}
	}

	/**
	 * ArrayInitializer = "{" [VariableInit {"," VariableInit}] [","] "}"
	 */
	final public Tree arrayInit(Tree type) throws ParseException
	{
		trace_call("arrayInit");
		try
		{
			List<Tree> elems = new ArrayList<Tree>();
			Tree res;
			int pos = 0;
			switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk)
			{
				case 57:
				{
					jj_consume_token(57);
					pos = position();
					// second, parse the optional variable initializer for array.	
					// "," "}" { return F.at(pos).NewArray(frontend.type, Tree.emptyList, elems); }

					res = variableInit();
					elems.add(res);
					label_6:
					while (true)
					{
						if (jj_2_3(2))
						{
						}
						else
						{
							break label_6;
						}
						jj_consume_token(56);
						res = variableInit();
						elems.add(res);
					}
					break;
				}
				case 56:
				{
					jj_consume_token(56);
					jj_consume_token(58);
					{

						return F.at(pos).NewArray(type, Tree.emptyList, elems);
					}

				}
				case 58:
				{
					jj_consume_token(58);
					{

						return F.at(pos).NewArray(type, Tree.emptyList, elems);
					}

				}
				default:
					jj_la1[10] = jj_gen;
					jj_consume_token(-1);
					throw new ParseException();
			}
			throw new Error("Missing return statement in function");
		}
		finally
		{
			trace_return("arrayInit");
		}
	}

	/**
	 * A handler to function definition or declaration.
	 * <p>
	 * function_def ::=
	 * storage_class_qualifier Type Name "(" param_lists_opt ")" block
	 * param_lists_opt ::=
	 * | param_lists
	 * <p>
	 * param_lists ::=
	 * variable_declaration
	 * |   variable_declaration "," param_list
	 *
	 * @return A root of AST which represents a MethodDef syntax structure.
	 */
	final public Tree functionDecl() throws ParseException
	{
		trace_call("functionDecl");
		try
		{
			long flags = 0;
			Tree rettype;
			Name methodName;
			List<Tree> params;
			Tree body = null;
			int pos = 0;
			flags = storage();
			if (flags != 0)
				pos = position();
			rettype = type();
			if (flags == 0)
				pos = rettype.pos;
			methodName = name();
			params = formalParameters();
			switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk)
			{
				case 57:
				{
					body = block();
					break;
				}
				case 53:
				{
					jj_consume_token(53);
					break;
				}
				default:
					jj_la1[11] = jj_gen;
					jj_consume_token(-1);
					throw new ParseException();
			}
			{

				return F.at(pos)
						.MethodDef(flags, methodName, rettype, params, body);
			}

		}
		finally
		{
			trace_return("functionDecl");
		}
	}

	/**
	 * Identify the storage class qualifier.
	 */
	final public long storage() throws ParseException
	{
		trace_call("storage");
		try
		{
			long flags = 0;
			t = null;
			switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk)
			{
				case STATIC:
				{
					t = jj_consume_token(STATIC);
					break;
				}
				default:
					jj_la1[12] = jj_gen;
			}
			if (t != null)
			{

				return flags |= Flags.STATIC;
			}
			else
			{

				return flags;
			}

		}
		finally
		{
			trace_return("storage");
		}
	}

	/**
	 * A method that parses parameters list in the function declaration.
	 *
	 * @return A list of all of parameters.
	 */
	final public List<Tree> formalParameters() throws ParseException
	{
		trace_call("formalParameters");
		try
		{
			List<Tree> params = new ArrayList<Tree>();
			Tree singleParam;
			jj_consume_token(54);
			switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk)
			{
				case VOID:
				case CHAR:
				case SHORT:
				case INT:
				case LONG:
				case BOOL:
				{
					singleParam = formalParameter();
					params.add(singleParam);
					label_7:
					while (true)
					{
						switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk)
						{
							case 56:
							{
								break;
							}
							default:
								jj_la1[13] = jj_gen;
								break label_7;
						}
						jj_consume_token(56);
						singleParam = formalParameter();
						params.add(singleParam);
					}
					break;
				}
				default:
					jj_la1[14] = jj_gen;
			}
			jj_consume_token(59);
			{

				return params;
			}

		}
		finally
		{
			trace_return("formalParameters");
		}
	}

	/**
	 * Parses the single variable declaration statement of function parameter list.
	 *
	 * @return
	 */
	final public Tree formalParameter() throws ParseException
	{
		trace_call("formalParameter");
		try
		{
			Tree t;
			Name n;
			t = type();
			n = name();
			{

				return F.at(t.pos).VarDef(Flags.PARAMETER, n, t, null);
			}

		}
		finally
		{
			trace_return("formalParameter");
		}
	}

	/**
	 * Parses the function body.
	 * <pre>
	 * Block_stmt ::=
	 * 				varibale_defs stmts
	 * </pre>
	 *
	 * @return
	 */
	final public Tree block() throws ParseException
	{
		trace_call("block");
		try
		{
			int pos;
			List<Tree> stats, res = new ArrayList<Tree>();
			t = jj_consume_token(57);
			pos = position();
			label_8:
			while (true)
			{
				switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk)
				{
					case VOID:
					case CHAR:
					case SHORT:
					case INT:
					case LONG:
					case BOOL:
					case STATIC:
					case CONST:
					case TRUE_:
					case FALSE_:
					case IF:
					case SWITCH:
					case WHILE:
					case DO:
					case FOR:
					case RETURN:
					case BREAK:
					case CONTINUE:
					case GOTO:
					case IDENTIFIER:
					case INTEGER:
					case CHARACTER:
					case 53:
					case 54:
					case 57:
					case 63:
					case 64:
					case 89:
					case 90:
					case 94:
					case 95:
					{
						break;
					}
					default:
						jj_la1[15] = jj_gen;
						break label_8;
				}
				stats = blockStatement();
				res.addAll(stats);
			}
			jj_consume_token(58);
			{

				return F.at(pos).Block(res);
			}

		}
		finally
		{
			trace_return("block");
		}
	}

	/**
	 * Just for all statements in block statement.
	 */
	final public List<Tree> blockStatement() throws ParseException
	{
		trace_call("blockStatement");
		try
		{
			List<Tree> vars;
			List<Tree> res = new ArrayList<Tree>();
			Tree stmt;
			if (jj_2_4(2147483647))
			{
				vars = variableDefinitions();
				jj_consume_token(53);
				res.addAll(vars);
			}
			else
			{
				switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk)
				{
					case TRUE_:
					case FALSE_:
					case IF:
					case SWITCH:
					case WHILE:
					case DO:
					case FOR:
					case RETURN:
					case BREAK:
					case CONTINUE:
					case GOTO:
					case IDENTIFIER:
					case INTEGER:
					case CHARACTER:
					case 53:
					case 54:
					case 57:
					case 63:
					case 64:
					case 89:
					case 90:
					case 94:
					case 95:
					{
						stmt = statement();
						res.add(stmt);

						return res;

					}
					default:
						jj_la1[16] = jj_gen;
						jj_consume_token(-1);
						throw new ParseException();
				}
			}
			throw new Error("Missing return statement in function");
		}
		finally
		{
			trace_return("blockStatement");
		}
	}

	/**
	 * handles to frontend.type syntax construct.
	 */
	final public Tree type() throws ParseException
	{
		trace_call("frontend/type");
		try
		{
			Tree ref;
			// basic frontend.type reference, such as void, char, int, long etc.
			ref = baseType();
			label_9:
			while (true)
			{
				switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk)
				{
					case 60:
					{
						break;
					}
					default:
						jj_la1[17] = jj_gen;
						break label_9;
				}
				jj_consume_token(60);
				jj_consume_token(61);
				// array frontend.type reference to no getArraySize
				ref = F.at(ref.pos).TypeArray(ref);
			}
			{

				return ref;
			}

		}
		finally
		{
			trace_return("frontend/type");
		}
	}

	/**
	 * Parses the base frontend.type.
	 */
	final public Tree baseType() throws ParseException
	{
		trace_call("baseType");
		try
		{
			int pos;
			switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk)
			{
				case VOID:
				{
					t = jj_consume_token(VOID);
					pos = position();
					{

						return F.at(pos).TypeIdent(Type.Void);
					}

				}
				case CHAR:
				{
					t = jj_consume_token(CHAR);
					pos = position();
					{

						return F.at(pos).TypeIdent(Type.Char);
					}

				}
				case SHORT:
				{
					t = jj_consume_token(SHORT);
					pos = position();
					{

						return F.at(pos).TypeIdent(Type.Short);
					}

				}
				case INT:
				{
					t = jj_consume_token(INT);
					pos = position();
					{

						return F.at(pos).TypeIdent(Type.Int);
					}

				}
				case LONG:
				{
					t = jj_consume_token(LONG);
					pos = position();
					{

						return F.at(pos).TypeIdent(Type.LongInteger);
					}

				}
				case BOOL:
				{
					t = jj_consume_token(BOOL);
					pos = position();
					{

						return F.at(pos).TypeIdent(Type.BOOL);
					}

				}
				default:
					jj_la1[18] = jj_gen;
					jj_consume_token(-1);
					throw new ParseException();
			}

		}
		finally
		{
			trace_return("baseType");
		}
	}

	/**
	 * Parses a kind of various statement, like if statement discussed below.
	 * <pre>
	 * stmt ::= ;
	 * 			|labeled_stmt
	 * 			|subExpr SEMICOLON
	 * 			|block
	 * 			|if_stmt
	 * 			|while_stmt
	 * 			|dowhile_stmt
	 * 			|for_stmt
	 * 			|switch_stmt
	 * 			|break_stmt
	 * 			|continue_stmt
	 * 			|goto_stmt
	 * 			|return_stmt;
	 * </pre>
	 */
	final public Tree statement() throws ParseException
	{
		trace_call("statement");
		try
		{
			Tree tree = null, expr = null;
			switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk)
			{
				case 53:
				{
					jj_consume_token(53);
					break;
				}
				default:
					jj_la1[19] = jj_gen;
					if (jj_2_5(2))
					{
						tree = labeledStmt();
					}
					else if (jj_2_6(3))
					{
						expr = expr();
						jj_consume_token(53);
						tree = F.at(tree.pos).Exec(expr);
					}
					else
					{
						switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk)
						{
							case 57:
							{
								tree = block();
								break;
							}
							case IF:
							{
								tree = ifStmt();
								break;
							}
							case WHILE:
							{
								tree = whileStmt();
								break;
							}
							case DO:
							{
								tree = doStmt();
								break;
							}
							case FOR:
							{
								tree = forStmt();
								break;
							}
							case SWITCH:
							{
								tree = switchStmt();
								break;
							}
							case BREAK:
							{
								tree = breakStmt();
								break;
							}
							case CONTINUE:
							{
								tree = continueStmt();
								break;
							}
							case GOTO:
							{
								tree = gotoStmt();
								break;
							}
							case TRUE_:
							case FALSE_:
							case RETURN:
							case IDENTIFIER:
							case INTEGER:
							case CHARACTER:
							case 54:
							case 63:
							case 64:
							case 89:
							case 90:
							case 94:
							case 95:
							{
								tree = returnStmt();
								break;
							}
							default:
								jj_la1[20] = jj_gen;
								jj_consume_token(-1);
								throw new ParseException();
						}
					}
			}
			{

				return tree;
			}

		}
		finally
		{
			trace_return("statement");
		}
	}

	/**
	 * Parses labeled statement.
	 */
	final public Tree labeledStmt() throws ParseException
	{
		trace_call("labeledStmt");
		try
		{
			Tree body;
			int pos;
			Name n;
			n = name();
			pos = position();
			jj_consume_token(62);
			body = statement();
			{

				return F.at(pos).Labelled(n, body);
			}

		}
		finally
		{
			trace_return("labeledStmt");
		}
	}

	/**
	 * Parses if statement.
	 */
	final public Tree ifStmt() throws ParseException
	{
		trace_call("ifStmt");
		try
		{
			Tree cond, thenBody, elseBody = null;
			int pos;
			// this is a famous problem at c language that "dangling else".
			// It might be solved by lookahead one token.

			t = jj_consume_token(IF);
			pos = position();
			jj_consume_token(54);
			cond = expr();
			jj_consume_token(59);
			thenBody = statement();
			switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk)
			{
				case ELSE:
				{
					jj_consume_token(ELSE);
					elseBody = statement();
					break;
				}
				default:
					jj_la1[21] = jj_gen;
			}
			{

				return F.at(pos).If(cond, thenBody, elseBody);
			}

		}
		finally
		{
			trace_return("ifStmt");
		}
	}

	/**
	 * Parses while statement.
	 */
	final public Tree whileStmt() throws ParseException
	{
		trace_call("whileStmt");
		try
		{
			Tree cond, body;
			int pos;
			t = jj_consume_token(WHILE);
			pos = position();
			jj_consume_token(54);
			cond = expr();
			jj_consume_token(59);
			body = statement();
			{

				return F.at(pos).WhileLoop(cond, body);
			}

		}
		finally
		{
			trace_return("whileStmt");
		}
	}

	/**
	 * Parses do while statement.
	 */
	final public Tree doStmt() throws ParseException
	{
		trace_call("doStmt");
		try
		{
			Tree cond, body;
			int pos;
			t = jj_consume_token(DO);
			pos = position();
			body = statement();
			jj_consume_token(WHILE);
			jj_consume_token(54);
			cond = expr();
			jj_consume_token(59);
			jj_consume_token(53);
			{

				return F.at(pos).DoLoop(cond, body);
			}

		}
		finally
		{
			trace_return("doStmt");
		}
	}

	/**
	 * Parses for statement.
	 */
	final public Tree forStmt() throws ParseException
	{
		trace_call("forStmt");
		try
		{
			List<Tree> init = null, incr = null;
			Tree body, cond = null;
			int pos;
			t = jj_consume_token(FOR);
			pos = position();
			jj_consume_token(54);
			switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk)
			{
				case VOID:
				case CHAR:
				case SHORT:
				case INT:
				case LONG:
				case BOOL:
				case STATIC:
				case CONST:
				case TRUE_:
				case FALSE_:
				case IDENTIFIER:
				case INTEGER:
				case CHARACTER:
				case 54:
				case 63:
				case 64:
				{
					init = forInit();
					break;
				}
				default:
					jj_la1[22] = jj_gen;
			}
			jj_consume_token(53);
			switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk)
			{
				case TRUE_:
				case FALSE_:
				case IDENTIFIER:
				case INTEGER:
				case CHARACTER:
				case 54:
				case 63:
				case 64:
				case 89:
				case 90:
				case 94:
				case 95:
				{
					cond = expr();
					break;
				}
				default:
					jj_la1[23] = jj_gen;
			}
			jj_consume_token(53);
			switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk)
			{
				case TRUE_:
				case FALSE_:
				case IDENTIFIER:
				case INTEGER:
				case CHARACTER:
				case 54:
				case 63:
				case 64:
				{
					incr = forUpdate();
					break;
				}
				default:
					jj_la1[24] = jj_gen;
			}
			jj_consume_token(59);
			body = statement();
			{

				return F.at(pos).ForLoop(init, cond, incr, body);
			}

		}
		finally
		{
			trace_return("forStmt");
		}
	}

	/**
	 * Parses the initialization part of for loop.
	 */
	final public List<Tree> forInit() throws ParseException
	{
		trace_call("forInit");
		try
		{
			List<Tree> res;
			if (jj_2_7(2147483647))
			{
				res = variableDefinitions();
				{

					return res;
				}
			}
			else
			{
				switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk)
				{
					case TRUE_:
					case FALSE_:
					case IDENTIFIER:
					case INTEGER:
					case CHARACTER:
					case 54:
					case 63:
					case 64:
					{
						res = stmtExprs();
						{

							return res;
						}

					}
					default:
						jj_la1[25] = jj_gen;
						jj_consume_token(-1);
						throw new ParseException();
				}
			}

		}
		finally
		{
			trace_return("forInit");
		}
	}

	/**
	 * Parses the update parts of for statement.
	 */
	final public List<Tree> forUpdate() throws ParseException
	{
		trace_call("forUpdate");
		try
		{
			List<Tree> list;
			list = stmtExprs();
			{

				return list;
			}

		}
		finally
		{
			trace_return("forUpdate");
		}
	}

	/**
	 * Parses subExpr statement sequences.
	 */
	final public List<Tree> stmtExprs() throws ParseException
	{
		trace_call("stmtExprs");
		try
		{
			List<Tree> stats = new ArrayList<Tree>();
			Tree res;
			res = stmtExpr();
			stats.add(res);
			label_10:
			while (true)
			{
				switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk)
				{
					case 56:
					{
						break;
					}
					default:
						jj_la1[26] = jj_gen;
						break label_10;
				}
				jj_consume_token(56);
				res = stmtExpr();
				stats.add(res);
			}
			{

				return stats;
			}

		}
		finally
		{
			trace_return("stmtExprs");
		}
	}

	/**
	 * The last expansion of this production accepts more than the legal
	 * Java expansions for StatementExpression.  This expansion does not
	 * use PostfixExpression for performance reasons.
	 */
	final public Tree stmtExpr() throws ParseException
	{
		trace_call("stmtExpr");
		try
		{
			Tree expr;
			int pos;
			Tree rhs;
			int op;
			switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk)
			{
				case 63:
				{
					t = jj_consume_token(63);
					pos = position();
					expr = unary();
					expr = F.at(pos).Unary(Tree.PREINC, expr);
					break;
				}
				case 64:
				{
					t = jj_consume_token(64);
					pos = position();
					expr = unary();
					expr = F.at(pos).Unary(Tree.PREDEC, expr);
					break;
				}
				case TRUE_:
				case FALSE_:
				case IDENTIFIER:
				case INTEGER:
				case CHARACTER:
				case 54:
				{
					expr = primary();
					switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk)
					{
						case 55:
						case 63:
						case 64:
						case 65:
						case 66:
						case 67:
						case 68:
						case 69:
						case 70:
						case 71:
						case 72:
						case 73:
						case 74:
						{
							switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk)
							{
								case 63:
								{
									jj_consume_token(63);
									expr = F.at(expr.pos)
											.Unary(Tree.POSTINC, expr);
									break;
								}
								case 64:
								{
									jj_consume_token(64);
									expr = F.at(expr.pos)
											.Unary(Tree.POSTDEC, expr);
									break;
								}
								case 55:
								{
									jj_consume_token(55);
									rhs = expr();
									expr = F.at(expr.pos).Assign(expr, rhs);
									break;
								}
								case 65:
								case 66:
								case 67:
								case 68:
								case 69:
								case 70:
								case 71:
								case 72:
								case 73:
								case 74:
								{
									op = opAssign();
									rhs = expr();
									expr = F.at(expr.pos)
											.Assignop(op, expr, rhs);
									break;
								}
								default:
									jj_la1[27] = jj_gen;
									jj_consume_token(-1);
									throw new ParseException();
							}
							break;
						}
						default:
							jj_la1[28] = jj_gen;
					}
					{

						return expr;
					}

				}
				default:
					jj_la1[29] = jj_gen;
					jj_consume_token(-1);
					throw new ParseException();
			}
			throw new Error("Missing return statement in function");
		}
		finally
		{
			trace_return("stmtExpr");
		}
	}

	/**
	 * Parses switch statement.
	 */
	final public Tree switchStmt() throws ParseException
	{
		trace_call("switchStmt");
		try
		{
			int pos;
			Tree selector;
			List<CaseStmt> cases;
			t = jj_consume_token(SWITCH);
			pos = position();
			jj_consume_token(54);
			selector = expr();
			jj_consume_token(59);
			jj_consume_token(57);
			cases = switchBlockStatementGroups();
			jj_consume_token(58);
			{

				return F.at(pos).Switch(selector, cases);
			}

		}
		finally
		{
			trace_return("switchStmt");
		}
	}

	final public List<Tree.CaseStmt> switchBlockStatementGroups() throws ParseException
	{
		trace_call("switchBlockStatementGroups");
		try
		{
			List<Tree.CaseStmt> cases = new ArrayList<CaseStmt>();
			Tree pat;
			List<Tree> stmts;
			ArrayList<Tree> values = new ArrayList<Tree>();
			int pos;
			label_11:
			while (true)
			{
				switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk)
				{
					case CASE:
					{
						break;
					}
					default:
						jj_la1[30] = jj_gen;
						break label_11;
				}
				label_12:
				while (true)
				{
					t = jj_consume_token(CASE);
					pos = position();
					pat = expr();
					jj_consume_token(62);
					values.add(pat);
					switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk)
					{
						case CASE:
						{
							break;
						}
						default:
							jj_la1[31] = jj_gen;
							break label_12;
					}
				}
				stmts = blockStatement();
				cases.add(F.at(pos).Case(values, F.at(pos).Block(stmts)));
			}
			switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk)
			{
				case DEFAULT_:
				{
					t = jj_consume_token(DEFAULT_);
					pos = position();
					jj_consume_token(62);

					stmts = blockStatement();
					cases.add(F.at(pos).Case(values, F.at(pos).Block(stmts)));
					break;
				}
				default:
					jj_la1[32] = jj_gen;
			}
			{

				return cases;
			}

		}
		finally
		{
			trace_return("switchBlockStatementGroups");
		}
	}

	/**
	 * Parses goto statement.
	 */
	final public Tree gotoStmt() throws ParseException
	{
		trace_call("gotoStmt");
		try
		{
			Name n;
			int pos;
			t = jj_consume_token(GOTO);
			pos = position();
			n = name();
			jj_consume_token(53);
			{

				return F.at(pos).Goto(n);
			}

		}
		finally
		{
			trace_return("gotoStmt");
		}
	}

	/**
	 * Parses break statement.
	 */
	final public Tree breakStmt() throws ParseException
	{
		trace_call("breakStmt");
		try
		{
			int pos;
			t = jj_consume_token(BREAK);
			pos = position();
			jj_consume_token(53);
			{

				return F.at(pos).Break();
			}

		}
		finally
		{
			trace_return("breakStmt");
		}
	}

	/**
	 * Parses continue statement.
	 */
	final public Tree continueStmt() throws ParseException
	{
		trace_call("continueStmt");
		try
		{
			int pos;
			t = jj_consume_token(CONTINUE);
			pos = position();
			jj_consume_token(53);
			{

				return F.at(pos).Continue();
			}

		}
		finally
		{
			trace_return("continueStmt");
		}
	}

	/**
	 * Parses return statement.
	 */
	final public Tree returnStmt() throws ParseException
	{
		trace_call("returnStmt");
		try
		{
			Tree expr;
			int pos;
			switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk)
			{
				case RETURN:
				{
					t = jj_consume_token(RETURN);
					pos = position();
					jj_consume_token(53);
					return F.at(pos).Return(null);
				}
				case TRUE_:
				case FALSE_:
				case IDENTIFIER:
				case INTEGER:
				case CHARACTER:
				case 54:
				case 63:
				case 64:
				case 89:
				case 90:
				case 94:
				case 95:
				{
					expr = expr();
					jj_consume_token(53);
					return F.at(expr.pos).Return(expr);
				}
				default:
					jj_la1[33] = jj_gen;
					jj_consume_token(-1);
					throw new ParseException();
			}

		}
		finally
		{
			trace_return("returnStmt");
		}
	}

	/**
	 * Parses expression statement.
	 */
	final public Tree expr() throws ParseException
	{
		trace_call("subExpr");
		try
		{
			Tree lhs, rhs, expr;
			int op;
			if (jj_2_8(2147483647))
			{
				lhs = term();
				jj_consume_token(55);
				rhs = expr();
				return F.at(lhs.pos).Assign(lhs, rhs);
			}
			else if (jj_2_9(2147483647))
			{
				lhs = term();
				op = opAssign();
				rhs = expr();
				return F.at(lhs.pos).Assignop(op, lhs, rhs);
			}
			else
			{
				switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk)
				{
					case TRUE_:
					case FALSE_:
					case IDENTIFIER:
					case INTEGER:
					case CHARACTER:
					case 54:
					case 63:
					case 64:
					case 89:
					case 90:
					case 94:
					case 95:
					{
						expr = expr10();
						return expr;
					}
					default:
						jj_la1[34] = jj_gen;
						jj_consume_token(-1);
						throw new ParseException();
				}
			}
		}
		finally
		{
			trace_return("subExpr");
		}
	}

	/**
	 * Parses operation assignment statement.
	 * <p>such as +=, -= , *= and so on.
	 */
	final public int opAssign() throws ParseException
	{
		trace_call("opAssign");
		try
		{
			switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk)
			{
				case 65:
				{
					jj_consume_token(65);
					return Tree.PLUS_ASG;
				}
				case 66:
				{
					jj_consume_token(66);
					return Tree.MINUS_ASG;
				}
				case 67:
				{
					jj_consume_token(67);
					return Tree.MUL_ASG;
				}
				case 68:
				{
					jj_consume_token(68);
					return Tree.DIV_ASG;
				}
				case 69:
				{
					jj_consume_token(69);
					return Tree.MOD_ASG;
				}
				case 70:
				{
					jj_consume_token(70);
					return Tree.BITAND_ASG;
				}
				case 71:
				{
					jj_consume_token(71);
					return Tree.BITOR_ASG;
				}
				case 72:
				{
					jj_consume_token(72);
					return Tree.BITXOR_ASG;
				}
				case 73:
				{
					jj_consume_token(73);
					return Tree.SL_ASG;
				}
				case 74:
				{
					jj_consume_token(74);
					return Tree.SR_ASG;
				}
				default:
					jj_la1[35] = jj_gen;
					jj_consume_token(-1);
					throw new ParseException();
			}

		}
		finally
		{
			trace_return("opAssign");
		}
	}

	/**
	 * Parses condition expression.
	 */
	final public Tree expr10() throws ParseException
	{
		trace_call("expr10");
		try
		{
			Tree cond, truePart, elsePart;
			// other subExpr or ? : subExpr.
			cond = expr9();
			switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk)
			{
				case 75:
				{
					jj_consume_token(75);
					truePart = expr();
					jj_consume_token(62);
					elsePart = expr();
					{

						return F.at(cond.pos)
								.Conditional(cond, truePart, elsePart);
					}

				}
				default:
					jj_la1[36] = jj_gen;
			}
			return cond;

		}
		finally
		{
			trace_return("expr10");
		}
	}

	/**
	 * Logical or expression.
	 */
	final public Tree expr9() throws ParseException
	{
		trace_call("expr9");
		try
		{
			Tree l, r;
			l = expr8();
			label_13:
			while (true)
			{
				switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk)
				{
					case 76:
					{
						break;
					}
					default:
						jj_la1[37] = jj_gen;
						break label_13;
				}
				jj_consume_token(76);
				r = expr8();
				l = F.at(l.pos).Binary(Tree.OR, l, r);
			}
			return l;
		}
		finally
		{
			trace_return("expr9");
		}
	}

	/**
	 * Logical and subExpr.
	 */
	final public Tree expr8() throws ParseException
	{
		trace_call("expr8");
		try
		{
			Tree l, r;
			l = expr7();
			label_14:
			while (true)
			{
				switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk)
				{
					case 77:
					{
						break;
					}
					default:
						jj_la1[38] = jj_gen;
						break label_14;
				}
				jj_consume_token(77);
				r = expr7();
				l = F.at(l.pos).Binary(Tree.AND, l, r);
			}
			return l;
		}
		finally
		{
			trace_return("expr8");
		}
	}

	/**
	 * relational subExpr.
	 */
	final public Tree expr7() throws ParseException
	{
		trace_call("expr7");
		try
		{
			Tree l, r;
			l = expr6();
			label_15:
			while (true)
			{
				switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk)
				{
					case 78:
					case 79:
					case 80:
					case 81:
					case 82:
					case 83:
					{
						break;
					}
					default:
						jj_la1[39] = jj_gen;
						break label_15;
				}
				switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk)
				{
					case 78:
					{
						jj_consume_token(78);
						r = expr6();
						l = F.at(l.pos).Binary(Tree.GT, l, r);
						break;
					}
					case 79:
					{
						jj_consume_token(79);
						r = expr6();
						l = F.at(l.pos).Binary(Tree.LT, l, r);
						break;
					}
					case 80:
					{
						jj_consume_token(80);
						r = expr6();
						l = F.at(l.pos).Binary(Tree.GE, l, r);
						break;
					}
					case 81:
					{
						jj_consume_token(81);
						r = expr6();
						l = F.at(l.pos).Binary(Tree.LE, l, r);
						break;
					}
					case 82:
					{
						jj_consume_token(82);
						r = expr6();
						l = F.at(l.pos).Binary(Tree.EQ, l, r);
						break;
					}
					case 83:
					{
						jj_consume_token(83);
						r = expr6();
						l = F.at(l.pos).Binary(Tree.NE, l, r);
						break;
					}
					default:
						jj_la1[40] = jj_gen;
						jj_consume_token(-1);
						throw new ParseException();
				}
			}
			return l;
		}
		finally
		{
			trace_return("expr7");
		}
	}

	/**
	 * Parses bit or expression.
	 */
	final public Tree expr6() throws ParseException
	{
		trace_call("expr6");
		try
		{
			Tree l, r;
			l = expr5();
			label_16:
			while (true)
			{
				switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk)
				{
					case 84:
					{
						break;
					}
					default:
						jj_la1[41] = jj_gen;
						break label_16;
				}
				jj_consume_token(84);
				r = expr5();
				l = F.at(l.pos).Binary(Tree.BITOR, l, r);
			}
			return l;
		}
		finally
		{
			trace_return("expr6");
		}
	}

	/**
	 * Parses exclusive bit or expression.
	 */
	final public Tree expr5() throws ParseException
	{
		trace_call("expr5");
		try
		{
			Tree l, r;
			l = expr4();
			label_17:
			while (true)
			{
				switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk)
				{
					case 85:
					{
						break;
					}
					default:
						jj_la1[42] = jj_gen;
						break label_17;
				}
				jj_consume_token(85);
				r = expr4();
				l = F.at(l.pos).Binary(Tree.BITXOR, l, r);
			}
			return l;
		}
		finally
		{
			trace_return("expr5");
		}
	}

	/**
	 * Parses bit and expression.
	 */
	final public Tree expr4() throws ParseException
	{
		trace_call("expr4");
		try
		{
			Tree l, r;
			l = expr3();
			label_18:
			while (true)
			{
				switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk)
				{
					case 86:
					{
						break;
					}
					default:
						jj_la1[43] = jj_gen;
						break label_18;
				}
				jj_consume_token(86);
				r = expr3();
				l = F.at(l.pos).Binary(Tree.BITAND, l, r);
			}
			return l;
		}
		finally
		{
			trace_return("expr4");
		}
	}

	/**
	 * Parses right or left shift expression.
	 */
	final public Tree expr3() throws ParseException
	{
		trace_call("expr3");
		try
		{
			Tree l, r;
			l = expr2();
			label_19:
			while (true)
			{
				switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk)
				{
					case 87:
					case 88:
					{
						break;
					}
					default:
						jj_la1[44] = jj_gen;
						break label_19;
				}
				switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk)
				{
					case 87:
					{
						jj_consume_token(87);
						r = expr2();
						l = F.at(l.pos).Binary(Tree.SL, l, r);
						break;
					}
					case 88:
					{
						jj_consume_token(88);
						r = expr2();
						l = F.at(l.pos).Binary(Tree.SR, l, r);
						break;
					}
					default:
						jj_la1[45] = jj_gen;
						jj_consume_token(-1);
						throw new ParseException();
				}
			}
			return l;
		}
		finally
		{
			trace_return("expr3");
		}
	}

	/**
	 * Parses plus or minus subExpr.
	 */
	final public Tree expr2() throws ParseException
	{
		trace_call("expr2");
		try
		{
			Tree l, r;
			l = expr1();
			label_20:
			while (true)
			{
				switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk)
				{
					case 89:
					case 90:
					{
						break;
					}
					default:
						jj_la1[46] = jj_gen;
						break label_20;
				}
				switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk)
				{
					case 89:
					{
						jj_consume_token(89);
						r = expr1();
						l = F.at(l.pos).Binary(Tree.PLUS, l, r);
						break;
					}
					case 90:
					{
						jj_consume_token(90);
						r = expr1();
						l = F.at(l.pos).Binary(Tree.MINUS, l, r);
						break;
					}
					default:
						jj_la1[47] = jj_gen;
						jj_consume_token(-1);
						throw new ParseException();
				}
			}
			return l;
		}
		finally
		{
			trace_return("expr2");
		}
	}

	/**
	 * Parses multiplex or division or modular subExpr.
	 */
	final public Tree expr1() throws ParseException
	{
		trace_call("expr1");
		try
		{
			Tree l, r;
			l = term();
			label_21:
			while (true)
			{
				switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk)
				{
					case 91:
					case 92:
					case 93:
					{
						break;
					}
					default:
						jj_la1[48] = jj_gen;
						break label_21;
				}
				switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk)
				{
					case 91:
					{
						jj_consume_token(91);
						r = term();
						l = F.at(l.pos).Binary(Tree.MUL, l, r);
						break;
					}
					case 92:
					{
						jj_consume_token(92);
						r = term();
						l = F.at(l.pos).Binary(Tree.DIV, l, r);
						break;
					}
					case 93:
					{
						jj_consume_token(93);
						r = term();
						l = F.at(l.pos).Binary(Tree.MOD, l, r);
						break;
					}
					default:
						jj_la1[49] = jj_gen;
						jj_consume_token(-1);
						throw new ParseException();
				}
			}
			return l;
		}
		finally
		{
			trace_return("expr1");
		}
	}

	/**
	 * Parses frontend.type cast or unary subExpr
	 */
	final public Tree term() throws ParseException
	{
		trace_call("term");
		try
		{
			Tree type;
			Tree n;
			if (jj_2_10(2147483647))
			{
				jj_consume_token(54);
				type = type();
				jj_consume_token(59);
				n = term();
				return F.at(type.pos).TypeCast(type, n);
			}
			else
			{
				switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk)
				{
					case TRUE_:
					case FALSE_:
					case IDENTIFIER:
					case INTEGER:
					case CHARACTER:
					case 54:
					case 63:
					case 64:
					case 89:
					case 90:
					case 94:
					case 95:
					{
						n = unary();
						return n;
					}
					default:
						jj_la1[50] = jj_gen;
						jj_consume_token(-1);
						throw new ParseException();
				}
			}
		}
		finally
		{
			trace_return("term");
		}
	}

	/**
	 * Currently, there are bool, char, byte, short, int, long, float, double
	 * supported as primitive frontend.type rather than no aggregate or class.
	 */
	final public void primitiveType() throws ParseException
	{
		trace_call("primitiveType");
		try
		{
			switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk)
			{
				case BOOL:
				{
					jj_consume_token(BOOL);
					break;
				}
				case CHAR:
				{
					jj_consume_token(CHAR);
					break;
				}
				case BYTE:
				{
					jj_consume_token(BYTE);
					break;
				}
				case SHORT:
				{
					jj_consume_token(SHORT);
					break;
				}
				case INT:
				{
					jj_consume_token(INT);
					break;
				}
				case LONG:
				{
					jj_consume_token(LONG);
					break;
				}
				case FLOAT:
				{
					jj_consume_token(FLOAT);
					break;
				}
				case DOUBLE:
				{
					jj_consume_token(DOUBLE);
					break;
				}
				default:
					jj_la1[51] = jj_gen;
					jj_consume_token(-1);
					throw new ParseException();
			}
		}
		finally
		{
			trace_return("primitiveType");
		}
	}

	/**
	 * Parses unary operation expression.
	 */
	final public Tree unary() throws ParseException
	{
		trace_call("unary");
		try
		{
			Tree tree;
			int pos;
			switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk)
			{
				case 63:
				{
					t = jj_consume_token(63);
					pos = position();
					tree = unary();
					return F.at(pos).Unary(Tree.PREINC, tree);
				}
				case 64:
				{
					t = jj_consume_token(64);
					pos = position();
					tree = unary();
					return F.at(pos).Unary(Tree.PREDEC, tree);
				}
				case 89:
				{
					jj_consume_token(89);
					tree = term();
					return tree;
				}
				case 90:
				{
					t = jj_consume_token(90);
					pos = position();
					tree = term();
					return F.at(pos).Unary(Tree.NEG, tree);
				}
				case 94:
				{
					t = jj_consume_token(94);
					pos = position();
					tree = term();
					return F.at(pos).Unary(Tree.NOT, tree);
				}
				case 95:
				{
					t = jj_consume_token(95);
					pos = position();
					tree = term();
					return F.at(pos).Unary(Tree.COMPL, tree);
				}
				case TRUE_:
				case FALSE_:
				case IDENTIFIER:
				case INTEGER:
				case CHARACTER:
				case 54:
				{
					tree = postfix();
					return tree;
				}
				default:
					jj_la1[52] = jj_gen;
					jj_consume_token(-1);
					throw new ParseException();
			}
		}
		finally
		{
			trace_return("unary");
		}
	}

	/**
	 * Parses unary operation with postfix.
	 */
	final public Tree postfix() throws ParseException
	{
		trace_call("postfix");
		try
		{
			Tree expr, idx;
			List<Tree> args;
			expr = primary();
			label_22:
			while (true)
			{
				switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk)
				{
					case 54:
					case 60:
					case 63:
					case 64:
					{
						break;
					}
					default:
						jj_la1[53] = jj_gen;
						break label_22;
				}
				switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk)
				{
					case 63:
					{
						jj_consume_token(63);
						expr = F.at(expr.pos).Unary(Tree.POSTINC, expr);
						break;
					}
					case 64:
					{
						jj_consume_token(64);
						expr = F.at(expr.pos).Unary(Tree.POSTDEC, expr);
						break;
					}
					case 60:
					{
						jj_consume_token(60);
						idx = expr();
						jj_consume_token(61);
						expr = F.at(expr.pos).Indexed(expr, idx);
						break;
					}
					case 54:
					{
						jj_consume_token(54);
						args = args();
						jj_consume_token(59);
						expr = F.at(expr.pos).Apply(expr, args);
						break;
					}
					default:
						jj_la1[54] = jj_gen;
						jj_consume_token(-1);
						throw new ParseException();
				}
			}
			return expr;
		}
		finally
		{
			trace_return("postfix");
		}
	}

	/**
	 * Parses all of arguments of the calling to function.
	 */
	final public List<Tree> args() throws ParseException
	{
		trace_call("args");
		try
		{
			List<Tree> args = new ArrayList<Tree>();
			Tree arg;
			switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk)
			{
				case TRUE_:
				case FALSE_:
				case IDENTIFIER:
				case INTEGER:
				case CHARACTER:
				case 54:
				case 63:
				case 64:
				case 89:
				case 90:
				case 94:
				case 95:
				{
					arg = expr();
					args.add(arg);
					label_23:
					while (true)
					{
						switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk)
						{
							case 56:
							{
								break;
							}
							default:
								jj_la1[55] = jj_gen;
								break label_23;
						}
						jj_consume_token(56);
						arg = expr();
						args.add(arg);
					}
					break;
				}
				default:
					jj_la1[56] = jj_gen;
			}
			return args;
		}
		finally
		{
			trace_return("args");
		}
	}

	/**
	 * Parses literal with primitive, like number literal, character literal etc.
	 */
	final public Tree primary() throws ParseException
	{
		trace_call("primary");
		try
		{
			Tree n;
			int pos;
			switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk)
			{
				case INTEGER:
				{
					// encounters a integer literal
					t = jj_consume_token(INTEGER);
					pos = position();
					try
					{
						return integerNode(pos, t.image);
					}
					catch (NumberFormatException ex)
					{
						log.error(pos, "int.number.too.large", t.image);
					}
					break;
				}
				case CHARACTER:
				{
					t = jj_consume_token(CHARACTER);
					pos = position();
					{

						return F.at(pos).Literal(Type.Char,
								new Integer(t.image.charAt(0)));
					}

				}
				case IDENTIFIER:
				{
					t = jj_consume_token(IDENTIFIER);
					pos = position();
					return F.at(pos).Ident(Name.fromString(names, t.image));
				}
				case TRUE_:
				{
					t = jj_consume_token(TRUE_);
					pos = position();
					return F.at(pos).Ident(Name.fromString(names, "true"));
				}
				case FALSE_:
				{
					t = jj_consume_token(FALSE_);
					pos = position();
					return F.at(pos).Ident(Name.fromString(names, "false"));
				}
				case 54:
				{
					jj_consume_token(54);
					n = expr();
					jj_consume_token(59);

					return n;
				}
				default:
					jj_la1[57] = jj_gen;
					jj_consume_token(-1);
					throw new ParseException();
			}
			throw new Error("Missing return statement in function");
		}
		finally
		{
			trace_return("primary");
		}
	}

	private boolean jj_2_1(int xla)
	{
		jj_la = xla;
		jj_lastpos = jj_scanpos = token;
		try { return !jj_3_1(); }
		catch (LookaheadSuccess ls) { return true; }
		finally { jj_save(0, xla); }
	}

	private boolean jj_2_2(int xla)
	{
		jj_la = xla;
		jj_lastpos = jj_scanpos = token;
		try { return !jj_3_2(); }
		catch (LookaheadSuccess ls) { return true; }
		finally { jj_save(1, xla); }
	}

	private boolean jj_2_3(int xla)
	{
		jj_la = xla;
		jj_lastpos = jj_scanpos = token;
		try { return !jj_3_3(); }
		catch (LookaheadSuccess ls) { return true; }
		finally { jj_save(2, xla); }
	}

	private boolean jj_2_4(int xla)
	{
		jj_la = xla;
		jj_lastpos = jj_scanpos = token;
		try { return !jj_3_4(); }
		catch (LookaheadSuccess ls) { return true; }
		finally { jj_save(3, xla); }
	}

	private boolean jj_2_5(int xla)
	{
		jj_la = xla;
		jj_lastpos = jj_scanpos = token;
		try { return !jj_3_5(); }
		catch (LookaheadSuccess ls) { return true; }
		finally { jj_save(4, xla); }
	}

	private boolean jj_2_6(int xla)
	{
		jj_la = xla;
		jj_lastpos = jj_scanpos = token;
		try { return !jj_3_6(); }
		catch (LookaheadSuccess ls) { return true; }
		finally { jj_save(5, xla); }
	}

	private boolean jj_2_7(int xla)
	{
		jj_la = xla;
		jj_lastpos = jj_scanpos = token;
		try { return !jj_3_7(); }
		catch (LookaheadSuccess ls) { return true; }
		finally { jj_save(6, xla); }
	}

	private boolean jj_2_8(int xla)
	{
		jj_la = xla;
		jj_lastpos = jj_scanpos = token;
		try { return !jj_3_8(); }
		catch (LookaheadSuccess ls) { return true; }
		finally { jj_save(7, xla); }
	}

	private boolean jj_2_9(int xla)
	{
		jj_la = xla;
		jj_lastpos = jj_scanpos = token;
		try { return !jj_3_9(); }
		catch (LookaheadSuccess ls) { return true; }
		finally { jj_save(8, xla); }
	}

	private boolean jj_2_10(int xla)
	{
		jj_la = xla;
		jj_lastpos = jj_scanpos = token;
		try { return !jj_3_10(); }
		catch (LookaheadSuccess ls) { return true; }
		finally { jj_save(9, xla); }
	}

	private boolean jj_3R_45()
	{
		return jj_scan_token(69);
	}

	private boolean jj_3R_44()
	{
		return jj_scan_token(68);
	}

	private boolean jj_3R_43()
	{
		return jj_scan_token(67);
	}

	private boolean jj_3R_42()
	{
		return jj_scan_token(66);
	}

	private boolean jj_3R_41()
	{
		return jj_scan_token(65);
	}

	private boolean jj_3_2()
	{
		return jj_scan_token(57);
	}

	private boolean jj_3R_29()
	{
		Token xsp;
		xsp = jj_scanpos;
		if (jj_3R_41())
		{
			jj_scanpos = xsp;
			if (jj_3R_42())
			{
				jj_scanpos = xsp;
				if (jj_3R_43())
				{
					jj_scanpos = xsp;
					if (jj_3R_44())
					{
						jj_scanpos = xsp;
						if (jj_3R_45())
						{
							jj_scanpos = xsp;
							if (jj_3R_46())
							{
								jj_scanpos = xsp;
								if (jj_3R_47())
								{
									jj_scanpos = xsp;
									if (jj_3R_48())
									{
										jj_scanpos = xsp;
										if (jj_3R_49())
										{
											jj_scanpos = xsp;
											if (jj_3R_50())
												return true;
										}
									}
								}
							}
						}
					}
				}
			}
		}
		return false;
	}

	private boolean jj_3R_32()
	{
		if (jj_scan_token(60))
			return true;
		return jj_scan_token(61);
	}

	private boolean jj_3R_34()
	{
		return jj_3R_27();
	}

	private boolean jj_3R_24()
	{
		if (jj_3R_31())
			return true;
		Token xsp;
		while (true)
		{
			xsp = jj_scanpos;
			if (jj_3R_32())
			{
				jj_scanpos = xsp;
				break;
			}
		}
		return false;
	}

	private boolean jj_3_10()
	{
		if (jj_scan_token(54))
			return true;
		return jj_3R_30();
	}

	private boolean jj_3_7()
	{
		if (jj_3R_24())
			return true;
		return jj_scan_token(IDENTIFIER);
	}

	private boolean jj_3R_30()
	{
		Token xsp;
		xsp = jj_scanpos;
		if (jj_scan_token(14))
		{
			jj_scanpos = xsp;
			if (jj_scan_token(8))
			{
				jj_scanpos = xsp;
				if (jj_scan_token(7))
				{
					jj_scanpos = xsp;
					if (jj_scan_token(9))
					{
						jj_scanpos = xsp;
						if (jj_scan_token(10))
						{
							jj_scanpos = xsp;
							if (jj_scan_token(11))
							{
								jj_scanpos = xsp;
								if (jj_scan_token(12))
								{
									jj_scanpos = xsp;
									if (jj_scan_token(13))
										return true;
								}
							}
						}
					}
				}
			}
		}
		return false;
	}

	private boolean jj_3_9()
	{
		if (jj_3R_28())
			return true;
		return jj_3R_29();
	}

	private boolean jj_3_4()
	{
		if (jj_3R_24())
			return true;
		return jj_scan_token(IDENTIFIER);
	}

	private boolean jj_3R_33()
	{
		return jj_scan_token(57);
	}

	private boolean jj_3R_25()
	{
		Token xsp;
		xsp = jj_scanpos;
		if (jj_3R_33())
		{
			jj_scanpos = xsp;
			if (jj_3R_34())
				return true;
		}
		return false;
	}

	private boolean jj_3R_38()
	{
		return jj_3R_57();
	}

	private boolean jj_3R_40()
	{
		return jj_3R_58();
	}

	private boolean jj_3_8()
	{
		if (jj_3R_28())
			return true;
		return jj_scan_token(55);
	}

	private boolean jj_3R_39()
	{
		if (jj_scan_token(54))
			return true;
		if (jj_3R_24())
			return true;
		if (jj_scan_token(59))
			return true;
		return jj_3R_28();
	}

	private boolean jj_3R_28()
	{
		Token xsp;
		xsp = jj_scanpos;
		if (jj_3R_39())
		{
			jj_scanpos = xsp;
			if (jj_3R_40())
				return true;
		}
		return false;
	}

	private boolean jj_3R_37()
	{
		if (jj_3R_28())
			return true;
		if (jj_3R_29())
			return true;
		return jj_3R_27();
	}

	private boolean jj_3R_113()
	{
		if (jj_scan_token(93))
			return true;
		return jj_3R_28();
	}

	private boolean jj_3R_36()
	{
		if (jj_3R_28())
			return true;
		if (jj_scan_token(55))
			return true;
		return jj_3R_27();
	}

	private boolean jj_3R_27()
	{
		Token xsp;
		xsp = jj_scanpos;
		if (jj_3R_36())
		{
			jj_scanpos = xsp;
			if (jj_3R_37())
			{
				jj_scanpos = xsp;
				if (jj_3R_38())
					return true;
			}
		}
		return false;
	}

	private boolean jj_3R_112()
	{
		if (jj_scan_token(92))
			return true;
		return jj_3R_28();
	}

	private boolean jj_3R_111()
	{
		if (jj_scan_token(91))
			return true;
		return jj_3R_28();
	}

	private boolean jj_3R_108()
	{
		Token xsp;
		xsp = jj_scanpos;
		if (jj_3R_111())
		{
			jj_scanpos = xsp;
			if (jj_3R_112())
			{
				jj_scanpos = xsp;
				if (jj_3R_113())
					return true;
			}
		}
		return false;
	}

	private boolean jj_3R_104()
	{
		if (jj_3R_28())
			return true;
		Token xsp;
		while (true)
		{
			xsp = jj_scanpos;
			if (jj_3R_108())
			{
				jj_scanpos = xsp;
				break;
			}
		}
		return false;
	}

	private boolean jj_3R_110()
	{
		if (jj_scan_token(90))
			return true;
		return jj_3R_104();
	}

	private boolean jj_3R_109()
	{
		if (jj_scan_token(89))
			return true;
		return jj_3R_104();
	}

	private boolean jj_3R_105()
	{
		Token xsp;
		xsp = jj_scanpos;
		if (jj_3R_109())
		{
			jj_scanpos = xsp;
			if (jj_3R_110())
				return true;
		}
		return false;
	}

	private boolean jj_3R_102()
	{
		if (jj_3R_104())
			return true;
		Token xsp;
		while (true)
		{
			xsp = jj_scanpos;
			if (jj_3R_105())
			{
				jj_scanpos = xsp;
				break;
			}
		}
		return false;
	}

	private boolean jj_3R_107()
	{
		if (jj_scan_token(88))
			return true;
		return jj_3R_102();
	}

	private boolean jj_3R_106()
	{
		if (jj_scan_token(87))
			return true;
		return jj_3R_102();
	}

	private boolean jj_3R_103()
	{
		Token xsp;
		xsp = jj_scanpos;
		if (jj_3R_106())
		{
			jj_scanpos = xsp;
			if (jj_3R_107())
				return true;
		}
		return false;
	}

	private boolean jj_3R_99()
	{
		if (jj_3R_102())
			return true;
		Token xsp;
		while (true)
		{
			xsp = jj_scanpos;
			if (jj_3R_103())
			{
				jj_scanpos = xsp;
				break;
			}
		}
		return false;
	}

	private boolean jj_3R_100()
	{
		if (jj_scan_token(86))
			return true;
		return jj_3R_99();
	}

	private boolean jj_3R_82()
	{
		if (jj_scan_token(54))
			return true;
		if (jj_3R_27())
			return true;
		return jj_scan_token(59);
	}

	private boolean jj_3R_81()
	{
		return jj_scan_token(FALSE_);
	}

	private boolean jj_3R_80()
	{
		return jj_scan_token(TRUE_);
	}

	private boolean jj_3R_96()
	{
		if (jj_3R_99())
			return true;
		Token xsp;
		while (true)
		{
			xsp = jj_scanpos;
			if (jj_3R_100())
			{
				jj_scanpos = xsp;
				break;
			}
		}
		return false;
	}

	private boolean jj_3R_97()
	{
		if (jj_scan_token(85))
			return true;
		return jj_3R_96();
	}

	private boolean jj_3R_79()
	{
		return jj_scan_token(IDENTIFIER);
	}

	private boolean jj_3_1()
	{
		Token xsp;
		xsp = jj_scanpos;
		if (jj_scan_token(18))
			jj_scanpos = xsp;
		if (jj_3R_24())
			return true;
		if (jj_scan_token(IDENTIFIER))
			return true;
		return jj_scan_token(54);
	}

	private boolean jj_3R_78()
	{
		return jj_scan_token(CHARACTER);
	}

	private boolean jj_3R_87()
	{
		if (jj_3R_96())
			return true;
		Token xsp;
		while (true)
		{
			xsp = jj_scanpos;
			if (jj_3R_97())
			{
				jj_scanpos = xsp;
				break;
			}
		}
		return false;
	}

	private boolean jj_3R_88()
	{
		if (jj_scan_token(84))
			return true;
		return jj_3R_87();
	}

	private boolean jj_3R_73()
	{
		Token xsp;
		xsp = jj_scanpos;
		if (jj_3R_77())
		{
			jj_scanpos = xsp;
			if (jj_3R_78())
			{
				jj_scanpos = xsp;
				if (jj_3R_79())
				{
					jj_scanpos = xsp;
					if (jj_3R_80())
					{
						jj_scanpos = xsp;
						if (jj_3R_81())
						{
							jj_scanpos = xsp;
							if (jj_3R_82())
								return true;
						}
					}
				}
			}
		}
		return false;
	}

	private boolean jj_3R_77()
	{
		return jj_scan_token(INTEGER);
	}

	private boolean jj_3R_94()
	{
		if (jj_scan_token(83))
			return true;
		return jj_3R_75();
	}

	private boolean jj_3R_75()
	{
		if (jj_3R_87())
			return true;
		Token xsp;
		while (true)
		{
			xsp = jj_scanpos;
			if (jj_3R_88())
			{
				jj_scanpos = xsp;
				break;
			}
		}
		return false;
	}

	private boolean jj_3R_93()
	{
		if (jj_scan_token(82))
			return true;
		return jj_3R_75();
	}

	private boolean jj_3R_92()
	{
		if (jj_scan_token(81))
			return true;
		return jj_3R_75();
	}

	private boolean jj_3R_91()
	{
		if (jj_scan_token(80))
			return true;
		return jj_3R_75();
	}

	private boolean jj_3R_89()
	{
		if (jj_scan_token(78))
			return true;
		return jj_3R_75();
	}

	private boolean jj_3R_76()
	{
		Token xsp;
		xsp = jj_scanpos;
		if (jj_3R_89())
		{
			jj_scanpos = xsp;
			if (jj_3R_90())
			{
				jj_scanpos = xsp;
				if (jj_3R_91())
				{
					jj_scanpos = xsp;
					if (jj_3R_92())
					{
						jj_scanpos = xsp;
						if (jj_3R_93())
						{
							jj_scanpos = xsp;
							if (jj_3R_94())
								return true;
						}
					}
				}
			}
		}
		return false;
	}

	private boolean jj_3R_90()
	{
		if (jj_scan_token(79))
			return true;
		return jj_3R_75();
	}

	private boolean jj_3R_26()
	{
		if (jj_3R_35())
			return true;
		return jj_scan_token(62);
	}

	private boolean jj_3R_101()
	{
		if (jj_scan_token(56))
			return true;
		return jj_3R_27();
	}

	private boolean jj_3R_98()
	{
		if (jj_3R_27())
			return true;
		Token xsp;
		while (true)
		{
			xsp = jj_scanpos;
			if (jj_3R_101())
			{
				jj_scanpos = xsp;
				break;
			}
		}
		return false;
	}

	private boolean jj_3R_95()
	{
		Token xsp;
		xsp = jj_scanpos;
		if (jj_3R_98())
			jj_scanpos = xsp;
		return false;
	}

	private boolean jj_3R_71()
	{
		if (jj_3R_75())
			return true;
		Token xsp;
		while (true)
		{
			xsp = jj_scanpos;
			if (jj_3R_76())
			{
				jj_scanpos = xsp;
				break;
			}
		}
		return false;
	}

	private boolean jj_3R_86()
	{
		if (jj_scan_token(54))
			return true;
		if (jj_3R_95())
			return true;
		return jj_scan_token(59);
	}

	private boolean jj_3R_85()
	{
		if (jj_scan_token(60))
			return true;
		if (jj_3R_27())
			return true;
		return jj_scan_token(61);
	}

	private boolean jj_3R_84()
	{
		return jj_scan_token(64);
	}

	private boolean jj_3R_72()
	{
		if (jj_scan_token(77))
			return true;
		return jj_3R_71();
	}

	private boolean jj_3R_74()
	{
		Token xsp;
		xsp = jj_scanpos;
		if (jj_3R_83())
		{
			jj_scanpos = xsp;
			if (jj_3R_84())
			{
				jj_scanpos = xsp;
				if (jj_3R_85())
				{
					jj_scanpos = xsp;
					if (jj_3R_86())
						return true;
				}
			}
		}
		return false;
	}

	private boolean jj_3R_83()
	{
		return jj_scan_token(63);
	}

	private boolean jj_3R_68()
	{
		if (jj_3R_71())
			return true;
		Token xsp;
		while (true)
		{
			xsp = jj_scanpos;
			if (jj_3R_72())
			{
				jj_scanpos = xsp;
				break;
			}
		}
		return false;
	}

	private boolean jj_3_6()
	{
		if (jj_3R_27())
			return true;
		return jj_scan_token(53);
	}

	private boolean jj_3R_70()
	{
		if (jj_3R_73())
			return true;
		Token xsp;
		while (true)
		{
			xsp = jj_scanpos;
			if (jj_3R_74())
			{
				jj_scanpos = xsp;
				break;
			}
		}
		return false;
	}

	private boolean jj_3_5()
	{
		return jj_3R_26();
	}

	private boolean jj_3R_35()
	{
		return jj_scan_token(IDENTIFIER);
	}

	private boolean jj_3R_67()
	{
		return jj_3R_70();
	}

	private boolean jj_3R_69()
	{
		if (jj_scan_token(76))
			return true;
		return jj_3R_68();
	}

	private boolean jj_3R_66()
	{
		if (jj_scan_token(95))
			return true;
		return jj_3R_28();
	}

	private boolean jj_3R_59()
	{
		if (jj_3R_68())
			return true;
		Token xsp;
		while (true)
		{
			xsp = jj_scanpos;
			if (jj_3R_69())
			{
				jj_scanpos = xsp;
				break;
			}
		}
		return false;
	}

	private boolean jj_3R_65()
	{
		if (jj_scan_token(94))
			return true;
		return jj_3R_28();
	}

	private boolean jj_3R_64()
	{
		if (jj_scan_token(90))
			return true;
		return jj_3R_28();
	}

	private boolean jj_3R_63()
	{
		if (jj_scan_token(89))
			return true;
		return jj_3R_28();
	}

	private boolean jj_3R_56()
	{
		return jj_scan_token(BOOL);
	}

	private boolean jj_3R_62()
	{
		if (jj_scan_token(64))
			return true;
		return jj_3R_58();
	}

	private boolean jj_3R_60()
	{
		if (jj_scan_token(75))
			return true;
		if (jj_3R_27())
			return true;
		if (jj_scan_token(62))
			return true;
		return jj_3R_27();
	}

	private boolean jj_3R_58()
	{
		Token xsp;
		xsp = jj_scanpos;
		if (jj_3R_61())
		{
			jj_scanpos = xsp;
			if (jj_3R_62())
			{
				jj_scanpos = xsp;
				if (jj_3R_63())
				{
					jj_scanpos = xsp;
					if (jj_3R_64())
					{
						jj_scanpos = xsp;
						if (jj_3R_65())
						{
							jj_scanpos = xsp;
							if (jj_3R_66())
							{
								jj_scanpos = xsp;
								if (jj_3R_67())
									return true;
							}
						}
					}
				}
			}
		}
		return false;
	}

	private boolean jj_3R_61()
	{
		if (jj_scan_token(63))
			return true;
		return jj_3R_58();
	}

	private boolean jj_3R_55()
	{
		return jj_scan_token(LONG);
	}

	private boolean jj_3R_54()
	{
		return jj_scan_token(INT);
	}

	private boolean jj_3R_57()
	{
		if (jj_3R_59())
			return true;
		Token xsp;
		xsp = jj_scanpos;
		if (jj_3R_60())
			jj_scanpos = xsp;
		return false;
	}

	private boolean jj_3R_53()
	{
		return jj_scan_token(SHORT);
	}

	private boolean jj_3_3()
	{
		if (jj_scan_token(56))
			return true;
		return jj_3R_25();
	}

	private boolean jj_3R_52()
	{
		return jj_scan_token(CHAR);
	}

	private boolean jj_3R_31()
	{
		Token xsp;
		xsp = jj_scanpos;
		if (jj_3R_51())
		{
			jj_scanpos = xsp;
			if (jj_3R_52())
			{
				jj_scanpos = xsp;
				if (jj_3R_53())
				{
					jj_scanpos = xsp;
					if (jj_3R_54())
					{
						jj_scanpos = xsp;
						if (jj_3R_55())
						{
							jj_scanpos = xsp;
							if (jj_3R_56())
								return true;
						}
					}
				}
			}
		}
		return false;
	}

	private boolean jj_3R_51()
	{
		return jj_scan_token(VOID);
	}

	private boolean jj_3R_50()
	{
		return jj_scan_token(74);
	}

	private boolean jj_3R_49()
	{
		return jj_scan_token(73);
	}

	private boolean jj_3R_48()
	{
		return jj_scan_token(72);
	}

	private boolean jj_3R_47()
	{
		return jj_scan_token(71);
	}

	private boolean jj_3R_46()
	{
		return jj_scan_token(70);
	}

	/**
	 * Generated Token Manager.
	 */
	public ParserTokenManager token_source;
	SimpleCharStream jj_input_stream;
	/**
	 * Current token.
	 */
	public Token token;
	/**
	 * Next token.
	 */
	public Token jj_nt;
	private int jj_ntk;
	private Token jj_scanpos, jj_lastpos;
	private int jj_la;
	private int jj_gen;
	final private int[] jj_la1 = new int[58];
	static private int[] jj_la1_0;
	static private int[] jj_la1_1;
	static private int[] jj_la1_2;

	static
	{
		jj_la1_init_0();
		jj_la1_init_1();
		jj_la1_init_2();
	}

	private static void jj_la1_init_0()
	{
		jj_la1_0 = new int[] { 0x0, 0x0, 0x144f40, 0x144f40, 0x140000, 0x140000,
				0x0, 0x0, 0x0, 0xc00000, 0x0, 0x0, 0x40000, 0x0, 0x4f40,
				0xcad44f40, 0xcac00000, 0x0, 0x4f40, 0x0, 0xcac00000, 0x4000000,
				0xd44f40, 0xc00000, 0xc00000, 0xc00000, 0x0, 0x0, 0x0, 0xc00000,
				0x10000000, 0x10000000, 0x20000000, 0xc00000, 0xc00000, 0x0,
				0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
				0x0, 0xc00000, 0x7f80, 0xc00000, 0x0, 0x0, 0x0, 0xc00000,
				0xc00000, };
	}

	private static void jj_la1_init_1()
	{
		jj_la1_1 = new int[] { 0x40, 0x100000, 0x0, 0x0, 0x0, 0x0, 0x800000,
				0x1000000, 0x800000, 0x80404300, 0x7000000, 0x2200000, 0x0,
				0x1000000, 0x0, 0x8260431f, 0x8260431f, 0x10000000, 0x0,
				0x200000, 0x8240431f, 0x0, 0x80404300, 0x80404300, 0x80404300,
				0x80404300, 0x1000000, 0x80800000, 0x80800000, 0x80404300, 0x0,
				0x0, 0x0, 0x80404302, 0x80404300, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
				0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x80404300, 0x0,
				0x80404300, 0x90400000, 0x90400000, 0x1000000, 0x80404300,
				0x404300, };
	}

	private static void jj_la1_init_2()
	{
		jj_la1_2 = new int[] { 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
				0xc6000001, 0x0, 0x0, 0x0, 0x0, 0x0, 0xc6000001, 0xc6000001,
				0x0, 0x0, 0x0, 0xc6000001, 0x0, 0x1, 0xc6000001, 0x1, 0x1, 0x0,
				0x7ff, 0x7ff, 0x1, 0x0, 0x0, 0x0, 0xc6000001, 0xc6000001, 0x7fe,
				0x800, 0x1000, 0x2000, 0xfc000, 0xfc000, 0x100000, 0x200000,
				0x400000, 0x1800000, 0x1800000, 0x6000000, 0x6000000,
				0x38000000, 0x38000000, 0xc6000001, 0x0, 0xc6000001, 0x1, 0x1,
				0x0, 0xc6000001, 0x0, };
	}

	final private JJCalls[] jj_2_rtns = new JJCalls[10];
	private boolean jj_rescan = false;
	private int jj_gc = 0;

	/**
	 * Constructor with InputStream.
	 */
	public Parser(java.io.InputStream stream)
	{
		this(stream, null);
	}

	/**
	 * Constructor with InputStream and supplied encoding
	 */
	public Parser(java.io.InputStream stream, String encoding)
	{
		try
		{
			jj_input_stream = new SimpleCharStream(stream, encoding, 1, 1);
		}
		catch (java.io.UnsupportedEncodingException e)
		{
			throw new RuntimeException(e);
		}
		token_source = new ParserTokenManager(jj_input_stream);
		token = new Token();
		jj_ntk = -1;
		jj_gen = 0;
		for (int i = 0; i < 58; i++)
			jj_la1[i] = -1;
		for (int i = 0; i < jj_2_rtns.length; i++)
			jj_2_rtns[i] = new JJCalls();
	}

	/**
	 * Reinitialise.
	 */
	public void ReInit(java.io.InputStream stream)
	{
		ReInit(stream, null);
	}

	/**
	 * Reinitialise.
	 */
	public void ReInit(java.io.InputStream stream, String encoding)
	{
		try
		{
			jj_input_stream.ReInit(stream, encoding, 1, 1);
		}
		catch (java.io.UnsupportedEncodingException e)
		{
			throw new RuntimeException(e);
		}
		token_source.ReInit(jj_input_stream);
		token = new Token();
		jj_ntk = -1;
		jj_gen = 0;
		for (int i = 0; i < 58; i++)
			jj_la1[i] = -1;
		for (int i = 0; i < jj_2_rtns.length; i++)
			jj_2_rtns[i] = new JJCalls();
	}

	/**
	 * Constructor.
	 */
	public Parser(java.io.Reader stream)
	{
		jj_input_stream = new SimpleCharStream(stream, 1, 1);
		token_source = new ParserTokenManager(jj_input_stream);
		token = new Token();
		jj_ntk = -1;
		jj_gen = 0;
		for (int i = 0; i < 58; i++)
			jj_la1[i] = -1;
		for (int i = 0; i < jj_2_rtns.length; i++)
			jj_2_rtns[i] = new JJCalls();
	}

	/**
	 * Reinitialise.
	 */
	public void ReInit(java.io.Reader stream)
	{
		jj_input_stream.ReInit(stream, 1, 1);
		token_source.ReInit(jj_input_stream);
		token = new Token();
		jj_ntk = -1;
		jj_gen = 0;
		for (int i = 0; i < 58; i++)
			jj_la1[i] = -1;
		for (int i = 0; i < jj_2_rtns.length; i++)
			jj_2_rtns[i] = new JJCalls();
	}

	/**
	 * Constructor with generated Token Manager.
	 */
	public Parser(ParserTokenManager tm)
	{
		token_source = tm;
		token = new Token();
		jj_ntk = -1;
		jj_gen = 0;
		for (int i = 0; i < 58; i++)
			jj_la1[i] = -1;
		for (int i = 0; i < jj_2_rtns.length; i++)
			jj_2_rtns[i] = new JJCalls();
	}

	/**
	 * Reinitialise.
	 */
	public void ReInit(ParserTokenManager tm)
	{
		token_source = tm;
		token = new Token();
		jj_ntk = -1;
		jj_gen = 0;
		for (int i = 0; i < 58; i++)
			jj_la1[i] = -1;
		for (int i = 0; i < jj_2_rtns.length; i++)
			jj_2_rtns[i] = new JJCalls();
	}

	private Token jj_consume_token(int kind) throws ParseException
	{
		Token oldToken;
		if ((oldToken = token).next != null)
			token = token.next;
		else
			token = token.next = token_source.getNextToken();
		jj_ntk = -1;
		if (token.kind == kind)
		{
			jj_gen++;
			if (++jj_gc > 100)
			{
				jj_gc = 0;
				for (int i = 0; i < jj_2_rtns.length; i++)
				{
					JJCalls c = jj_2_rtns[i];
					while (c != null)
					{
						if (c.gen < jj_gen)
							c.first = null;
						c = c.next;
					}
				}
			}
			trace_token(token, "");
			return token;
		}
		token = oldToken;
		jj_kind = kind;
		throw generateParseException();
	}

	@SuppressWarnings("serial") static private final class LookaheadSuccess
			extends java.lang.Error
	{
	}

	final private LookaheadSuccess jj_ls = new LookaheadSuccess();

	private boolean jj_scan_token(int kind)
	{
		if (jj_scanpos == jj_lastpos)
		{
			jj_la--;
			if (jj_scanpos.next == null)
			{
				jj_lastpos = jj_scanpos = jj_scanpos.next = token_source
						.getNextToken();
			}
			else
			{
				jj_lastpos = jj_scanpos = jj_scanpos.next;
			}
		}
		else
		{
			jj_scanpos = jj_scanpos.next;
		}
		if (jj_rescan)
		{
			int i = 0;
			Token tok = token;
			while (tok != null && tok != jj_scanpos)
			{
				i++;
				tok = tok.next;
			}
			if (tok != null)
				jj_add_error_token(kind, i);
		}
		if (jj_scanpos.kind != kind)
			return true;
		if (jj_la == 0 && jj_scanpos == jj_lastpos)
			throw jj_ls;
		return false;
	}

	/**
	 * Get the next Token.
	 */
	final public Token getNextToken()
	{
		if (token.next != null)
			token = token.next;
		else
			token = token.next = token_source.getNextToken();
		jj_ntk = -1;
		jj_gen++;
		trace_token(token, " (in getNextToken)");
		return token;
	}

	/**
	 * Get the specific Token.
	 */
	final public Token getToken(int index)
	{
		Token t = token;
		for (int i = 0; i < index; i++)
		{
			if (t.next != null)
				t = t.next;
			else
				t = t.next = token_source.getNextToken();
		}
		return t;
	}

	private int jj_ntk_f()
	{
		if ((jj_nt = token.next) == null)
			return (jj_ntk = (token.next = token_source.getNextToken()).kind);
		else
			return (jj_ntk = jj_nt.kind);
	}

	private java.util.List<int[]> jj_expentries = new java.util.ArrayList<int[]>();
	private int[] jj_expentry;
	private int jj_kind = -1;
	private int[] jj_lasttokens = new int[100];
	private int jj_endpos;

	private void jj_add_error_token(int kind, int pos)
	{
		if (pos >= 100)
			return;
		if (pos == jj_endpos + 1)
		{
			jj_lasttokens[jj_endpos++] = kind;
		}
		else if (jj_endpos != 0)
		{
			jj_expentry = new int[jj_endpos];
			for (int i = 0; i < jj_endpos; i++)
			{
				jj_expentry[i] = jj_lasttokens[i];
			}
			jj_entries_loop:
			for (java.util.Iterator<?> it = jj_expentries.iterator(); it
					.hasNext(); )
			{
				int[] oldentry = (int[]) (it.next());
				if (oldentry.length == jj_expentry.length)
				{
					for (int i = 0; i < jj_expentry.length; i++)
					{
						if (oldentry[i] != jj_expentry[i])
						{
							continue jj_entries_loop;
						}
					}
					jj_expentries.add(jj_expentry);
					break jj_entries_loop;
				}
			}
			if (pos != 0)
				jj_lasttokens[(jj_endpos = pos) - 1] = kind;
		}
	}

	/**
	 * Generate ParseException.
	 */
	public ParseException generateParseException()
	{
		jj_expentries.clear();
		boolean[] la1tokens = new boolean[96];
		if (jj_kind >= 0)
		{
			la1tokens[jj_kind] = true;
			jj_kind = -1;
		}
		for (int i = 0; i < 58; i++)
		{
			if (jj_la1[i] == jj_gen)
			{
				for (int j = 0; j < 32; j++)
				{
					if ((jj_la1_0[i] & (1 << j)) != 0)
					{
						la1tokens[j] = true;
					}
					if ((jj_la1_1[i] & (1 << j)) != 0)
					{
						la1tokens[32 + j] = true;
					}
					if ((jj_la1_2[i] & (1 << j)) != 0)
					{
						la1tokens[64 + j] = true;
					}
				}
			}
		}
		for (int i = 0; i < 96; i++)
		{
			if (la1tokens[i])
			{
				jj_expentry = new int[1];
				jj_expentry[0] = i;
				jj_expentries.add(jj_expentry);
			}
		}
		jj_endpos = 0;
		jj_rescan_token();
		jj_add_error_token(0, 0);
		int[][] exptokseq = new int[jj_expentries.size()][];
		for (int i = 0; i < jj_expentries.size(); i++)
		{
			exptokseq[i] = jj_expentries.get(i);
		}
		return new ParseException(token, exptokseq, tokenImage);
	}

	private int trace_indent = 0;
	private boolean trace_enabled = true;

	/**
	 * Enable tracing.
	 */
	final public void enable_tracing()
	{
		trace_enabled = true;
	}

	/**
	 * Disable tracing.
	 */
	final public void disable_tracing()
	{
		trace_enabled = false;
	}

	private void trace_call(String s)
	{
		if (trace_enabled)
		{
			for (int i = 0; i < trace_indent; i++) { System.out.print(" "); }
			System.out.println("Call:   " + s);
		}
		trace_indent = trace_indent + 2;
	}

	private void trace_return(String s)
	{
		trace_indent = trace_indent - 2;
		if (trace_enabled)
		{
			for (int i = 0; i < trace_indent; i++) { System.out.print(" "); }
			System.out.println("ReturnInst: " + s);
		}
	}

	private void trace_token(Token t, String where)
	{
		if (trace_enabled)
		{
			for (int i = 0; i < trace_indent; i++) { System.out.print(" "); }
			System.out.print("Consumed token: <" + tokenImage[t.kind]);
			if (t.kind != 0 && !tokenImage[t.kind]
					.equals("\"" + t.image + "\""))
			{
				System.out.print(": \"" + t.image + "\"");
			}
			System.out.println(
					" at line " + t.beginLine + " column " + t.beginColumn + ">"
							+ where);
		}
	}

	private void trace_scan(Token t1, int t2)
	{
		if (trace_enabled)
		{
			for (int i = 0; i < trace_indent; i++) { System.out.print(" "); }
			System.out.print("Visited token: <" + tokenImage[t1.kind]);
			if (t1.kind != 0 && !tokenImage[t1.kind]
					.equals("\"" + t1.image + "\""))
			{
				System.out.print(": \"" + t1.image + "\"");
			}
			System.out.println(
					" at line " + t1.beginLine + " column " + t1.beginColumn
							+ ">; Expected token: <" + tokenImage[t2] + ">");
		}
	}

	private void jj_rescan_token()
	{
		jj_rescan = true;
		for (int i = 0; i < 10; i++)
		{
			try
			{
				JJCalls p = jj_2_rtns[i];
				do
				{
					if (p.gen > jj_gen)
					{
						jj_la = p.arg;
						jj_lastpos = jj_scanpos = p.first;
						switch (i)
						{
							case 0:
								jj_3_1();
								break;
							case 1:
								jj_3_2();
								break;
							case 2:
								jj_3_3();
								break;
							case 3:
								jj_3_4();
								break;
							case 4:
								jj_3_5();
								break;
							case 5:
								jj_3_6();
								break;
							case 6:
								jj_3_7();
								break;
							case 7:
								jj_3_8();
								break;
							case 8:
								jj_3_9();
								break;
							case 9:
								jj_3_10();
								break;
						}
					}
					p = p.next;
				} while (p != null);
			}
			catch (LookaheadSuccess ls) { }
		}
		jj_rescan = false;
	}

	private void jj_save(int index, int xla)
	{
		JJCalls p = jj_2_rtns[index];
		while (p.gen > jj_gen)
		{
			if (p.next == null)
			{
				p = p.next = new JJCalls();
				break;
			}
			p = p.next;
		}
		p.gen = jj_gen + xla - jj_la;
		p.first = token;
		p.arg = xla;
	}

	static final class JJCalls
	{
		int gen;
		Token first;
		int arg;
		JJCalls next;
	}

}

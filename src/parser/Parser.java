/* Generated By:JavaCC: Do not edit this line. Parser.java */
package parser;

import ast.*;
import ast.Tree.*;
import type.*;
import utils.*;

import java.util.*;
import java.io.*;

/**
 * The parser that parses the cflat source file. It maps a token sequence into
 * an abstract syntax tree witch operates by LR grammar.
 * 
 * @version 1.0
 */
public class Parser implements ParserConstants {

	/**
	 * The factory to be used for abstract syntax tree construction.
	 */
	private TreeMaker F;

	/**
	 * 默认的字符编码标准
	 */
	static final public String SOURCE_ENCODING = "UTF-8";

	/**
	 * The name table.
	 */
	private Name.Table names;

	private Log log;

	/**
	 * The current token.
	 */
	private Token t;
	
	private static final Context.Key parserKey = new Context.Key();
	
	/**
	 * Constructs a parser.
	 * 
	 * @param input	the input stream
	 * @param debug		whether debug  or not 
	 * @param context	A context object
	 */
	public Parser(InputStream input, boolean debug, Context context) {
		this(input, SOURCE_ENCODING);
		context.put(parserKey, this);
		this.F = TreeMaker.instance(context);
		this.log = Log.instance(context);
		this.names = Name.Table.instance(context);
		if (debug) {
			enable_tracing();
		} else {
			disable_tracing();
		}
	}

	/**
	 * Constructor with file name.
	 * @throws FileNotFoundException 
	 * @throws UnsupportedEncodingException 
	 */
	public Parser(String filename, boolean debug, Context context) 
			throws UnsupportedEncodingException, FileNotFoundException 
	{
		this(new FileInputStream(filename), debug, context);
	}

	/**
	 * Constructs a Integer literal node.
	 */
	private Literal integerNode(int pos, String image) {
		long i = integerValue(image);
		if (image.endsWith("L")) {
			return F.at(pos).Literal(Type.LONG, new Long(i));
		} else {
			return F.at(pos).Literal(Type.LONG, new Integer((int) i));
		}
	}

	/**
	 * A auxiliary method for extracting a integer or long value.
	 */
	private long integerValue(String image) {
		String s = image.replaceFirst("[UL]+", "");
		if (s.startsWith("0x") || s.startsWith("0X")) {
			return Long.parseLong(s.substring(2), 16);
		} else if (s.startsWith("0") && !s.equals("0")) {
			return Long.parseLong(s.substring(1), 8);
		} else {
			return Long.parseLong(s, 10);
		}
	}

	/**
	 * A auxiliary method for extracting a string value.
	 */
	private String stringValue(String _image) throws ParseException {
		int pos = 0;
		int idx;
		StringBuffer buf = new StringBuffer();
		String image = _image.substring(1, _image.length() - 1);

		while ((idx = image.indexOf("\u005c\u005c", pos)) >= 0) {
			buf.append(image.substring(pos, idx));
			if (image.length() >= idx + 4
					&& Character.isDigit(image.charAt(idx + 1))
					&& Character.isDigit(image.charAt(idx + 2))
					&& Character.isDigit(image.charAt(idx + 3))) {
				buf.append(unescapeOctal(image.substring(idx + 1, idx + 4)));
				pos = idx + 4;
			} else {
				buf.append(unescapeSeq(image.charAt(idx + 1)));
				pos = idx + 2;
			}
		}
		if (pos < image.length()) {
			buf.append(image.substring(pos, image.length()));
		}
		return buf.toString();
	}

	private static final int charMax = 255;

	private char unescapeOctal(String digits) throws ParseException {
		int i = Integer.parseInt(digits, 8);
		if (i > charMax) {
			throw new ParseException(
					"octal character sequence too big: \u005c\u005c" + digits);
		}
		return (char) i;
	}

	private static final char bell = 7;
	private static final char backspace = 8;
	private static final char escape = 27;
	private static final char vt = 11;

	private char unescapeSeq(char c) throws ParseException {
		switch (c) {
		case '0':
			return '\u005c0';
		case '"':
			return '"';
		case '\u005c'':
			return '\u005c'';
		case 'a':
			return bell;
		case 'b':
			return backspace;
		case 'e':
			return escape;
		case 'f':
			return '\u005cf';
		case 'n':
			return '\u005cn';
		case 'r':
			return '\u005cr';
		case 't':
			return '\u005ct';
		case 'v':
			return vt;
		default:
			throw new ParseException(
					"unknown escape sequence: \u005c"\u005c\u005c" + c);
		}
	}

	/**
	 * Gets the current position of current token.
	 */
	private int position() {
		// get the current token
		Token current = getToken(0);
		return Position.make(current.beginLine, current.beginColumn);
	}

	final public Tree.TopLevel compilationUnit() throws ParseException {
		trace_call("compilationUnit");
		try {
			List<Tree> importdecls, typedecls;
			t = getToken(1);
			importdecls = importDeclarations();
			typedecls = top_defs();
			jj_consume_token(0);
			importdecls.addAll(typedecls);
			int pos = position();
			{
				if (true)
					return F.at(pos).TopLevel(importdecls);
			}
			throw new Error("Missing return statement in function");
		} finally {
			trace_return("compilationUnit");
		}
	}

	/**
	 * 处理import语句序列，并返回一棵根节点为Declarations的抽象语法树。 该语句的BNF范式如下：
	 * importDeclarations:: import_stmt; importDeclarations
	 *
	 * @return
	 */
	final public List<Tree> importDeclarations() throws ParseException {
		trace_call("importDeclarations");
		try {
			List<Tree> imports = new ArrayList<Tree>();
			Tree impt;
			label_1: while (true) {
				switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
				case IMPORT:
					;
					break;
				default:
					jj_la1[0] = jj_gen;
					break label_1;
				}
				impt = import_statement();
				imports.add(impt);
			}
			{
				if (true)
					return imports;
			}
			throw new Error("Missing return statement in function");
		} finally {
			trace_return("importDeclarations");
		}
	}

	/**
	 * 处理单个import语句，并返回一个表示import语句的字符串。 该语句的BNF范式如下： import_statement::= IMPORT
	 * name SEMICOLON | IMPORT name DOT MULT SEMICOLON
	 *
	 * name ::= simple_name | qualified_name ; simple_name ::= IDENTIFIER ;
	 * qualified_name ::= name DOT IDENTIFIER ;
	 * 
	 * @return 一棵根节点为Declarations的抽象语法树。
	 */
	final public Tree import_statement() throws ParseException {
		trace_call("import_statement");
		try {
			Tree pid;
			Name n;
			int pos;
			jj_consume_token(IMPORT);
			n = name();
			pos = position();
			pid = F.at(pos).Ident(n);
			label_2: while (true) {
				switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
				case 52:
					;
					break;
				default:
					jj_la1[1] = jj_gen;
					break label_2;
				}
				jj_consume_token(52);
				n = name();
				pos = position();
				pid = F.at(pos).Select(pid, n);
			}
			jj_consume_token(53);
			{
				if (true)
					return F.at(pos).Import(pid);
			}
			throw new Error("Missing return statement in function");
		} finally {
			trace_return("import_statement");
		}
	}

	/**
	 * Gets a Name instance from a token.
	 */
	final public Name name() throws ParseException {
		trace_call("name");
		try {
			t = jj_consume_token(IDENTIFIER);
			{
				if (true)
					return Name.fromString(names, t.image);
			}
			throw new Error("Missing return statement in function");
		} finally {
			trace_return("name");
		}
	}

	/**
	 * 顶层的变量或函数声明语句序列。 type_declarations_opt ::= type_declarations | ;
	 * type_declarations ::= type_declaration | type_declarations
	 * type_declaration
	 *
	 * type_declaration ::= Function_declaration | variable_declaration
	 * (包括结构体和普通变量声明，以及类型重定义typedef) | SEMICOLON
	 *
	 * @return Declarations 一棵根节点为Declarations的抽象语法树。
	 */
	final public List<Tree> top_defs() throws ParseException {
		trace_call("top_defs");
		try {
			List<Tree> res;
			List<Tree> decls = new ArrayList<Tree>();
			label_3: while (true) {
				switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
				case VOID:
				case CHAR:
				case SHORT:
				case INT:
				case LONG:
				case BOOL:
				case STATIC:
				case CONST:
					;
					break;
				default:
					jj_la1[2] = jj_gen;
					break label_3;
				}
				res = declaration();
				decls.addAll(res);
			}
			{
				if (true)
					return decls;
			}
			throw new Error("Missing return statement in function");
		} finally {
			trace_return("top_defs");
		}
	}

	final public List<Tree> declaration() throws ParseException {
		trace_call("declaration");
		try {
			/**
			 * the definition of various of variables.
			 */
			Tree methodDef;
			List<Tree> defvars;

			List<Tree> defs = new ArrayList<Tree>();
			if (jj_2_1(2147483647)) {
				methodDef = methodDeclaration();
				defs.add(methodDef);
			} else {
				switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
				case VOID:
				case CHAR:
				case SHORT:
				case INT:
				case LONG:
				case BOOL:
				case STATIC:
				case CONST:
					defvars = variableDefinitions();
					defs.addAll(defvars);
					{
						if (true)
							return defs;
					}
					break;
				default:
					jj_la1[3] = jj_gen;
					jj_consume_token(-1);
					throw new ParseException();
				}
			}
			throw new Error("Missing return statement in function");
		} finally {
			trace_return("declaration");
		}
	}

	/**
	 * 变量定义语句序列。 variable_def ::= storage_class_qualifier type_specifier ID |
	 * storage_class_qualifier type_specifier ID = variable_initializer
	 * rariable_initializer ::= expression
	 *
	 * @return
	 */
	final public List<Tree> variableDefinitions() throws ParseException {
		trace_call("variableDefinitions");
		try {
			// a list at which a large amounts of various of definition
			// storages.
			List<Tree> defs = new ArrayList<Tree>();
			long flags = 0;
			long flag = 0;
			Tree type;
			Name name;
			Tree init = null;
			int pos = 0;
			label_4: while (true) {
				switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
				case STATIC:
				case CONST:
					;
					break;
				default:
					jj_la1[4] = jj_gen;
					break label_4;
				}
				switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
				case STATIC:
					t = jj_consume_token(STATIC);
					if ((flags & Flags.STATIC) != 0) {
						if (true)
							throw generateParseException();
					} else
						flags |= Flags.STATIC;
					break;
				case CONST:
					t = jj_consume_token(CONST);
					if ((flags & Flags.CONST) != 0) {
						if (true)
							throw generateParseException();
					} else
						flags |= Flags.CONST;
					break;
				default:
					jj_la1[5] = jj_gen;
					jj_consume_token(-1);
					throw new ParseException();
				}
			}
			if (flags != 0)
				pos = position();
			type = type();
			if (flags == 0)
				pos = position();
			name = name();
			switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
			case 55:
				jj_consume_token(55);
				init = expression();
				break;
			default:
				jj_la1[6] = jj_gen;
				;
			}
			VarDef result = F.at(pos).VarDef(flags, name, type, init);
			defs.add(result);
			init = null;
			label_5: while (true) {
				switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
				case 56:
					;
					break;
				default:
					jj_la1[7] = jj_gen;
					break label_5;
				}
				jj_consume_token(56);
				name = name();
				switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
				case 55:
					jj_consume_token(55);
					init = expression();
					break;
				default:
					jj_la1[8] = jj_gen;
					;
				}

				defs.add(F.at(pos).VarDef(flags, name, type, init));
				init = null;
			}
			jj_consume_token(53);
			{
				if (true)
					return defs;
			}
			throw new Error("Missing return statement in function");
		} finally {
			trace_return("variableDefinitions");
		}
	}

	final public Tree variableInit() throws ParseException {
		trace_call("variableInit");
		try {
			Tree expr;
			if (jj_2_2(2147483647)) {
				jj_consume_token(57);
				{
					if (true)
						return arrayInit(null);
				}
			} else {
				switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
				case TRUE_:
				case FALSE_:
				case IDENTIFIER:
				case INTEGER:
				case CHARACTER:
				case STRING:
				case 54:
				case 63:
				case 64:
				case 89:
				case 90:
				case 94:
				case 95:
					expr = expression();
					{
						if (true)
							return expr;
					}
					break;
				default:
					jj_la1[9] = jj_gen;
					jj_consume_token(-1);
					throw new ParseException();
				}
			}
			throw new Error("Missing return statement in function");
		} finally {
			trace_return("variableInit");
		}
	}

	/**
	 * ArrayInitializer = "{" [VariableInit {"," VariableInit}] [","] "}"
	 */
	final public Tree arrayInit(Tree type) throws ParseException {
		trace_call("arrayInit");
		try {
			List<Tree> elems = new ArrayList<Tree>();
			Tree res;
			int pos = 0;
			switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
			case 57:
				// first, accept a left brace
				t = jj_consume_token(57);
				pos = position();
				// second, parse the optional variable initializer for array.
				// "," "}" { return F.at(pos).NewArray(t, Tree.emptyList,
				// elems); }

				res = variableInit();
				elems.add(res);
				label_6: while (true) {
					if (jj_2_3(2)) {
						;
					} else {
						break label_6;
					}
					jj_consume_token(56);
					res = variableInit();
					elems.add(res);
				}
				break;
			case 56:
				jj_consume_token(56);
				jj_consume_token(58);
				{
					if (true)
						return F.at(pos).NewArray(type, Tree.emptyList, elems);
				}
				break;
			case 58:
				jj_consume_token(58);
				{
					if (true)
						return F.at(pos).NewArray(type, Tree.emptyList, elems);
				}
				jj_consume_token(58);
				{
					if (true)
						return F.at(pos).NewArray(type, Tree.emptyList, elems);
				}
				break;
			default:
				jj_la1[10] = jj_gen;
				jj_consume_token(-1);
				throw new ParseException();
			}
			throw new Error("Missing return statement in function");
		} finally {
			trace_return("arrayInit");
		}
	}

	/**
	 * A handler to function definition.
	 * 
	 * function_def ::= storage_class_qualifier Type Name "(" param_lists_opt
	 * ")" block param_lists_opt ::= | param_lists
	 * 
	 * param_lists ::= variable_declaration | variable_declaration ","
	 * param_list
	 * 
	 * @return A root of AST which represents a MethodDef syntax structure.
	 */
	final public Tree methodDeclaration() throws ParseException {
		trace_call("methodDeclaration");
		try {
			long flags = 0;
			Tree rettype;
			Name methodName;
			List<Tree> params;
			Tree body = null;
			int pos = 0;
			flags = storage();
			if (flags != 0)
				pos = position();
			rettype = type();
			if (flags == 0)
				pos = rettype.pos;
			methodName = name();
			params = formalParameters();
			switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
			case 57:
				body = block();
				break;
			case 53:
				jj_consume_token(53);
				break;
			default:
				jj_la1[11] = jj_gen;
				jj_consume_token(-1);
				throw new ParseException();
			}
			{
				if (true)
			        return F.at(pos).MethodDef(flags, methodName, rettype, params, body);
			}
			throw new Error("Missing return statement in function");
		} finally {
			trace_return("methodDeclaration");
		}
	}

	/**
	 * A storage class qualifier.
	 */
	final public long storage() throws ParseException {
		trace_call("storage");
		try {
			long flags = 0;
			t = null;
			switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
			case STATIC:
				t = jj_consume_token(STATIC);
				break;
			default:
				jj_la1[12] = jj_gen;
				;
			}
			if (t != null) {
				if (true)
					return flags |= Flags.STATIC;
			} else {
				if (true)
					return flags;
			}
			throw new Error("Missing return statement in function");
		} finally {
			trace_return("storage");
		}
	}

	/**
	 * A method that parses parameters list at the function declaration.
	 * 
	 * @return A list of all of parameters.
	 */
	final public List<Tree> formalParameters() throws ParseException {
		trace_call("formalParameters");
		try {
			List<Tree> params = new ArrayList<Tree>();
			Tree singleParam;
			jj_consume_token(54);
			switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
			case VOID:
			case CHAR:
			case SHORT:
			case INT:
			case LONG:
			case BOOL:
				singleParam = formalParameter();
				params.add(singleParam);
				label_7: while (true) {
					switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
					case 56:
						;
						break;
					default:
						jj_la1[13] = jj_gen;
						break label_7;
					}
					jj_consume_token(56);
					singleParam = formalParameter();
					params.add(singleParam);
				}
				break;
			default:
				jj_la1[14] = jj_gen;
				;
			}
			jj_consume_token(59);
			{
				if (true)
					return params;
			}
			throw new Error("Missing return statement in function");
		} finally {
			trace_return("formalParameters");
		}
	}

	/**
	 * 解析函数形式参数列表中单个参数声明语句。
	 * 
	 * @return 返回一棵表示单个参数的抽象语法树。
	 */
	final public Tree formalParameter() throws ParseException {
		trace_call("formalParameter");
		try {
			Tree t;
			Name n;		
			t = type();
			n = name();
			{
				if (true)
					return F.at(t.pos).VarDef(Flags.PARAMETER, n, t, null);
			}
			throw new Error("Missing return statement in function");
		} finally {
			trace_return("formalParameter");
		}
	}

	/**
	 * 解析函数的函数体部分。 Block_stmt ::= varibale_defs stmts
	 * 
	 * @return 返回一个表示函数体的抽象语法树。
	 */
	final public Tree block() throws ParseException {
		trace_call("block");
		try {
			int pos;
			List<Tree> stats, res = new ArrayList<>();
			t = jj_consume_token(57);
			pos = position();
			label_8: while (true) {
				switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
				case VOID:
				case CHAR:
				case SHORT:
				case INT:
				case LONG:
				case BOOL:
				case STATIC:
				case CONST:
				case TRUE_:
				case FALSE_:
				case IF:
				case SWITCH:
				case WHILE:
				case DO:
				case FOR:
				case RETURN:
				case BREAK:
				case CONTINUE:
				case GOTO:
				case IDENTIFIER:
				case INTEGER:
				case CHARACTER:
				case STRING:
				case 53:
				case 54:
				case 57:
				case 63:
				case 64:
				case 89:
				case 90:
				case 94:
				case 95:
					;
					break;
				default:
					jj_la1[15] = jj_gen;
					break label_8;
				}
				stats = blockStatement();
				res.addAll(stats);
			}
			jj_consume_token(58);
			{
				if (true)
					return F.at(pos).Block(res);
			}
			throw new Error("Missing return statement in function");
		} finally {
			trace_return("block");
		}
	}

	/**
	 * Just for all statements in block statement.
	 */
	final public List<Tree> blockStatement() throws ParseException {
		trace_call("blockStatement");
		try {
			List<Tree> vars;
			List<Tree> res = new ArrayList<Tree>();
			Tree stmt;
			if (jj_2_4(2147483647)) {
				vars = variableDefinitions();
				jj_consume_token(53);
				res.addAll(vars);
			} else {
				switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
				case TRUE_:
				case FALSE_:
				case IF:
				case SWITCH:
				case WHILE:
				case DO:
				case FOR:
				case RETURN:
				case BREAK:
				case CONTINUE:
				case GOTO:
				case IDENTIFIER:
				case INTEGER:
				case CHARACTER:
				case STRING:
				case 53:
				case 54:
				case 57:
				case 63:
				case 64:
				case 89:
				case 90:
				case 94:
				case 95:
					stmt = statement();
					res.add(stmt);
					{
						if (true)
							return res;
					}
					break;
				default:
					jj_la1[16] = jj_gen;
					jj_consume_token(-1);
					throw new ParseException();
				}
			}
			throw new Error("Missing return statement in function");
		} finally {
			trace_return("blockStatement");
		}
	}

	/**
	 * A handler to type syntax construct.
	 */
	final public Tree type() throws ParseException {
		trace_call("type");
		try {
			Tree ref;
			// basic type reference, such as void, char, int, long and so on.
			ref = typeref_base();
			label_9: while (true) {
				switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
				case 60:
					;
					break;
				default:
					jj_la1[17] = jj_gen;
					break label_9;
				}
				jj_consume_token(60);
				jj_consume_token(61);
				// array type reference to no size
				ref = F.at(ref.pos).TypeArray(ref);
			}
			{
				if (true)
					return ref;
			}
			throw new Error("Missing return statement in function");
		} finally {
			trace_return("type");
		}
	}

	/**
	 * Parses the base type.
	 */
	final public Tree typeref_base() throws ParseException {
		trace_call("typeref_base");
		try {
			int pos;
			switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
			case VOID:
				t = jj_consume_token(VOID);
				pos = position();
				{
					if (true)
						return F.at(pos).TypeIdent(Type.VOID);
				}
				break;
			case CHAR:
				t = jj_consume_token(CHAR);
				pos = position();
				{
					if (true)
						return F.at(pos).TypeIdent(Type.CHAR);
				}
				break;
			case SHORT:
				t = jj_consume_token(SHORT);
				pos = position();
				{
					if (true)
						return F.at(pos).TypeIdent(Type.SHORT);
				}
				break;
			case INT:
				t = jj_consume_token(INT);
				pos = position();
				{
					if (true)
						return F.at(pos).TypeIdent(Type.INT);
				}
				break;
			case LONG:
				t = jj_consume_token(LONG);
				pos = position();
				{
					if (true)
						return F.at(pos).TypeIdent(Type.LONG);
				}
				break;
			case BOOL:
				t = jj_consume_token(BOOL);
				pos = position();
				{
					if (true)
						return F.at(pos).TypeIdent(Type.BOOL);
				}
				break;
			default:
				jj_la1[18] = jj_gen;
				jj_consume_token(-1);
				throw new ParseException();
			}
			throw new Error("Missing return statement in function");
		} finally {
			trace_return("typeref_base");
		}
	}

	/**
	 * Parses single statement. stmt ::= ; |labeled_stmt |expr SEMICOLON |block
	 * |if_stmt |while_stmt |dowhile_stmt |for_stmt |switch_stmt |break_stmt
	 * |continue_stmt |goto_stmt |return_stmt;
	 */
	final public Tree statement() throws ParseException {
		trace_call("statement");
		try {
			Tree tree = null, expr = null;
			switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
			case 53:
				jj_consume_token(53);
				break;
			default:
				jj_la1[19] = jj_gen;
				if (jj_2_5(2)) {
					tree = labeled_statement();
				} else if (jj_2_6(3)) {
					expr = expression();
					jj_consume_token(53);
					tree = F.at(expr.pos).Exec(expr);							
				} else {
					switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
					case 57:
						tree = block();
						break;
					case IF:
						tree = if_statement();
						break;
					case WHILE:
						tree = while_statement();
						break;
					case DO:
						tree = dowhile_statement();
						break;
					case FOR:
						tree = for_statement();
						break;
					case SWITCH:
						tree = switch_statement();
						break;
					case BREAK:
						tree = break_statement();
						break;
					case CONTINUE:
						tree = continue_statement();
						break;
					case GOTO:
						tree = goto_statement();
						break;
					case TRUE_:
					case FALSE_:
					case RETURN:
					case IDENTIFIER:
					case INTEGER:
					case CHARACTER:
					case STRING:
					case 54:
					case 63:
					case 64:
					case 89:
					case 90:
					case 94:
					case 95:
						tree = return_statement();
						break;
					default:
						jj_la1[20] = jj_gen;
						jj_consume_token(-1);
						throw new ParseException();
					}
				}
			}
			{
				if (true)
					return tree;
			}
			throw new Error("Missing return statement in function");
		} finally {
			trace_return("statement");
		}
	}

	/**
	 * Parses labeled statement.
	 */
	final public Tree labeled_statement() throws ParseException {
		trace_call("labeled_statement");
		try {
			Tree body;
			int pos;
			Name n;
			n = name();
			pos = position();
			jj_consume_token(62);
			body = statement();
			{
				if (true)
					return F.at(pos).Labelled(n, body);
			}
			throw new Error("Missing return statement in function");
		} finally {
			trace_return("labeled_statement");
		}
	}

	/**
	 * Parses if statement.
	 */
	final public Tree if_statement() throws ParseException {
		trace_call("if_statement");
		try {
			Tree cond, thenBody, elseBody = null;
			int pos;
			// this is a famous problem at c language that "dangling else".
			// It might be solved by lookahead one token.

			t = jj_consume_token(IF);
			pos = position();
			jj_consume_token(54);
			cond = expression();
			jj_consume_token(59);
			thenBody = statement();
			switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
			case ELSE:
				jj_consume_token(ELSE);
				elseBody = statement();
				break;
			default:
				jj_la1[21] = jj_gen;
				;
			}
			{
				if (true)
					return F.at(pos).If(cond, thenBody, elseBody);
			}
			throw new Error("Missing return statement in function");
		} finally {
			trace_return("if_statement");
		}
	}

	/**
	 * Parses while statement.
	 */
	final public Tree while_statement() throws ParseException {
		trace_call("while_statement");
		try {
			Tree cond, body;
			int pos;
			t = jj_consume_token(WHILE);
			pos = position();
			jj_consume_token(54);
			cond = expression();
			jj_consume_token(59);
			body = statement();
			{
				if (true)
					return F.at(pos).WhileLoop(cond, body);
			}
			throw new Error("Missing return statement in function");
		} finally {
			trace_return("while_statement");
		}
	}

	/**
	 * Parses do while statement.
	 */
	final public Tree dowhile_statement() throws ParseException {
		trace_call("dowhile_statement");
		try {
			Tree cond, body;
			int pos;
			t = jj_consume_token(DO);
			pos = position();
			body = statement();
			jj_consume_token(WHILE);
			jj_consume_token(54);
			cond = expression();
			jj_consume_token(59);
			jj_consume_token(53);
			{
				if (true)
					return F.at(pos).DoLoop(cond, body);
			}
			throw new Error("Missing return statement in function");
		} finally {
			trace_return("dowhile_statement");
		}
	}

	/**
	 * Parses for statement.
	 */
	final public Tree for_statement() throws ParseException {
		trace_call("for_statement");
		try {
			List<Tree> init = null, incr = null;
			Tree body, cond = null;
			int pos;
			t = jj_consume_token(FOR);
			pos = position();
			jj_consume_token(54);
			switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
			case 53:
				jj_consume_token(53);
				break;
			case VOID:
			case CHAR:
			case SHORT:
			case INT:
			case LONG:
			case BOOL:
			case STATIC:
			case CONST:
			case TRUE_:
			case FALSE_:
			case IDENTIFIER:
			case INTEGER:
			case CHARACTER:
			case STRING:
			case 54:
			case 63:
			case 64:
				init = forInit();
				jj_consume_token(53);
				break;
			default:
				jj_la1[22] = jj_gen;
				jj_consume_token(-1);
				throw new ParseException();
			}
			switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
			case TRUE_:
			case FALSE_:
			case IDENTIFIER:
			case INTEGER:
			case CHARACTER:
			case STRING:
			case 54:
			case 63:
			case 64:
			case 89:
			case 90:
			case 94:
			case 95:
				cond = expression();
				break;
			default:
				jj_la1[23] = jj_gen;
				;
			}
			jj_consume_token(53);
			switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
			case TRUE_:
			case FALSE_:
			case IDENTIFIER:
			case INTEGER:
			case CHARACTER:
			case STRING:
			case 54:
			case 63:
			case 64:
				incr = forUpdate();
				break;
			default:
				jj_la1[24] = jj_gen;
				;
			}
			jj_consume_token(59);
			body = statement();
			{
				if (true)
					return F.at(pos).ForLoop(init, cond, incr, body);
			}
			throw new Error("Missing return statement in function");
		} finally {
			trace_return("for_statement");
		}
	}

	final public List<Tree> forInit() throws ParseException {
		trace_call("forInit");
		try {
			List<Tree> res;
			if (jj_2_7(2147483647)) {
				res = variableDefinitions();
				{
					if (true)
						return res;
				}
			} else {
				switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
				case TRUE_:
				case FALSE_:
				case IDENTIFIER:
				case INTEGER:
				case CHARACTER:
				case STRING:
				case 54:
				case 63:
				case 64:
					res = statementExpressionList();
					{
						if (true)
							return res;
					}
					break;
				default:
					jj_la1[25] = jj_gen;
					jj_consume_token(-1);
					throw new ParseException();
				}
			}
			throw new Error("Missing return statement in function");
		} finally {
			trace_return("forInit");
		}
	}

	final public List<Tree> statementExpressionList() throws ParseException {
		trace_call("statementExpressionList");
		try {
			List<Tree> stats = new ArrayList<Tree>();
			Tree res;
			res = statementExpression();
			stats.add(res);
			label_10: while (true) {
				switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
				case 56:
					;
					break;
				default:
					jj_la1[26] = jj_gen;
					break label_10;
				}
				jj_consume_token(56);
				res = statementExpression();
				stats.add(res);
			}
			{
				if (true)
					return stats;
			}
			throw new Error("Missing return statement in function");
		} finally {
			trace_return("statementExpressionList");
		}
	}

	/**
	 * The last expansion of this production accepts more than the legal Java
	 * expansions for StatementExpression. This expansion does not use
	 * PostfixExpression for performance reasons.
	 */
	final public Tree statementExpression() throws ParseException {
		trace_call("statementExpression");
		try {
			Tree expr;
			int pos;
			Tree rhs;
			int op;
			switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
			case 63:
				t = jj_consume_token(63);
				pos = position();
				expr = unary();
				expr = F.at(pos).Unary(Tree.PREINC, expr);
				break;
			case 64:
				t = jj_consume_token(64);
				pos = position();
				expr = unary();
				expr = F.at(pos).Unary(Tree.PREDEC, expr);
				break;
			case TRUE_:
			case FALSE_:
			case IDENTIFIER:
			case INTEGER:
			case CHARACTER:
			case STRING:
			case 54:
				expr = primary();
				switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
				case 55:
				case 63:
				case 64:
				case 65:
				case 66:
				case 67:
				case 68:
				case 69:
				case 70:
				case 71:
				case 72:
				case 73:
				case 74:
					switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
					case 63:
						jj_consume_token(63);
						expr = F.at(expr.pos).Unary(Tree.POSTINC, expr);
						break;
					case 64:
						jj_consume_token(64);
						expr = F.at(expr.pos).Unary(Tree.POSTDEC, expr);
						break;
					case 55:
						jj_consume_token(55);
						rhs = expression();
						expr = F.at(expr.pos).Assign(expr, rhs);
						break;
					case 65:
					case 66:
					case 67:
					case 68:
					case 69:
					case 70:
					case 71:
					case 72:
					case 73:
					case 74:
						op = opassign_op();
						rhs = expression();
						expr = F.at(expr.pos).Assignop(op, expr, rhs);
						break;
					default:
						jj_la1[27] = jj_gen;
						jj_consume_token(-1);
						throw new ParseException();
					}
					break;
				default:
					jj_la1[28] = jj_gen;
					;
				}
				{
					if (true)
						return expr;
				}
				break;
			default:
				jj_la1[29] = jj_gen;
				jj_consume_token(-1);
				throw new ParseException();
			}
			throw new Error("Missing return statement in function");
		} finally {
			trace_return("statementExpression");
		}
	}

	final public List<Tree> forUpdate() throws ParseException {
		trace_call("forUpdate");
		try {
			List<Tree> list;
			list = statementExpressionList();
			{
				if (true)
					return list;
			}
			throw new Error("Missing return statement in function");
		} finally {
			trace_return("forUpdate");
		}
	}

	/**
	 * Parses switch statement.
	 */
	final public Tree switch_statement() throws ParseException {
		trace_call("switch_statement");
		try {
			int pos;
			Tree selector;
			List<Tree> cases;
			t = jj_consume_token(SWITCH);
			pos = position();
			jj_consume_token(54);
			selector = expression();
			jj_consume_token(59);
			jj_consume_token(57);
			cases = switchBlockStatementGroups();
			jj_consume_token(58);
			{
				if (true)
					return F.at(pos).Switch(selector, cases);
			}
			throw new Error("Missing return statement in function");
		} finally {
			trace_return("switch_statement");
		}
	}

	final public List<Tree> switchBlockStatementGroups() throws ParseException {
		trace_call("switchBlockStatementGroups");
		try {
			List<Tree> cases = new ArrayList<Tree>();
			Tree pat;
			List<Tree> stmts;
			int pos;
			label_11: while (true) {
				switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
				case CASE:
				case DEFAULT_:
					;
					break;
				default:
					jj_la1[30] = jj_gen;
					break label_11;
				}
				switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
				case CASE:
					t = jj_consume_token(CASE);
					pos = position();
					pat = expression();
					jj_consume_token(62);

					break;
				case DEFAULT_:
					t = jj_consume_token(DEFAULT_);
					pos = position();
					jj_consume_token(62);
					pat = null;
					break;
				default:
					jj_la1[31] = jj_gen;
					jj_consume_token(-1);
					throw new ParseException();
				}
				stmts = blockStatement();
				cases.add(F.at(pos).Case(pat, stmts));
			}
			{
				if (true)
					return cases;
			}
			throw new Error("Missing return statement in function");
		} finally {
			trace_return("switchBlockStatementGroups");
		}
	}

	/**
	 * Parses goto statement.
	 */
	final public Tree goto_statement() throws ParseException {
		trace_call("goto_statement");
		try {
			Name n;
			int pos;
			t = jj_consume_token(GOTO);
			pos = position();
			n = name();
			jj_consume_token(53);
			{
				if (true)
					return F.at(pos).Goto(n);
			}
			throw new Error("Missing return statement in function");
		} finally {
			trace_return("goto_statement");
		}
	}

	/**
	 * Parses break statement.
	 */
	final public Tree break_statement() throws ParseException {
		trace_call("break_statement");
		try {
			int pos;
			t = jj_consume_token(BREAK);
			pos = position();
			jj_consume_token(53);
			{
				if (true)
					return F.at(pos).Break();
			}
			throw new Error("Missing return statement in function");
		} finally {
			trace_return("break_statement");
		}
	}

	/**
	 * Parses continue statement.
	 */
	final public Tree continue_statement() throws ParseException {
		trace_call("continue_statement");
		try {
			int pos;
			t = jj_consume_token(CONTINUE);
			pos = position();
			jj_consume_token(53);
			{
				if (true)
					return F.at(pos).Continue();
			}
			throw new Error("Missing return statement in function");
		} finally {
			trace_return("continue_statement");
		}
	}

	/**
	 * Parses return statement.
	 */
	final public Tree return_statement() throws ParseException {
		trace_call("return_statement");
		try {
			Tree expr;
			int pos = 0;
			switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
			case RETURN:
				t = jj_consume_token(RETURN);
				pos = position();
				jj_consume_token(53);
				return F.at(pos).Return(null);
			case TRUE_:
			case FALSE_:
			case IDENTIFIER:
			case INTEGER:
			case CHARACTER:
			case STRING:
			case 54:
			case 63:
			case 64:
			case 89:
			case 90:
			case 94:
			case 95:
				expr = expression();
				jj_consume_token(53);
				return F.at(expr.pos).Return(expr);
			default:
				jj_la1[32] = jj_gen;
				jj_consume_token(-1);
				throw new ParseException();
			}
		} finally {
			trace_return("return_statement");
		}
	}

	/**
	 * Parses expression statement.
	 */
	final public Tree expression() throws ParseException {
		trace_call("expression");
		try {
			Tree lhs, rhs, expr;
			int op;
			if (jj_2_8(2147483647)) {
				lhs = term();
				jj_consume_token(55);
				rhs = expression();
				{
					if (true)
						return F.at(lhs.pos).Assign(lhs, rhs);
				}
			} else if (jj_2_9(2147483647)) {
				lhs = term();
				op = opassign_op();
				rhs = expression();
				{
					if (true)
						return F.at(lhs.pos).Assignop(op, lhs, rhs);
				}
			} else {
				switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
				case TRUE_:
				case FALSE_:
				case IDENTIFIER:
				case INTEGER:
				case CHARACTER:
				case STRING:
				case 54:
				case 63:
				case 64:
				case 89:
				case 90:
				case 94:
				case 95:
					expr = expr10();
					{
						if (true)
							return expr;
					}
					break;
				default:
					jj_la1[33] = jj_gen;
					jj_consume_token(-1);
					throw new ParseException();
				}
			}
			throw new Error("Missing return statement in function");
		} finally {
			trace_return("expression");
		}
	}

	/**
	 * Parses operation assignment statement.
	 * 
	 * such as +=, -= , *= and so on.
	 */
	final public int opassign_op() throws ParseException {
		trace_call("opassign_op");
		try {
			switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
			case 65:
				jj_consume_token(65);
				{
					if (true)
						return Tree.PLUS_ASG;
				}
				break;
			case 66:
				jj_consume_token(66);
				{
					if (true)
						return Tree.MINUS_ASG;
				}
				break;
			case 67:
				jj_consume_token(67);
				{
					if (true)
						return Tree.MUL_ASG;
				}
				break;
			case 68:
				jj_consume_token(68);
				{
					if (true)
						return Tree.DIV_ASG;
				}
				break;
			case 69:
				jj_consume_token(69);
				{
					if (true)
						return Tree.MOD_ASG;
				}
				break;
			case 70:
				jj_consume_token(70);
				{
					if (true)
						return Tree.BITAND_ASG;
				}
				break;
			case 71:
				jj_consume_token(71);
				{
					if (true)
						return Tree.BITOR_ASG;
				}
				break;
			case 72:
				jj_consume_token(72);
				{
					if (true)
						return Tree.BITXOR_ASG;
				}
				break;
			case 73:
				jj_consume_token(73);
				{
					if (true)
						return Tree.SL_ASG;
				}
				break;
			case 74:
				jj_consume_token(74);
				{
					if (true)
						return Tree.SR_ASG;
				}
				break;
			default:
				jj_la1[34] = jj_gen;
				jj_consume_token(-1);
				throw new ParseException();
			}
			throw new Error("Missing return statement in function");
		} finally {
			trace_return("opassign_op");
		}
	}

	/**
	 * Parses conditional expression.
	 */
	final public Tree expr10() throws ParseException {
		trace_call("expr10");
		try {
			Tree cond, truePart, elsePart;
			// other expr or ? : expr.
			cond = expr9();
			switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
			case 75:
				jj_consume_token(75);
				truePart = expression();
				jj_consume_token(62);
				elsePart = expression();
				{
					if (true)
						return F.at(cond.pos).Conditional(cond, truePart, elsePart);
				}
				break;
			default:
				jj_la1[35] = jj_gen;
				;
			}
			{
				if (true)
					return cond;
			}
			throw new Error("Missing return statement in function");
		} finally {
			trace_return("expr10");
		}
	}

	/**
	 * Logical or expression.
	 */
	final public Tree expr9() throws ParseException {
		trace_call("expr9");
		try {
			Tree l, r;
			l = expr8();
			label_12: while (true) {
				switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
				case 76:
					;
					break;
				default:
					jj_la1[36] = jj_gen;
					break label_12;
				}
				jj_consume_token(76);
				r = expr8();
				l = F.at(l.pos).Binary(Tree.OR, l, r);
			}
			{
				if (true)
					return l;
			}
			throw new Error("Missing return statement in function");
		} finally {
			trace_return("expr9");
		}
	}

	/**
	 * Logical and expression.
	 */
	final public Tree expr8() throws ParseException {
		trace_call("expr8");
		try {
			Tree l, r;
			l = expr7();
			label_13: while (true) {
				switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
				case 77:
					;
					break;
				default:
					jj_la1[37] = jj_gen;
					break label_13;
				}
				jj_consume_token(77);
				r = expr7();
				l = F.at(l.pos).Binary(Tree.AND, l, r);
			}
			{
				if (true)
					return l;
			}
			throw new Error("Missing return statement in function");
		} finally {
			trace_return("expr8");
		}
	}

	/**
	 * relational expression.
	 */
	final public Tree expr7() throws ParseException {
		trace_call("expr7");
		try {
			Tree l, r;
			l = expr6();
			label_14: while (true) {
				switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
				case 78:
				case 79:
				case 80:
				case 81:
				case 82:
				case 83:
					;
					break;
				default:
					jj_la1[38] = jj_gen;
					break label_14;
				}
				switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
				case 78:
					jj_consume_token(78);
					r = expr6();
					l = F.at(l.pos).Binary(Tree.GT, l, r);
					break;
				case 79:
					jj_consume_token(79);
					r = expr6();
					l = F.at(l.pos).Binary(Tree.LT, l, r);
					break;
				case 80:
					jj_consume_token(80);
					r = expr6();
					l = F.at(l.pos).Binary(Tree.GE, l, r);
					break;
				case 81:
					jj_consume_token(81);
					r = expr6();
					l = F.at(l.pos).Binary(Tree.LE, l, r);
					break;
				case 82:
					jj_consume_token(82);
					r = expr6();
					l = F.at(l.pos).Binary(Tree.EQ, l, r);
					break;
				case 83:
					jj_consume_token(83);
					r = expr6();
					l = F.at(l.pos).Binary(Tree.NE, l, r);
					break;
				default:
					jj_la1[39] = jj_gen;
					jj_consume_token(-1);
					throw new ParseException();
				}
			}
			{
				if (true)
					return l;
			}
			throw new Error("Missing return statement in function");
		} finally {
			trace_return("expr7");
		}
	}

	/**
	 * Parses bitwise or expression.
	 *
	 */
	final public Tree expr6() throws ParseException {
		trace_call("expr6");
		try {
			Tree l, r;
			l = expr5();
			label_15: while (true) {
				switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
				case 84:
					;
					break;
				default:
					jj_la1[40] = jj_gen;
					break label_15;
				}
				jj_consume_token(84);
				r = expr5();
				l = F.at(l.pos).Binary(Tree.BITOR, l, r);
			}
			{
				if (true)
					return l;
			}
			throw new Error("Missing return statement in function");
		} finally {
			trace_return("expr6");
		}
	}

	/**
	 * Parses bitwise exclusive or expression.
	 *
	 */
	final public Tree expr5() throws ParseException {
		trace_call("expr5");
		try {
			Tree l, r;
			l = expr4();
			label_16: while (true) {
				switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
				case 85:
					;
					break;
				default:
					jj_la1[41] = jj_gen;
					break label_16;
				}
				jj_consume_token(85);
				r = expr4();
				l = F.at(l.pos).Binary(Tree.BITXOR, l, r);
			}
			{
				if (true)
					return l;
			}
			throw new Error("Missing return statement in function");
		} finally {
			trace_return("expr5");
		}
	}

	/**
	 * Parses bitwise and expression.
	 *
	 */
	final public Tree expr4() throws ParseException {
		trace_call("expr4");
		try {
			Tree l, r;
			l = expr3();
			label_17: while (true) {
				switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
				case 86:
					;
					break;
				default:
					jj_la1[42] = jj_gen;
					break label_17;
				}
				jj_consume_token(86);
				r = expr3();
				l = F.at(l.pos).Binary(Tree.BITAND, l, r);
			}
			{
				if (true)
					return l;
			}
			throw new Error("Missing return statement in function");
		} finally {
			trace_return("expr4");
		}
	}

	/**
	 * Parses right or left shift expression.
	 *
	 */
	final public Tree expr3() throws ParseException {
		trace_call("expr3");
		try {
			Tree l, r;
			l = expr2();
			label_18: while (true) {
				switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
				case 87:
				case 88:
					;
					break;
				default:
					jj_la1[43] = jj_gen;
					break label_18;
				}
				switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
				case 87:
					jj_consume_token(87);
					r = expr2();
					l = F.at(l.pos).Binary(Tree.SL, l, r);
					break;
				case 88:
					jj_consume_token(88);
					r = expr2();
					l = F.at(l.pos).Binary(Tree.SR, l, r);
					break;
				default:
					jj_la1[44] = jj_gen;
					jj_consume_token(-1);
					throw new ParseException();
				}
			}
			{
				if (true)
					return l;
			}
			throw new Error("Missing return statement in function");
		} finally {
			trace_return("expr3");
		}
	}

	/**
	 * Parses plus or minus expression.
	 *
	 */
	final public Tree expr2() throws ParseException {
		trace_call("expr2");
		try {
			Tree l, r;
			l = expr1();
			label_19: while (true) {
				switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
				case 89:
				case 90:
					;
					break;
				default:
					jj_la1[45] = jj_gen;
					break label_19;
				}
				switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
				case 89:
					jj_consume_token(89);
					r = expr1();
					l = F.at(l.pos).Binary(Tree.PLUS, l, r);
					break;
				case 90:
					jj_consume_token(90);
					r = expr1();
					l = F.at(l.pos).Binary(Tree.MINUS, l, r);
					break;
				default:
					jj_la1[46] = jj_gen;
					jj_consume_token(-1);
					throw new ParseException();
				}
			}
			{
				if (true)
					return l;
			}
			throw new Error("Missing return statement in function");
		} finally {
			trace_return("expr2");
		}
	}

	/**
	 * Parses multiplex or division or modular expression.
	 */
	final public Tree expr1() throws ParseException {
		trace_call("expr1");
		try {
			Tree l, r;
			l = term();
			label_20: while (true) {
				switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
				case 91:
				case 92:
				case 93:
					;
					break;
				default:
					jj_la1[47] = jj_gen;
					break label_20;
				}
				switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
				case 91:
					jj_consume_token(91);
					r = term();
					l = F.at(l.pos).Binary(Tree.MUL, l, r);
					break;
				case 92:
					jj_consume_token(92);
					r = term();
					l = F.at(l.pos).Binary(Tree.DIV, l, r);
					break;
				case 93:
					jj_consume_token(93);
					r = term();
					l = F.at(l.pos).Binary(Tree.MOD, l, r);
					break;
				default:
					jj_la1[48] = jj_gen;
					jj_consume_token(-1);
					throw new ParseException();
				}
			}
			{
				if (true)
					return l;
			}
			throw new Error("Missing return statement in function");
		} finally {
			trace_return("expr1");
		}
	}

	/**
	 * Parses type cast or unary expression
	 *
	 */
	final public Tree term() throws ParseException {
		trace_call("term");
		try {
			Tree type;
			Tree n;
			if (jj_2_10(2147483647)) {
				jj_consume_token(54);
				type = type();
				jj_consume_token(59);
				n = term();
				{
					if (true)
						return F.at(type.pos).TypeCast(type, n);
				}
			} else {
				switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
				case TRUE_:
				case FALSE_:
				case IDENTIFIER:
				case INTEGER:
				case CHARACTER:
				case STRING:
				case 54:
				case 63:
				case 64:
				case 89:
				case 90:
				case 94:
				case 95:
					n = unary();
					{
						if (true)
							return n;
					}
					break;
				default:
					jj_la1[49] = jj_gen;
					jj_consume_token(-1);
					throw new ParseException();
				}
			}
			throw new Error("Missing return statement in function");
		} finally {
			trace_return("term");
		}
	}

	final public void primitiveType() throws ParseException {
		trace_call("primitiveType");
		try {
			switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
			case BOOL:
				jj_consume_token(BOOL);
				break;
			case CHAR:
				jj_consume_token(CHAR);
				break;
			case BYTE:
				jj_consume_token(BYTE);
				break;
			case SHORT:
				jj_consume_token(SHORT);
				break;
			case INT:
				jj_consume_token(INT);
				break;
			case LONG:
				jj_consume_token(LONG);
				break;
			case FLOAT:
				jj_consume_token(FLOAT);
				break;
			case DOUBLE:
				jj_consume_token(DOUBLE);
				break;
			default:
				jj_la1[50] = jj_gen;
				jj_consume_token(-1);
				throw new ParseException();
			}
		} finally {
			trace_return("primitiveType");
		}
	}

	/**
	 * Parses unary expression
	 */
	final public Tree unary() throws ParseException {
		trace_call("unary");
		try {
			Tree tree;
			int pos;
			switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
			case 63:
				t = jj_consume_token(63);
				pos = position();
				tree = unary();
				{
					if (true)
						return F.at(pos).Unary(Tree.PREINC, tree);
				}
				break;
			case 64:
				t = jj_consume_token(64);
				pos = position();
				tree = unary();
				{
					if (true)
						return F.at(pos).Unary(Tree.PREDEC, tree);
				}
				break;
			case 89:
				jj_consume_token(89);
				tree = term();
				{
					if (true)
						return tree;
				}
				break;
			case 90:
				t = jj_consume_token(90);
				pos = position();
				tree = term();
				{
					if (true)
						return F.at(pos).Unary(Tree.NEG, tree);
				}
				break;
			case 94:
				t = jj_consume_token(94);
				pos = position();
				tree = term();
				{
					if (true)
						return F.at(pos).Unary(Tree.NOT, tree);
				}
				break;
			case 95:
				t = jj_consume_token(95);
				pos = position();
				tree = term();
				{
					if (true)
						return F.at(pos).Unary(Tree.COMPL, tree);
				}
				break;
			case TRUE_:
			case FALSE_:
			case IDENTIFIER:
			case INTEGER:
			case CHARACTER:
			case STRING:
			case 54:
				tree = postfix();
				{
					if (true)
						return tree;
				}
				break;
			default:
				jj_la1[51] = jj_gen;
				jj_consume_token(-1);
				throw new ParseException();
			}
			throw new Error("Missing return statement in function");
		} finally {
			trace_return("unary");
		}
	}

	/**
	 * Parses unary postfix expression
	 *
	 */
	final public Tree postfix() throws ParseException {
		trace_call("postfix");
		try {
			Tree expr, idx;
			List<Tree> args;
			expr = primary();
			label_21: while (true) {
				switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
				case 54:
				case 60:
				case 63:
				case 64:
					;
					break;
				default:
					jj_la1[52] = jj_gen;
					break label_21;
				}
				switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
				case 63:
					jj_consume_token(63);
					expr = F.at(expr.pos).Unary(Tree.POSTINC, expr);
					break;
				case 64:
					jj_consume_token(64);
					expr = F.at(expr.pos).Unary(Tree.POSTDEC, expr);
					break;
				case 60:
					jj_consume_token(60);
					idx = expression();
					jj_consume_token(61);
					expr = F.at(expr.pos).Indexed(expr, idx);
					break;
				case 54:
					jj_consume_token(54);
					args = args();
					jj_consume_token(59);
					expr = F.at(expr.pos).Apply(expr, args);
					break;
				default:
					jj_la1[53] = jj_gen;
					jj_consume_token(-1);
					throw new ParseException();
				}
			}
			{
				if (true)
					return expr;
			}
			throw new Error("Missing return statement in function");
		} finally {
			trace_return("postfix");
		}
	}

	/**
	 * Parses all of arguments of the calling to function.
	 */
	final public List<Tree> args() throws ParseException {
		trace_call("args");
		try {
			List<Tree> args = new ArrayList<Tree>();
			Tree arg;
			switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
			case TRUE_:
			case FALSE_:
			case IDENTIFIER:
			case INTEGER:
			case CHARACTER:
			case STRING:
			case 54:
			case 63:
			case 64:
			case 89:
			case 90:
			case 94:
			case 95:
				arg = expression();
				args.add(arg);
				label_22: while (true) {
					switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
					case 56:
						;
						break;
					default:
						jj_la1[54] = jj_gen;
						break label_22;
					}
					jj_consume_token(56);
					arg = expression();
					args.add(arg);
				}
				break;
			default:
				jj_la1[55] = jj_gen;
				;
			}
			{
				if (true)
					return args;
			}
			throw new Error("Missing return statement in function");
		} finally {
			trace_return("args");
		}
	}

	/**
	 * Parses primary literal.
	 */
	final public Tree primary() throws ParseException {
		trace_call("primary");
		try {
			Tree n;
			int pos;
			switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
			case INTEGER:
				t = jj_consume_token(INTEGER);
				pos = position();
				try {
						return integerNode(pos, t.image);
				} catch (NumberFormatException ex) {
					log.error(pos, "int.number.too.large", t.image);
				}
				break;
			case CHARACTER:
				t = jj_consume_token(CHARACTER);
				pos = position();
				return F.at(pos).Literal(Type.CHAR, new Integer(t.image.charAt(0)));
				
			case STRING:
				t = jj_consume_token(STRING);
				pos = position();
				return F.at(pos).Literal(Type.STRING,
						stringValue(t.image));
				
			case IDENTIFIER:
				t = jj_consume_token(IDENTIFIER);
				pos = position();
				return F.at(pos).Ident(Name.fromString(names, t.image));
			case TRUE_:
				t = jj_consume_token(TRUE_);
				pos = position();
				return F.at(pos).Ident(Name.fromString(names, "true"));
			case FALSE_:
				t = jj_consume_token(FALSE_);
				pos = position();
				return F.at(pos).Ident(Name.fromString(names, "false"));
			case 54:
				jj_consume_token(54);
				n = expression();
				jj_consume_token(59);
				return n;
			default:
				jj_la1[56] = jj_gen;
				jj_consume_token(-1);
				throw new ParseException();
			}
			throw new Error("Missing return statement in function");
		} finally {
			trace_return("primary");
		}
	}

	private boolean jj_2_1(int xla) {
		jj_la = xla;
		jj_lastpos = jj_scanpos = token;
		try {
			return !jj_3_1();
		} catch (LookaheadSuccess ls) {
			return true;
		} finally {
			jj_save(0, xla);
		}
	}

	private boolean jj_2_2(int xla) {
		jj_la = xla;
		jj_lastpos = jj_scanpos = token;
		try {
			return !jj_3_2();
		} catch (LookaheadSuccess ls) {
			return true;
		} finally {
			jj_save(1, xla);
		}
	}

	private boolean jj_2_3(int xla) {
		jj_la = xla;
		jj_lastpos = jj_scanpos = token;
		try {
			return !jj_3_3();
		} catch (LookaheadSuccess ls) {
			return true;
		} finally {
			jj_save(2, xla);
		}
	}

	private boolean jj_2_4(int xla) {
		jj_la = xla;
		jj_lastpos = jj_scanpos = token;
		try {
			return !jj_3_4();
		} catch (LookaheadSuccess ls) {
			return true;
		} finally {
			jj_save(3, xla);
		}
	}

	private boolean jj_2_5(int xla) {
		jj_la = xla;
		jj_lastpos = jj_scanpos = token;
		try {
			return !jj_3_5();
		} catch (LookaheadSuccess ls) {
			return true;
		} finally {
			jj_save(4, xla);
		}
	}

	private boolean jj_2_6(int xla) {
		jj_la = xla;
		jj_lastpos = jj_scanpos = token;
		try {
			return !jj_3_6();
		} catch (LookaheadSuccess ls) {
			return true;
		} finally {
			jj_save(5, xla);
		}
	}

	private boolean jj_2_7(int xla) {
		jj_la = xla;
		jj_lastpos = jj_scanpos = token;
		try {
			return !jj_3_7();
		} catch (LookaheadSuccess ls) {
			return true;
		} finally {
			jj_save(6, xla);
		}
	}

	private boolean jj_2_8(int xla) {
		jj_la = xla;
		jj_lastpos = jj_scanpos = token;
		try {
			return !jj_3_8();
		} catch (LookaheadSuccess ls) {
			return true;
		} finally {
			jj_save(7, xla);
		}
	}

	private boolean jj_2_9(int xla) {
		jj_la = xla;
		jj_lastpos = jj_scanpos = token;
		try {
			return !jj_3_9();
		} catch (LookaheadSuccess ls) {
			return true;
		} finally {
			jj_save(8, xla);
		}
	}

	private boolean jj_2_10(int xla) {
		jj_la = xla;
		jj_lastpos = jj_scanpos = token;
		try {
			return !jj_3_10();
		} catch (LookaheadSuccess ls) {
			return true;
		} finally {
			jj_save(9, xla);
		}
	}

	private boolean jj_3R_54() {
		if (jj_scan_token(LONG))
			return true;
		return false;
	}

	private boolean jj_3R_57() {
		Token xsp;
		xsp = jj_scanpos;
		if (jj_3R_60()) {
			jj_scanpos = xsp;
			if (jj_3R_61()) {
				jj_scanpos = xsp;
				if (jj_3R_62()) {
					jj_scanpos = xsp;
					if (jj_3R_63()) {
						jj_scanpos = xsp;
						if (jj_3R_64()) {
							jj_scanpos = xsp;
							if (jj_3R_65()) {
								jj_scanpos = xsp;
								if (jj_3R_66())
									return true;
							}
						}
					}
				}
			}
		}
		return false;
	}

	private boolean jj_3R_60() {
		if (jj_scan_token(63))
			return true;
		if (jj_3R_57())
			return true;
		return false;
	}

	private boolean jj_3_3() {
		if (jj_scan_token(56))
			return true;
		if (jj_3R_24())
			return true;
		return false;
	}

	private boolean jj_3R_53() {
		if (jj_scan_token(INT))
			return true;
		return false;
	}

	private boolean jj_3R_52() {
		if (jj_scan_token(SHORT))
			return true;
		return false;
	}

	private boolean jj_3R_51() {
		if (jj_scan_token(CHAR))
			return true;
		return false;
	}

	private boolean jj_3R_30() {
		Token xsp;
		xsp = jj_scanpos;
		if (jj_3R_50()) {
			jj_scanpos = xsp;
			if (jj_3R_51()) {
				jj_scanpos = xsp;
				if (jj_3R_52()) {
					jj_scanpos = xsp;
					if (jj_3R_53()) {
						jj_scanpos = xsp;
						if (jj_3R_54()) {
							jj_scanpos = xsp;
							if (jj_3R_55())
								return true;
						}
					}
				}
			}
		}
		return false;
	}

	private boolean jj_3R_50() {
		if (jj_scan_token(VOID))
			return true;
		return false;
	}

	private boolean jj_3R_59() {
		if (jj_scan_token(75))
			return true;
		if (jj_3R_26())
			return true;
		if (jj_scan_token(62))
			return true;
		if (jj_3R_26())
			return true;
		return false;
	}

	private boolean jj_3R_56() {
		if (jj_3R_58())
			return true;
		Token xsp;
		xsp = jj_scanpos;
		if (jj_3R_59())
			jj_scanpos = xsp;
		return false;
	}

	private boolean jj_3R_49() {
		if (jj_scan_token(74))
			return true;
		return false;
	}

	private boolean jj_3R_48() {
		if (jj_scan_token(73))
			return true;
		return false;
	}

	private boolean jj_3R_47() {
		if (jj_scan_token(72))
			return true;
		return false;
	}

	private boolean jj_3_2() {
		if (jj_scan_token(57))
			return true;
		return false;
	}

	private boolean jj_3R_46() {
		if (jj_scan_token(71))
			return true;
		return false;
	}

	private boolean jj_3R_45() {
		if (jj_scan_token(70))
			return true;
		return false;
	}

	private boolean jj_3R_44() {
		if (jj_scan_token(69))
			return true;
		return false;
	}

	private boolean jj_3R_31() {
		if (jj_scan_token(60))
			return true;
		if (jj_scan_token(61))
			return true;
		return false;
	}

	private boolean jj_3R_43() {
		if (jj_scan_token(68))
			return true;
		return false;
	}

	private boolean jj_3R_42() {
		if (jj_scan_token(67))
			return true;
		return false;
	}

	private boolean jj_3R_33() {
		if (jj_3R_26())
			return true;
		return false;
	}

	private boolean jj_3R_41() {
		if (jj_scan_token(66))
			return true;
		return false;
	}

	private boolean jj_3_10() {
		if (jj_scan_token(54))
			return true;
		if (jj_3R_29())
			return true;
		return false;
	}

	private boolean jj_3R_40() {
		if (jj_scan_token(65))
			return true;
		return false;
	}

	private boolean jj_3R_23() {
		if (jj_3R_30())
			return true;
		Token xsp;
		while (true) {
			xsp = jj_scanpos;
			if (jj_3R_31()) {
				jj_scanpos = xsp;
				break;
			}
		}
		return false;
	}

	private boolean jj_3_7() {
		if (jj_3R_23())
			return true;
		if (jj_scan_token(IDENTIFIER))
			return true;
		return false;
	}

	private boolean jj_3R_28() {
		Token xsp;
		xsp = jj_scanpos;
		if (jj_3R_40()) {
			jj_scanpos = xsp;
			if (jj_3R_41()) {
				jj_scanpos = xsp;
				if (jj_3R_42()) {
					jj_scanpos = xsp;
					if (jj_3R_43()) {
						jj_scanpos = xsp;
						if (jj_3R_44()) {
							jj_scanpos = xsp;
							if (jj_3R_45()) {
								jj_scanpos = xsp;
								if (jj_3R_46()) {
									jj_scanpos = xsp;
									if (jj_3R_47()) {
										jj_scanpos = xsp;
										if (jj_3R_48()) {
											jj_scanpos = xsp;
											if (jj_3R_49())
												return true;
										}
									}
								}
							}
						}
					}
				}
			}
		}
		return false;
	}

	private boolean jj_3R_32() {
		if (jj_scan_token(57))
			return true;
		return false;
	}

	private boolean jj_3R_24() {
		Token xsp;
		xsp = jj_scanpos;
		if (jj_3R_32()) {
			jj_scanpos = xsp;
			if (jj_3R_33())
				return true;
		}
		return false;
	}

	private boolean jj_3R_29() {
		Token xsp;
		xsp = jj_scanpos;
		if (jj_scan_token(14)) {
			jj_scanpos = xsp;
			if (jj_scan_token(8)) {
				jj_scanpos = xsp;
				if (jj_scan_token(7)) {
					jj_scanpos = xsp;
					if (jj_scan_token(9)) {
						jj_scanpos = xsp;
						if (jj_scan_token(10)) {
							jj_scanpos = xsp;
							if (jj_scan_token(11)) {
								jj_scanpos = xsp;
								if (jj_scan_token(12)) {
									jj_scanpos = xsp;
									if (jj_scan_token(13))
										return true;
								}
							}
						}
					}
				}
			}
		}
		return false;
	}

	private boolean jj_3_4() {
		if (jj_3R_23())
			return true;
		if (jj_scan_token(IDENTIFIER))
			return true;
		return false;
	}

	private boolean jj_3R_39() {
		if (jj_3R_57())
			return true;
		return false;
	}

	private boolean jj_3R_38() {
		if (jj_scan_token(54))
			return true;
		if (jj_3R_23())
			return true;
		if (jj_scan_token(59))
			return true;
		if (jj_3R_27())
			return true;
		return false;
	}

	private boolean jj_3R_27() {
		Token xsp;
		xsp = jj_scanpos;
		if (jj_3R_38()) {
			jj_scanpos = xsp;
			if (jj_3R_39())
				return true;
		}
		return false;
	}

	private boolean jj_3_9() {
		if (jj_3R_27())
			return true;
		if (jj_3R_28())
			return true;
		return false;
	}

	private boolean jj_3R_37() {
		if (jj_3R_56())
			return true;
		return false;
	}

	private boolean jj_3_8() {
		if (jj_3R_27())
			return true;
		if (jj_scan_token(55))
			return true;
		return false;
	}

	private boolean jj_3R_113() {
		if (jj_scan_token(93))
			return true;
		if (jj_3R_27())
			return true;
		return false;
	}

	private boolean jj_3R_112() {
		if (jj_scan_token(92))
			return true;
		if (jj_3R_27())
			return true;
		return false;
	}

	private boolean jj_3R_111() {
		if (jj_scan_token(91))
			return true;
		if (jj_3R_27())
			return true;
		return false;
	}

	private boolean jj_3R_108() {
		Token xsp;
		xsp = jj_scanpos;
		if (jj_3R_111()) {
			jj_scanpos = xsp;
			if (jj_3R_112()) {
				jj_scanpos = xsp;
				if (jj_3R_113())
					return true;
			}
		}
		return false;
	}

	private boolean jj_3R_36() {
		if (jj_3R_27())
			return true;
		if (jj_3R_28())
			return true;
		if (jj_3R_26())
			return true;
		return false;
	}

	private boolean jj_3R_35() {
		if (jj_3R_27())
			return true;
		if (jj_scan_token(55))
			return true;
		if (jj_3R_26())
			return true;
		return false;
	}

	private boolean jj_3R_26() {
		Token xsp;
		xsp = jj_scanpos;
		if (jj_3R_35()) {
			jj_scanpos = xsp;
			if (jj_3R_36()) {
				jj_scanpos = xsp;
				if (jj_3R_37())
					return true;
			}
		}
		return false;
	}

	private boolean jj_3R_104() {
		if (jj_3R_27())
			return true;
		Token xsp;
		while (true) {
			xsp = jj_scanpos;
			if (jj_3R_108()) {
				jj_scanpos = xsp;
				break;
			}
		}
		return false;
	}

	private boolean jj_3R_110() {
		if (jj_scan_token(90))
			return true;
		if (jj_3R_104())
			return true;
		return false;
	}

	private boolean jj_3R_109() {
		if (jj_scan_token(89))
			return true;
		if (jj_3R_104())
			return true;
		return false;
	}

	private boolean jj_3R_105() {
		Token xsp;
		xsp = jj_scanpos;
		if (jj_3R_109()) {
			jj_scanpos = xsp;
			if (jj_3R_110())
				return true;
		}
		return false;
	}

	private boolean jj_3R_102() {
		if (jj_3R_104())
			return true;
		Token xsp;
		while (true) {
			xsp = jj_scanpos;
			if (jj_3R_105()) {
				jj_scanpos = xsp;
				break;
			}
		}
		return false;
	}

	private boolean jj_3R_107() {
		if (jj_scan_token(88))
			return true;
		if (jj_3R_102())
			return true;
		return false;
	}

	private boolean jj_3R_106() {
		if (jj_scan_token(87))
			return true;
		if (jj_3R_102())
			return true;
		return false;
	}

	private boolean jj_3R_103() {
		Token xsp;
		xsp = jj_scanpos;
		if (jj_3R_106()) {
			jj_scanpos = xsp;
			if (jj_3R_107())
				return true;
		}
		return false;
	}

	private boolean jj_3R_99() {
		if (jj_3R_102())
			return true;
		Token xsp;
		while (true) {
			xsp = jj_scanpos;
			if (jj_3R_103()) {
				jj_scanpos = xsp;
				break;
			}
		}
		return false;
	}

	private boolean jj_3R_82() {
		if (jj_scan_token(54))
			return true;
		if (jj_3R_26())
			return true;
		if (jj_scan_token(59))
			return true;
		return false;
	}

	private boolean jj_3R_100() {
		if (jj_scan_token(86))
			return true;
		if (jj_3R_99())
			return true;
		return false;
	}

	private boolean jj_3R_81() {
		if (jj_scan_token(FALSE_))
			return true;
		return false;
	}

	private boolean jj_3R_80() {
		if (jj_scan_token(TRUE_))
			return true;
		return false;
	}

	private boolean jj_3R_79() {
		if (jj_scan_token(IDENTIFIER))
			return true;
		return false;
	}

	private boolean jj_3R_96() {
		if (jj_3R_99())
			return true;
		Token xsp;
		while (true) {
			xsp = jj_scanpos;
			if (jj_3R_100()) {
				jj_scanpos = xsp;
				break;
			}
		}
		return false;
	}

	private boolean jj_3_1() {
		Token xsp;
		xsp = jj_scanpos;
		if (jj_scan_token(18))
			jj_scanpos = xsp;
		if (jj_3R_23())
			return true;
		if (jj_scan_token(IDENTIFIER))
			return true;
		if (jj_scan_token(54))
			return true;
		return false;
	}

	private boolean jj_3R_97() {
		if (jj_scan_token(85))
			return true;
		if (jj_3R_96())
			return true;
		return false;
	}

	private boolean jj_3R_78() {
		if (jj_scan_token(STRING))
			return true;
		return false;
	}

	private boolean jj_3R_77() {
		if (jj_scan_token(CHARACTER))
			return true;
		return false;
	}

	private boolean jj_3R_87() {
		if (jj_3R_96())
			return true;
		Token xsp;
		while (true) {
			xsp = jj_scanpos;
			if (jj_3R_97()) {
				jj_scanpos = xsp;
				break;
			}
		}
		return false;
	}

	private boolean jj_3R_72() {
		Token xsp;
		xsp = jj_scanpos;
		if (jj_3R_76()) {
			jj_scanpos = xsp;
			if (jj_3R_77()) {
				jj_scanpos = xsp;
				if (jj_3R_78()) {
					jj_scanpos = xsp;
					if (jj_3R_79()) {
						jj_scanpos = xsp;
						if (jj_3R_80()) {
							jj_scanpos = xsp;
							if (jj_3R_81()) {
								jj_scanpos = xsp;
								if (jj_3R_82())
									return true;
							}
						}
					}
				}
			}
		}
		return false;
	}

	private boolean jj_3R_76() {
		if (jj_scan_token(INTEGER))
			return true;
		return false;
	}

	private boolean jj_3R_88() {
		if (jj_scan_token(84))
			return true;
		if (jj_3R_87())
			return true;
		return false;
	}

	private boolean jj_3R_74() {
		if (jj_3R_87())
			return true;
		Token xsp;
		while (true) {
			xsp = jj_scanpos;
			if (jj_3R_88()) {
				jj_scanpos = xsp;
				break;
			}
		}
		return false;
	}

	private boolean jj_3R_94() {
		if (jj_scan_token(83))
			return true;
		if (jj_3R_74())
			return true;
		return false;
	}

	private boolean jj_3R_93() {
		if (jj_scan_token(82))
			return true;
		if (jj_3R_74())
			return true;
		return false;
	}

	private boolean jj_3R_92() {
		if (jj_scan_token(81))
			return true;
		if (jj_3R_74())
			return true;
		return false;
	}

	private boolean jj_3R_91() {
		if (jj_scan_token(80))
			return true;
		if (jj_3R_74())
			return true;
		return false;
	}

	private boolean jj_3R_89() {
		if (jj_scan_token(78))
			return true;
		if (jj_3R_74())
			return true;
		return false;
	}

	private boolean jj_3R_75() {
		Token xsp;
		xsp = jj_scanpos;
		if (jj_3R_89()) {
			jj_scanpos = xsp;
			if (jj_3R_90()) {
				jj_scanpos = xsp;
				if (jj_3R_91()) {
					jj_scanpos = xsp;
					if (jj_3R_92()) {
						jj_scanpos = xsp;
						if (jj_3R_93()) {
							jj_scanpos = xsp;
							if (jj_3R_94())
								return true;
						}
					}
				}
			}
		}
		return false;
	}

	private boolean jj_3R_101() {
		if (jj_scan_token(56))
			return true;
		if (jj_3R_26())
			return true;
		return false;
	}

	private boolean jj_3R_90() {
		if (jj_scan_token(79))
			return true;
		if (jj_3R_74())
			return true;
		return false;
	}

	private boolean jj_3R_25() {
		if (jj_3R_34())
			return true;
		if (jj_scan_token(62))
			return true;
		return false;
	}

	private boolean jj_3R_98() {
		if (jj_3R_26())
			return true;
		Token xsp;
		while (true) {
			xsp = jj_scanpos;
			if (jj_3R_101()) {
				jj_scanpos = xsp;
				break;
			}
		}
		return false;
	}

	private boolean jj_3R_95() {
		Token xsp;
		xsp = jj_scanpos;
		if (jj_3R_98())
			jj_scanpos = xsp;
		return false;
	}

	private boolean jj_3R_70() {
		if (jj_3R_74())
			return true;
		Token xsp;
		while (true) {
			xsp = jj_scanpos;
			if (jj_3R_75()) {
				jj_scanpos = xsp;
				break;
			}
		}
		return false;
	}

	private boolean jj_3R_86() {
		if (jj_scan_token(54))
			return true;
		if (jj_3R_95())
			return true;
		if (jj_scan_token(59))
			return true;
		return false;
	}

	private boolean jj_3R_85() {
		if (jj_scan_token(60))
			return true;
		if (jj_3R_26())
			return true;
		if (jj_scan_token(61))
			return true;
		return false;
	}

	private boolean jj_3R_84() {
		if (jj_scan_token(64))
			return true;
		return false;
	}

	private boolean jj_3R_73() {
		Token xsp;
		xsp = jj_scanpos;
		if (jj_3R_83()) {
			jj_scanpos = xsp;
			if (jj_3R_84()) {
				jj_scanpos = xsp;
				if (jj_3R_85()) {
					jj_scanpos = xsp;
					if (jj_3R_86())
						return true;
				}
			}
		}
		return false;
	}

	private boolean jj_3R_83() {
		if (jj_scan_token(63))
			return true;
		return false;
	}

	private boolean jj_3_6() {
		if (jj_3R_26())
			return true;
		if (jj_scan_token(53))
			return true;
		return false;
	}

	private boolean jj_3R_34() {
		if (jj_scan_token(IDENTIFIER))
			return true;
		return false;
	}

	private boolean jj_3R_71() {
		if (jj_scan_token(77))
			return true;
		if (jj_3R_70())
			return true;
		return false;
	}

	private boolean jj_3R_69() {
		if (jj_3R_72())
			return true;
		Token xsp;
		while (true) {
			xsp = jj_scanpos;
			if (jj_3R_73()) {
				jj_scanpos = xsp;
				break;
			}
		}
		return false;
	}

	private boolean jj_3_5() {
		if (jj_3R_25())
			return true;
		return false;
	}

	private boolean jj_3R_67() {
		if (jj_3R_70())
			return true;
		Token xsp;
		while (true) {
			xsp = jj_scanpos;
			if (jj_3R_71()) {
				jj_scanpos = xsp;
				break;
			}
		}
		return false;
	}

	private boolean jj_3R_66() {
		if (jj_3R_69())
			return true;
		return false;
	}

	private boolean jj_3R_65() {
		if (jj_scan_token(95))
			return true;
		if (jj_3R_27())
			return true;
		return false;
	}

	private boolean jj_3R_68() {
		if (jj_scan_token(76))
			return true;
		if (jj_3R_67())
			return true;
		return false;
	}

	private boolean jj_3R_64() {
		if (jj_scan_token(94))
			return true;
		if (jj_3R_27())
			return true;
		return false;
	}

	private boolean jj_3R_58() {
		if (jj_3R_67())
			return true;
		Token xsp;
		while (true) {
			xsp = jj_scanpos;
			if (jj_3R_68()) {
				jj_scanpos = xsp;
				break;
			}
		}
		return false;
	}

	private boolean jj_3R_63() {
		if (jj_scan_token(90))
			return true;
		if (jj_3R_27())
			return true;
		return false;
	}

	private boolean jj_3R_62() {
		if (jj_scan_token(89))
			return true;
		if (jj_3R_27())
			return true;
		return false;
	}

	private boolean jj_3R_55() {
		if (jj_scan_token(BOOL))
			return true;
		return false;
	}

	private boolean jj_3R_61() {
		if (jj_scan_token(64))
			return true;
		if (jj_3R_57())
			return true;
		return false;
	}

	/** Generated Token Manager. */
	public ParserTokenManager token_source;
	SimpleCharStream jj_input_stream;
	/** Current token. */
	public Token token;
	/** Next token. */
	public Token jj_nt;
	private int jj_ntk;
	private Token jj_scanpos, jj_lastpos;
	private int jj_la;
	private int jj_gen;
	final private int[] jj_la1 = new int[57];
	static private int[] jj_la1_0;
	static private int[] jj_la1_1;
	static private int[] jj_la1_2;
	static {
		jj_la1_init_0();
		jj_la1_init_1();
		jj_la1_init_2();
	}

	private static void jj_la1_init_0() {
		jj_la1_0 = new int[] { 0x0, 0x0, 0x144f40, 0x144f40, 0x140000,
				0x140000, 0x0, 0x0, 0x0, 0xc00000, 0x0, 0x0, 0x40000, 0x0,
				0x4f40, 0xcad44f40, 0xcac00000, 0x0, 0x4f40, 0x0, 0xcac00000,
				0x4000000, 0xd44f40, 0xc00000, 0xc00000, 0xc00000, 0x0, 0x0,
				0x0, 0xc00000, 0x30000000, 0x30000000, 0xc00000, 0xc00000, 0x0,
				0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
				0x0, 0x0, 0xc00000, 0x7f80, 0xc00000, 0x0, 0x0, 0x0, 0xc00000,
				0xc00000, };
	}

	private static void jj_la1_init_1() {
		jj_la1_1 = new int[] { 0x40, 0x100000, 0x0, 0x0, 0x0, 0x0, 0x800000,
				0x1000000, 0x800000, 0x80484300, 0x7000000, 0x2200000, 0x0,
				0x1000000, 0x0, 0x8268431f, 0x8268431f, 0x10000000, 0x0,
				0x200000, 0x8248431f, 0x0, 0x80684300, 0x80484300, 0x80484300,
				0x80484300, 0x1000000, 0x80800000, 0x80800000, 0x80484300, 0x0,
				0x0, 0x80484302, 0x80484300, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
				0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x80484300, 0x0,
				0x80484300, 0x90400000, 0x90400000, 0x1000000, 0x80484300,
				0x484300, };
	}

	private static void jj_la1_init_2() {
		jj_la1_2 = new int[] { 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
				0xc6000001, 0x0, 0x0, 0x0, 0x0, 0x0, 0xc6000001, 0xc6000001,
				0x0, 0x0, 0x0, 0xc6000001, 0x0, 0x1, 0xc6000001, 0x1, 0x1, 0x0,
				0x7ff, 0x7ff, 0x1, 0x0, 0x0, 0xc6000001, 0xc6000001, 0x7fe,
				0x800, 0x1000, 0x2000, 0xfc000, 0xfc000, 0x100000, 0x200000,
				0x400000, 0x1800000, 0x1800000, 0x6000000, 0x6000000,
				0x38000000, 0x38000000, 0xc6000001, 0x0, 0xc6000001, 0x1, 0x1,
				0x0, 0xc6000001, 0x0, };
	}

	final private JJCalls[] jj_2_rtns = new JJCalls[10];
	private boolean jj_rescan = false;
	private int jj_gc = 0;

	/** Constructor with InputStream. */
	public Parser(java.io.InputStream stream) {
		this(stream, null);
	}

	/** Constructor with InputStream and supplied encoding */
	public Parser(java.io.InputStream stream, String encoding) {
		try {
			jj_input_stream = new SimpleCharStream(stream, encoding, 1, 1);
		} catch (java.io.UnsupportedEncodingException e) {
			throw new RuntimeException(e);
		}
		token_source = new ParserTokenManager(jj_input_stream);
		token = new Token();
		jj_ntk = -1;
		jj_gen = 0;
		for (int i = 0; i < 57; i++)
			jj_la1[i] = -1;
		for (int i = 0; i < jj_2_rtns.length; i++)
			jj_2_rtns[i] = new JJCalls();
	}

	/** Reinitialise. */
	public void ReInit(java.io.InputStream stream) {
		ReInit(stream, null);
	}

	/** Reinitialise. */
	public void ReInit(java.io.InputStream stream, String encoding) {
		try {
			jj_input_stream.ReInit(stream, encoding, 1, 1);
		} catch (java.io.UnsupportedEncodingException e) {
			throw new RuntimeException(e);
		}
		token_source.ReInit(jj_input_stream);
		token = new Token();
		jj_ntk = -1;
		jj_gen = 0;
		for (int i = 0; i < 57; i++)
			jj_la1[i] = -1;
		for (int i = 0; i < jj_2_rtns.length; i++)
			jj_2_rtns[i] = new JJCalls();
	}

	/** Constructor. */
	public Parser(java.io.Reader stream) {
		jj_input_stream = new SimpleCharStream(stream, 1, 1);
		token_source = new ParserTokenManager(jj_input_stream);
		token = new Token();
		jj_ntk = -1;
		jj_gen = 0;
		for (int i = 0; i < 57; i++)
			jj_la1[i] = -1;
		for (int i = 0; i < jj_2_rtns.length; i++)
			jj_2_rtns[i] = new JJCalls();
	}

	/** Reinitialise. */
	public void ReInit(java.io.Reader stream) {
		jj_input_stream.ReInit(stream, 1, 1);
		token_source.ReInit(jj_input_stream);
		token = new Token();
		jj_ntk = -1;
		jj_gen = 0;
		for (int i = 0; i < 57; i++)
			jj_la1[i] = -1;
		for (int i = 0; i < jj_2_rtns.length; i++)
			jj_2_rtns[i] = new JJCalls();
	}

	/** Constructor with generated Token Manager. */
	public Parser(ParserTokenManager tm) {
		token_source = tm;
		token = new Token();
		jj_ntk = -1;
		jj_gen = 0;
		for (int i = 0; i < 57; i++)
			jj_la1[i] = -1;
		for (int i = 0; i < jj_2_rtns.length; i++)
			jj_2_rtns[i] = new JJCalls();
	}

	/** Reinitialise. */
	public void ReInit(ParserTokenManager tm) {
		token_source = tm;
		token = new Token();
		jj_ntk = -1;
		jj_gen = 0;
		for (int i = 0; i < 57; i++)
			jj_la1[i] = -1;
		for (int i = 0; i < jj_2_rtns.length; i++)
			jj_2_rtns[i] = new JJCalls();
	}

	private Token jj_consume_token(int kind) throws ParseException {
		Token oldToken;
		if ((oldToken = token).next != null)
			token = token.next;
		else
			token = token.next = token_source.getNextToken();
		jj_ntk = -1;
		if (token.kind == kind) {
			jj_gen++;
			if (++jj_gc > 100) {
				jj_gc = 0;
				for (int i = 0; i < jj_2_rtns.length; i++) {
					JJCalls c = jj_2_rtns[i];
					while (c != null) {
						if (c.gen < jj_gen)
							c.first = null;
						c = c.next;
					}
				}
			}
			trace_token(token, "");
			return token;
		}
		token = oldToken;
		jj_kind = kind;
		throw generateParseException();
	}

	static private final class LookaheadSuccess extends java.lang.Error {
	}

	final private LookaheadSuccess jj_ls = new LookaheadSuccess();

	private boolean jj_scan_token(int kind) {
		if (jj_scanpos == jj_lastpos) {
			jj_la--;
			if (jj_scanpos.next == null) {
				jj_lastpos = jj_scanpos = jj_scanpos.next = token_source
						.getNextToken();
			} else {
				jj_lastpos = jj_scanpos = jj_scanpos.next;
			}
		} else {
			jj_scanpos = jj_scanpos.next;
		}
		if (jj_rescan) {
			int i = 0;
			Token tok = token;
			while (tok != null && tok != jj_scanpos) {
				i++;
				tok = tok.next;
			}
			if (tok != null)
				jj_add_error_token(kind, i);
		}
		if (jj_scanpos.kind != kind)
			return true;
		if (jj_la == 0 && jj_scanpos == jj_lastpos)
			throw jj_ls;
		return false;
	}

	/** Get the next Token. */
	final public Token getNextToken() {
		if (token.next != null)
			token = token.next;
		else
			token = token.next = token_source.getNextToken();
		jj_ntk = -1;
		jj_gen++;
		trace_token(token, " (in getNextToken)");
		return token;
	}

	/** Get the specific Token. */
	final public Token getToken(int index) {
		Token t = token;
		for (int i = 0; i < index; i++) {
			if (t.next != null)
				t = t.next;
			else
				t = t.next = token_source.getNextToken();
		}
		return t;
	}

	private int jj_ntk() {
		if ((jj_nt = token.next) == null)
			return (jj_ntk = (token.next = token_source.getNextToken()).kind);
		else
			return (jj_ntk = jj_nt.kind);
	}

	private java.util.List<int[]> jj_expentries = new java.util.ArrayList<int[]>();
	private int[] jj_expentry;
	private int jj_kind = -1;
	private int[] jj_lasttokens = new int[100];
	private int jj_endpos;

	private void jj_add_error_token(int kind, int pos) {
		if (pos >= 100)
			return;
		if (pos == jj_endpos + 1) {
			jj_lasttokens[jj_endpos++] = kind;
		} else if (jj_endpos != 0) {
			jj_expentry = new int[jj_endpos];
			for (int i = 0; i < jj_endpos; i++) {
				jj_expentry[i] = jj_lasttokens[i];
			}
			boolean exists = false;
			for (java.util.Iterator<?> it = jj_expentries.iterator(); it
					.hasNext();) {
				exists = true;
				int[] oldentry = (int[]) (it.next());
				if (oldentry.length == jj_expentry.length) {
					for (int i = 0; i < jj_expentry.length; i++) {
						if (oldentry[i] != jj_expentry[i]) {
							exists = false;
							break;
						}
					}
					if (exists)
						break;
				}
			}
			if (!exists)
				jj_expentries.add(jj_expentry);
			if (pos != 0)
				jj_lasttokens[(jj_endpos = pos) - 1] = kind;
		}
	}

	/** Generate ParseException. */
	public ParseException generateParseException() {
		jj_expentries.clear();
		boolean[] la1tokens = new boolean[96];
		if (jj_kind >= 0) {
			la1tokens[jj_kind] = true;
			jj_kind = -1;
		}
		for (int i = 0; i < 57; i++) {
			if (jj_la1[i] == jj_gen) {
				for (int j = 0; j < 32; j++) {
					if ((jj_la1_0[i] & (1 << j)) != 0) {
						la1tokens[j] = true;
					}
					if ((jj_la1_1[i] & (1 << j)) != 0) {
						la1tokens[32 + j] = true;
					}
					if ((jj_la1_2[i] & (1 << j)) != 0) {
						la1tokens[64 + j] = true;
					}
				}
			}
		}
		for (int i = 0; i < 96; i++) {
			if (la1tokens[i]) {
				jj_expentry = new int[1];
				jj_expentry[0] = i;
				jj_expentries.add(jj_expentry);
			}
		}
		jj_endpos = 0;
		jj_rescan_token();
		jj_add_error_token(0, 0);
		int[][] exptokseq = new int[jj_expentries.size()][];
		for (int i = 0; i < jj_expentries.size(); i++) {
			exptokseq[i] = jj_expentries.get(i);
		}
		return new ParseException(token, exptokseq, tokenImage);
	}

	private int trace_indent = 0;
	private boolean trace_enabled = true;

	/** Enable tracing. */
	final public void enable_tracing() {
		trace_enabled = true;
	}

	/** Disable tracing. */
	final public void disable_tracing() {
		trace_enabled = false;
	}

	private void trace_call(String s) {
		if (trace_enabled) {
			for (int i = 0; i < trace_indent; i++) {
				System.out.print(" ");
			}
			System.out.println("Call:   " + s);
		}
		trace_indent = trace_indent + 2;
	}

	private void trace_return(String s) {
		trace_indent = trace_indent - 2;
		if (trace_enabled) {
			for (int i = 0; i < trace_indent; i++) {
				System.out.print(" ");
			}
			System.out.println("Return: " + s);
		}
	}

	private void trace_token(Token t, String where) {
		if (trace_enabled) {
			for (int i = 0; i < trace_indent; i++) {
				System.out.print(" ");
			}
			System.out.print("Consumed token: <" + tokenImage[t.kind]);
			if (t.kind != 0
					&& !tokenImage[t.kind].equals("\"" + t.image + "\"")) {
				System.out.print(": \"" + t.image + "\"");
			}
			System.out.println(" at line " + t.beginLine + " column "
					+ t.beginColumn + ">" + where);
		}
	}

	private void trace_scan(Token t1, int t2) {
		if (trace_enabled) {
			for (int i = 0; i < trace_indent; i++) {
				System.out.print(" ");
			}
			System.out.print("Visited token: <" + tokenImage[t1.kind]);
			if (t1.kind != 0
					&& !tokenImage[t1.kind].equals("\"" + t1.image + "\"")) {
				System.out.print(": \"" + t1.image + "\"");
			}
			System.out.println(" at line " + t1.beginLine + " column "
					+ t1.beginColumn + ">; Expected token: <" + tokenImage[t2]
					+ ">");
		}
	}

	private void jj_rescan_token() {
		jj_rescan = true;
		for (int i = 0; i < 10; i++) {
			try {
				JJCalls p = jj_2_rtns[i];
				do {
					if (p.gen > jj_gen) {
						jj_la = p.arg;
						jj_lastpos = jj_scanpos = p.first;
						switch (i) {
						case 0:
							jj_3_1();
							break;
						case 1:
							jj_3_2();
							break;
						case 2:
							jj_3_3();
							break;
						case 3:
							jj_3_4();
							break;
						case 4:
							jj_3_5();
							break;
						case 5:
							jj_3_6();
							break;
						case 6:
							jj_3_7();
							break;
						case 7:
							jj_3_8();
							break;
						case 8:
							jj_3_9();
							break;
						case 9:
							jj_3_10();
							break;
						}
					}
					p = p.next;
				} while (p != null);
			} catch (LookaheadSuccess ls) {
			}
		}
		jj_rescan = false;
	}

	private void jj_save(int index, int xla) {
		JJCalls p = jj_2_rtns[index];
		while (p.gen > jj_gen) {
			if (p.next == null) {
				p = p.next = new JJCalls();
				break;
			}
			p = p.next;
		}
		p.gen = jj_gen + xla - jj_la;
		p.first = token;
		p.arg = xla;
	}

	static final class JJCalls {
		int gen;
		Token first;
		int arg;
		JJCalls next;
	}

}

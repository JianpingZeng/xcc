package utils.tablegen;
/*
 * Extremely C language Compiler
 * Copyright (c) 2015-2020, Jianping Zeng
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied.  See the License for the specific language governing
 * permissions and limitations under the License.
 */

import gnu.trove.list.array.TIntArrayList;
import gnu.trove.map.hash.TIntObjectHashMap;
import gnu.trove.set.hash.TIntHashSet;
import tools.Error;
import tools.Util;

import java.io.FileNotFoundException;
import java.io.PrintStream;
import java.util.*;

import static backend.codegen.MVT.getEnumName;

/**
 * @author Jianping Zeng
 * @version 0.4
 */
public final class RegisterInfoEmitter extends TableGenBackend {
  private RecordKeeper records;
  private String targetName;
  private CodeGenTarget target;

  public RegisterInfoEmitter(RecordKeeper records) {
    this.records = records;
    Util.assertion(records != null);
    target = new CodeGenTarget(records);
    targetName = target.getName();
  }

  /**
   * Prints out all of register names as the variable namespace of integer type.
   * <b>Note that</b> This output source file generated by this method is
   * different with {@linkplain #run(String)}. This method just make
   * register namespace enumeration set.
   */
  void runEnums(String outputFile) throws FileNotFoundException {
    // The file path where all enum values would be written.
    String className = targetName + "GenRegisterNames";
    try (PrintStream os = outputFile.equals("-") ?
        System.out : new PrintStream(outputFile)) {
      ArrayList<Record> registers = records.getAllDerivedDefinition("Register");
      if (registers.isEmpty())
        Error.printFatalError("No 'Register' subclasses defined in td file!");

      os.printf("package backend.target.%s;\n", targetName.toLowerCase());
      emitSourceFileHeaderComment("Target Register Enum Values", os);

      int initValue = 0;
      os.printf("public interface %s \n{" + "\n\tint NoRegister = %d;\n",
          className, initValue);
      initValue++;
      for (Record reg : registers) {
        os.printf("\tint %s = %d;", reg.getName(), initValue);
        initValue++;
        os.println();
      }
      os.println("}");
    }
  }

  @Override
  public void run(String outputFile) throws FileNotFoundException {
    // The file path where all enum values would be written.
    String className = targetName + "GenRegisterInfo";

    try (PrintStream os = outputFile.equals("-") ?
        System.out : new PrintStream(outputFile)) {
      os.printf("package backend.target.%s;\n\n", targetName.toLowerCase());

      emitSourceFileHeaderComment("Register Information Source Fragment",
          os);

      os.println("import backend.codegen.MVT;");
      os.println("import backend.codegen.MachineFunction;");
      os.println("import backend.mc.MCRegisterClass;");
      os.println("import backend.mc.MCRegisterDesc;");
      os.println("import backend.target.TargetRegisterInfo;");
      os.println("import backend.target.RegClassInfo;");
      os.println("import backend.target.TargetMachine;");
      os.println("import backend.target.TargetFrameLowering;");
      os.println("import backend.codegen.EVT;");
      os.printf("import static backend.target.%s.%sGenRegisterNames.*;\n",
          targetName.toLowerCase(), targetName);
      os.printf("import static backend.target.%s.%sGenRegisterInfo.*;\n",
          targetName.toLowerCase(), targetName);
      os.println("import tools.Util;");
      os.println("import java.util.ArrayList;");

      os.printf("public class %s extends %sRegisterInfo \n{\t",
          className, targetName);

      // generates static array for register classes.
      generateRegClassesArray(os);

      // Generates the value type for each register class.
      HashMap<TIntArrayList, String> vtForRC = new HashMap<>();
      generateValueTypeForRegClass(os, vtForRC);

      generateRegClassInfo(os, vtForRC);
      generateRegisterClasses(os);
    }
  }

  private static final int SplitThreshold = 1024;
  private void outputLargeArray(PrintStream os, int[] table, int size,
                                ArrayList<CodeGenRegister> regs, String tableName,
                                ArrayList<String> generatedMtds) {
    if (size != 0) {
      os.printf("\tpublic static final int[] %s = new int[%d];\n", tableName, 2*size);
      String funName = String.format("initialize%s0", tableName);
      generatedMtds.add(funName);
      os.printf("\tprivate static void %s() {\n", funName);

      boolean newFunction = false;
      int idx = -1;
      for (int i = 0; i < size - 1; ++i) {
        if (i % SplitThreshold == 0) {
          if (newFunction) {
            os.println("\t}");
            os.println();

            funName = String.format("initialize%s%d", tableName, i/SplitThreshold);
            generatedMtds.add(funName);
            os.printf("\tprivate static void %s() {\n", funName);
          }
          newFunction = true;
        }

        // Insert spaces for nice formatting.
        if (table[2*i] != ~0) {
          os.printf("\t\t%s[%d] = %s; ", tableName, ++idx, regs.get(table[2*i]).theDef.getName());
          os.printf("%s[%d] = %s;\n", tableName, ++idx, regs.get(table[2*i + 1]).theDef.getName());
        } else {
          os.printf("\t\t%s[%d] = NoRegister; ", tableName, ++idx);
          os.printf("%s[%d] = NoRegister;\n", tableName, ++idx);
        }
      }

      int remained = size * 2 - 2;
      if (table[remained] != ~0) {
        os.printf("\t\t%s[%d] = %s; ", tableName, ++idx, regs.get(table[remained]).theDef.getName());
        os.printf("%s[%d] = %s;\n", tableName, ++idx, regs.get(table[remained + 1]).theDef.getName());
      } else {
        os.printf("\t\t%s[%d] = NoRegister; ", tableName, ++idx);
        os.printf("%s[%d] = NoRegister;\n", tableName, ++idx);
      }
      os.println("\t}");
      os.printf("\tpublic static final int %sSize = %d;\n", tableName, size);
    } else {
      os.printf("\tpublic static final int[] %s = { ~0, ~0 };\n "
          + "\tpublic static final int %sSize = 1;", tableName, tableName);
      os.println();
    }
  }

  private void generateRegClassInfo(PrintStream os,
                                    HashMap<TIntArrayList, String> vtForRC) {
    os.println("\n\t// Register Class information");
    os.println("\tpublic static final RegClassInfo[] RegClassInfos = {");
    CodeGenHwModes cgh = target.getHwModes();
    int numModes = cgh.getNumNodeIds();

    for (int m = 0; m < numModes; m++) {
      String modeName = m == 0 ? "Default" : cgh.getMode(m).name;
      os.printf("\t\t//%d(%s)%n", m, modeName);
      for (CodeGenRegisterClass rc : target.getRegisterClasses()) {
        ArrayList<ValueTypeByHwMode> vvts = rc.getValueTypes();
        TIntArrayList simpleVTs = new TIntArrayList();
        for (ValueTypeByHwMode v : vvts)
          simpleVTs.add(v.get(m).simpleVT);

        Util.assertion(vtForRC.containsKey(simpleVTs));
        String vtsName = vtForRC.get(simpleVTs);
        long regSize = rc.regInfos.get(m).regSize;
        long spillSize = rc.regInfos.get(m).spillSize;
        long alignment = rc.regInfos.get(m).spillAlignment;
        os.printf("\t\tnew RegClassInfo(%d, %d, %d, %s),\n",
            regSize, spillSize, alignment, vtsName);
      }
    }
    os.println("\t};\n");
  }

  private void generateRegClassesArray(PrintStream os) {
    ArrayList<CodeGenRegisterClass> regClasses = target.getRegisterClasses();

    for (CodeGenRegisterClass rc : regClasses) {
      String name = rc.theDef.getName();

      os.printf("\n\t//%s Register Class...\n", name);
      int i = 0;
      os.printf("\tpublic static final int[] %s = {\n\t\t", name);
      for (CodeGenRegister r : rc.members) {
        os.printf("%s, ", r.getName());
        if (i != 0 && i % 10 == 0)
          os.print("\n\t\t");
        ++i;
      }
      os.println("\n\t};");
    }
  }

  private void generateValueTypeForRegClass(PrintStream os,
                                            HashMap<TIntArrayList, String> vtForRC) {
    ArrayList<CodeGenRegisterClass> regClasses = target.getRegisterClasses();

    int numModes = target.getHwModes().getNumNodeIds();
    for (int m = 0; m < numModes; m++) {
      // compute vts for each mode.
      for (CodeGenRegisterClass rc : regClasses) {
        ArrayList<ValueTypeByHwMode> vvts = rc.getValueTypes();
        TIntArrayList simpleVTs = new TIntArrayList();
        for (ValueTypeByHwMode v : vvts)
          simpleVTs.add(v.get(m).simpleVT);

        // Given the value type a legal Java namespace if it is anonymous.
        String name = m == 0 ? "Default" : target.getHwModes().getMode(m).name;
        name += rc.theDef.getName() + "VTs";
        vtForRC.put(simpleVTs, name);
      }
    }

    vtForRC.forEach((vts, name) -> {
      os.printf("\tpublic static final int[] %s = {\n\t\t", name);
      for (int i = 0, e = vts.size(); i < e; i++) {
        int vt = vts.get(i);
        os.printf("%s, ", getEnumName(vt));

        if (i != 0 && i % 10 == 0)
          os.print("\n\t\t");
      }
      os.println("\n\t};");
    });

  }

  private void generateRegisterClasses(PrintStream os) {

    ArrayList<CodeGenRegisterClass> regClasses = target.getRegisterClasses();
    // Output the register class ID.
    int idx = 0;
    os.println("\n\t// Defines the Register Class ID.");
    for (CodeGenRegisterClass rc : regClasses) {
      os.printf("\tpublic static final int %sRegClassID", rc.getName());
      os.printf(" = %d;\n", idx);
      ++idx;
    }

    os.println();
    os.println();

    os.println("\t// Register Class declaration");
    for (CodeGenRegisterClass rc : regClasses) {
      String name = rc.getName();

      // defines a outer static variable.
      os.printf("\tpublic final static %sClass "
          + "%sRegisterClass = %sClass.getInstance();\n", name, name, name);
    }

    os.println();
    // print a static code block to initialize register class instance.
    os.println("\t{");
    for (CodeGenRegisterClass rc : regClasses) {
      String name = rc.getName();
      os.printf("\t\t// Register class initialization for %sRegisterClass.%n", name);
      os.printf("\t\t%sRegisterClass.setSubClasses(%sSubclasses);%n", name, name);
      os.printf("\t\t%sRegisterClass.setSuperClasses(%sSuperclasses);%n", name, name);
      os.printf("\t\t%sRegisterClass.setSubRegClasses(%sSubRegClasses);%n", name, name);
      os.printf("\t\t%sRegisterClass.setSuperRegClasses(%sSuperRegClasses);%n", name, name);
      os.println();
    }
    os.println("\t}");

    // Output an array containing all Register Class instances.
    os.println();
    os.printf("\t// %sMCRegisterClasses array.\n", targetName);
    os.printf("\tprivate static final MCRegisterClass[] %sMCRegisterClasses = {\n", targetName);
    for (CodeGenRegisterClass rc : regClasses) {
      os.printf("\t\t%sRegisterClass,\n", rc.getName());
    }
    os.println("\t};");

    // Output register class define.
    for (CodeGenRegisterClass rc : regClasses) {
      String name = rc.getName();
      // output the register class definition.
      os.printf("\n\tpublic final static class %sClass extends MCRegisterClass \t{",
          name);

      os.println("\n\t\t// Only allow one instance for this class.");
      os.printf("\t\tprivate static %sClass instance = new %sClass();\n", name, name);
      os.printf("\t\tpublic static %sClass getInstance() { return instance;}\n", name);

      os.printf("\n\t\tprivate %sClass()\n\t\t{\n\t\t\t "
              + "super(%sRegClassID, \"%s\", %sSubclasses, \n"
              + "\t\t\t%sSuperclasses, %sSubRegClasses, %sSuperRegClasses, \n"
              + "\t\t\t%d, %s); \n\t\t}",
          name, name, name, name,
          name,
          name,
          name,
          rc.copyCost,
          rc.getName());

      // Output the alternative register allocation order.
      if (!rc.altOrderSelect.isEmpty()) {
        os.println();
        os.println("\t\tprivate static int altOrderSelect(MachineFunction mf) {");
        os.printf("\t\t\t%s\t\n\t\t}\n", rc.altOrderSelect);

        int e = rc.getNumOrders();
        for (int i = 1; i < e; ++i) {
          ArrayList<Record> order = rc.getOrder(i);
          os.printf("\t\tprivate static final int[] altOrder%d = {", i);
          for (int elt = 0, sz = order.size(); elt < sz; ++elt) {
            os.print((elt != 0 ? ", " : " "));
            os.print(order.get(elt).getName());
          }
          os.println("};");
        }
        os.println();

        os.println("\t\t@Override");
        os.println("\t\tpublic int[] getRawAllocationOrder(MachineFunction mf) {");
        os.printf("\t\t\tMCRegisterClass mcr = %sMCRegisterClasses[%sRegClassID];\n", targetName, rc.getName());
        os.println("\t\t\tArrayList<int[]> order = new ArrayList<>();");
        os.println("\t\t\torder.add(mcr.getRegs());");
        for (int i = 1; i < e; ++i) {
          os.printf("\t\t\torder.add(altOrder%d);\n", i);
        }
        os.println("\t\t\tint select = altOrderSelect(mf);");
        os.printf("\t\t\tUtil.assertion(select < %d);\n", e);
        os.println("\t\t\treturn order.get(select);");
        os.println("\t\t}");
      }
      else
        os.println();

      os.println("\t}");
    }

    // Emit the sub-register classes for each RegisterClass.
    //TIntObjectHashMap<TIntHashSet> superClassMap = new TIntObjectHashMap<>();
    TIntObjectHashMap<TIntHashSet> superRegClassMap = new TIntObjectHashMap<>();

    os.println();
    for (int k = 0; k < regClasses.size(); k++) {
      CodeGenRegisterClass rc = regClasses.get(k);
      String name = rc.theDef.getName();

      os.printf("\n\t// %s Sub-register Classes...\n", name);
      os.printf("\tpublic static final MCRegisterClass[] %sSubRegClasses = {\n\t\t", name);

      boolean empty = true;

      for (int j = 0, e = rc.subRegClasses.size(); j < e; ++j) {
        Record subReg = rc.subRegClasses.get(j);
        int i = 0, e2 = regClasses.size();
        for (; i != e2; ++i) {
          CodeGenRegisterClass rc2 = regClasses.get(i);
          if (subReg.getName().equals(rc2.getName())) {
            if (!empty)
              os.print(", ");
            os.printf("%sRegisterClass", rc2.theDef.getName());
            empty = false;

            if (!superRegClassMap.containsKey(i)) {
              superRegClassMap.put(i, new TIntHashSet());
            }

            superRegClassMap.get(i).add(k);
            break;
          }
        }
        if (i == e2) {
          Error.printFatalError("Register Class member '" + subReg.getName() +
              "' is not a valid RegisterClass!");
        }
      }

      os.print(empty ? "" : ", ");
      os.print("\n\t};\n");
    }

    // Emit the super-register classes for each RegisterClass.
    for (int i = 0, e = regClasses.size(); i < e; ++i) {
      CodeGenRegisterClass rc = regClasses.get(i);

      String name = rc.theDef.getName();
      os.printf("\n\t// %s Super-register Classes...\n", name);
      os.printf("\tpublic static final MCRegisterClass[] %sSuperRegClasses = {\n\t\t", name);

      boolean empty = true;
      if (superRegClassMap.containsKey(i)) {
        for (int val : superRegClassMap.get(i).toArray()) {
          CodeGenRegisterClass rc2 = regClasses.get(val);
          if (!empty)
            os.print(", ");
          os.printf("%sRegisterClass", rc2.theDef.getName());
          empty = false;
        }
      }

      os.printf("%s", empty ? "" : ", ");
      os.print("\n\t};\n");
    }

    // Emit the sub-classes array for each RegisterClass
    for (CodeGenRegisterClass rc : regClasses) {
      String name = rc.theDef.getName();

      os.printf("\t// %s Register Class sub-classes...\n", name);
      os.printf("\tpublic static final MCRegisterClass[] %sSubclasses = {\n\t\t", name);

      boolean empty = true;
      for (CodeGenRegisterClass subClass : rc.subClasses) {
        if (!empty) os.print(", ");
        os.printf("%sRegisterClass", subClass.getName());
        empty = false;
      }
      os.printf("%s", empty ? "" : ", ");
      os.print("\n\t};\n\t");
    }

    for (int i = 0, e = regClasses.size(); i != e; i++) {
      CodeGenRegisterClass rc = regClasses.get(i);

      String name = rc.theDef.getName();
      os.printf("\t// %s Register Class super-classes...\n", name);
      os.printf("\tpublic static final MCRegisterClass[] %sSuperclasses = {\n\t\t", name);

      boolean empty = true;
      for (CodeGenRegisterClass supClass : rc.superClasses) {
        if (!empty) os.print(", ");
        os.printf("%sRegisterClass", supClass.getName());
        empty = false;
      }

      os.printf("%s", empty ? "" : ", ");
      os.print("\n\t};\n\n");
    }

    // Output RegisterClass array.
    os.println("\tpublic final static MCRegisterClass[] registerClasses = {");
    regClasses.forEach(rc ->
    {
      os.println("\t\t" + rc.theDef.getName() + "RegisterClass,");
    });
    os.println("\t};\n");

    // emit the register sub-registers / super-registers, aliases set.
    HashMap<Record, TreeSet<Record>> registerSubRegs = new HashMap<>();
    HashMap<Record, TreeSet<Record>> registerSuperRegs = new HashMap<>();
    HashMap<Record, TreeSet<Record>> registerAlias = new HashMap<>();

    ArrayList<CodeGenRegister> regs = target.getRegisters();
    for (CodeGenRegister cgr : regs) {
      Record r = cgr.theDef;
      ArrayList<Record> li = r.getValueAsListOfDefs("Aliases");
      for (Record reg : li) {
        if (!registerAlias.containsKey(r))
          registerAlias.put(r, new TreeSet<>(Record.LessRecord));
        if (!registerAlias.containsKey(reg))
          registerAlias.put(reg, new TreeSet<>(Record.LessRecord));

        if (registerAlias.get(r).contains(reg)) {
          System.err.println("Warning: register alias between "
              + r.getName() + " and " + reg.getName()
              + " specified multiple times!\n");
        }
        registerAlias.get(r).add(reg);

        if (registerAlias.get(reg).contains(r)) {
          System.err.println("Warning: register alias between "
              + r.getName() + " and " + reg.getName()
              + " specified multiple times!\n");
        }
        registerAlias.get(reg).add(r);
      }
    }

    // Process sub-register sets.
    for (CodeGenRegister cgr : regs) {
      Record r = cgr.theDef;
      ArrayList<Record> list = r.getValueAsListOfDefs("SubRegs");
      if (!registerSubRegs.containsKey(r))
        registerSubRegs.put(r, new TreeSet<>(Record.LessRecord));

      for (Record subreg : list) {
        if (registerSubRegs.get(r).contains(subreg)) {
          System.err.printf("Warning: register %s specified as a sub-register of %s"
              + " multiple times!", subreg.getName(), subreg.getName());
        }
        addSubSuperReg(r, subreg, registerSubRegs, registerSuperRegs, registerAlias);
      }
    }


    // Print the SubregHashTable, a simple quadratically probed
    // hash table for determining if a register is a subregister
    // of another register.
    int NumSubRegs = 0;
    HashMap<Record, Integer> RegNo = new HashMap<>();
    for (int i = 0, e = regs.size(); i != e; ++i) {
      RegNo.put(regs.get(i).theDef, i);
      NumSubRegs += registerSubRegs.get(regs.get(i).theDef).size();
    }

    int SubregHashTableSize = 2 * Util.NextPowerOf2(2 * NumSubRegs);
    int[] SubregHashTable = new int[2 * SubregHashTableSize];
    Arrays.fill(SubregHashTable, ~0);

    int hashMisses = 0;
    for (int i = 0, e = regs.size(); i != e; ++i) {
      Record R = regs.get(i).theDef;
      for (Record R3 : registerSubRegs.get(R)) {
        // We have to increase the indices of both registers by one when
        // computing the hash because, in the generated code, there
        // will be an extra empty slot at register 0.
        int index = ((i + 1) + (RegNo.get(R3) + 1) * 37) & (SubregHashTableSize - 1);
        int ProbeAmt = 2;
        while (SubregHashTable[index * 2] != ~0 &&
            SubregHashTable[index * 2 + 1] != ~0) {
          index = (index + ProbeAmt) & (SubregHashTableSize - 1);
          ProbeAmt += 2;

          hashMisses++;
        }

        SubregHashTable[index * 2] = i;
        SubregHashTable[index * 2 + 1] = RegNo.get(R3);
      }
    }

    os.printf("\n\n\t// Number of hash collisions: %d\n", hashMisses);

    // We use some initializer function to initilize a large array!!!
    // This is a ugly way, but I can't avoid it!!!.
    ArrayList<String> generatedInitMtds = new ArrayList<>();
    outputLargeArray(os, SubregHashTable, SubregHashTableSize, regs, "SubregHashTable", generatedInitMtds);

    // Print the SuperregHashTable, a simple quadratically probed
    // hash table for determining if a register is a super-register
    // of another register.
    int NumSupRegs = 0;
    RegNo.clear();
    for (int i = 0, e = regs.size(); i != e; ++i) {
      RegNo.put(regs.get(i).theDef, i);

      if (!registerSuperRegs.containsKey(regs.get(i).theDef))
        registerSuperRegs.put(regs.get(i).theDef, new TreeSet<>(Record.LessRecord));

      NumSupRegs += registerSuperRegs.get(regs.get(i).theDef).size();
    }

    int SuperregHashTableSize = 2 * Util.NextPowerOf2(2 * NumSupRegs);
    int[] SuperregHashTable = new int[2 * SuperregHashTableSize];
    Arrays.fill(SuperregHashTable, ~0);

    hashMisses = 0;

    for (int i = 0, e = regs.size(); i != e; ++i) {
      Record R = regs.get(i).theDef;
      if (!registerSuperRegs.containsKey(R))
        registerSuperRegs.put(R, new TreeSet<>(Record.LessRecord));

      for (Record RJ : registerSuperRegs.get(R)) {
        // We have to increase the indices of both registers by one when
        // computing the hash because, in the generated code, there
        // will be an extra empty slot at register 0.
        int index = ((i + 1) + (RegNo.get(RJ) + 1) * 37) & (SuperregHashTableSize - 1);
        int ProbeAmt = 2;
        while (SuperregHashTable[index * 2] != ~0 &&
            SuperregHashTable[index * 2 + 1] != ~0) {
          index = (index + ProbeAmt) & (SuperregHashTableSize - 1);
          ProbeAmt += 2;

          hashMisses++;
        }

        SuperregHashTable[index * 2] = i;
        SuperregHashTable[index * 2 + 1] = RegNo.get(RJ);
      }
    }

    os.printf("\n\n\t// Number of hash collisions: %s\n", hashMisses);
    outputLargeArray(os, SuperregHashTable, SuperregHashTableSize, regs, "SuperregHashTable", generatedInitMtds);


    // Print the AliasHashTable, a simple quadratically probed
    // hash table for determining if a register aliases another register.
    int NumAliases = 0;
    RegNo.clear();
    for (int i = 0, e = regs.size(); i != e; ++i) {
      RegNo.put(regs.get(i).theDef, i);
      if (!registerAlias.containsKey(regs.get(i).theDef))
        registerAlias.put(regs.get(i).theDef, new TreeSet<>(Record.LessRecord));

      NumAliases += registerAlias.get(regs.get(i).theDef).size();
    }

    int AliasesHashTableSize = 2 * Util.NextPowerOf2(2 * NumAliases);
    int[] AliasesHashTable = new int[2 * AliasesHashTableSize];
    Arrays.fill(AliasesHashTable, ~0);
    //std::fill(AliasesHashTable, AliasesHashTable + 2 * AliasesHashTableSize, ~0);

    hashMisses = 0;

    for (int i = 0, e = regs.size(); i != e; ++i) {
      Record R = regs.get(i).theDef;
      if (!registerAlias.containsKey(R))
        registerAlias.put(R, new TreeSet<>(Record.LessRecord));

      for (Record RJ : registerAlias.get(R)) {
        // We have to increase the indices of both registers by one when
        // computing the hash because, in the generated code, there
        // will be an extra empty slot at register 0.
        int index = ((i + 1) + (RegNo.get(RJ) + 1) * 37) & (AliasesHashTableSize - 1);
        int ProbeAmt = 2;
        while (AliasesHashTable[index * 2] != ~0 &&
            AliasesHashTable[index * 2 + 1] != ~0) {
          index = (index + ProbeAmt) & (AliasesHashTableSize - 1);
          ProbeAmt += 2;

          hashMisses++;
        }

        AliasesHashTable[index * 2] = i;
        AliasesHashTable[index * 2 + 1] = RegNo.get(RJ);
      }
    }

    os.printf("\n\n\t// Number of hash collisions: %s\n", hashMisses);
    outputLargeArray(os, AliasesHashTable, AliasesHashTableSize, regs, "AliasesHashTable", generatedInitMtds);


    if (!registerAlias.isEmpty())
      os.print("\n\n\t// Register Alias Sets...\n");

    // Emit the empty alias list
    os.print("\tpublic static final int[] Empty_AliasSet = { };\n");
    // Loop over all of the registers which have aliases, emitting the alias list
    // to memory.
    for (Map.Entry<Record, TreeSet<Record>> pair : registerAlias.entrySet()) {
      os.print("\tpublic static final int[] " + pair.getKey().getName() + "_AliasSet = { ");
      pair.getValue().forEach(val -> os.print(val.getName() + ", "));
      os.print("};\n");
    }

    if (!registerSubRegs.isEmpty())
      os.print("\n\n\t// Register Sub-registers Sets...\n");

    // Emit the empty sub-registers list
    os.print("\tpublic static final int[] Empty_SubRegsSet = {};\n");
    // Loop over all of the registers which have sub-registers, emitting the
    // sub-registers list to memory.
    for (Map.Entry<Record, TreeSet<Record>> pair : registerSubRegs.entrySet()) {
      os.print("\tpublic static final int[] " + pair.getKey().getName() + "_SubRegsSet = { ");

      ArrayList<Record> SubRegsVector = new ArrayList<>(pair.getValue());
      RegisterSorter RS = new RegisterSorter(registerSubRegs);
      SubRegsVector.sort(RS);

      for (int i = 0, e = SubRegsVector.size(); i != e; ++i)
        os.print(SubRegsVector.get(i).getName() + ", ");

      os.print("};\n");
    }

    if (!registerSuperRegs.isEmpty())
      os.print("\n\n\t// Register Super-registers Sets...\n");

    // Emit the empty super-registers list
    os.print("\tpublic static final int[] Empty_SuperRegsSet = { 0 };\n");
    // Loop over all of the registers which have super-registers, emitting the
    // super-registers list to memory.

    for (Map.Entry<Record, TreeSet<Record>> pair : registerSuperRegs.entrySet()) {
      os.print("\tpublic static final int[] " + pair.getKey().getName() + "_SuperRegsSet = { ");

      ArrayList<Record> SuperRegsVector = new ArrayList<>(pair.getValue());

      RegisterSorter RS = new RegisterSorter(registerSubRegs);
      SuperRegsVector.sort(RS);
      for (int i = 0, e = SuperRegsVector.size(); i != e; ++i)
        os.print(SuperRegsVector.get(i).getName() + ", ");
      os.print("};\n");
    }

    // Now that register alias and sub-registers sets have been emitted, emit the
    // register descriptors now.

    os.print("\n\tpublic static final MCRegisterDesc[] registerDescriptors = {// Descriptor\n");
    os.print("\t\tnew MCRegisterDesc(\"NOREG\", \"NOREG\", null, null, null),\n");

    // Now that register alias sets have been emitted, emit the register
    // descriptors now.
    for (CodeGenRegister reg : regs) {
      os.print("\t\tnew MCRegisterDesc(\"");
      try {
        String asmName = reg.theDef.getValueAsString("AsmName");
        if (!asmName.isEmpty())
          os.print(asmName);
        else
          os.print(reg.getName());

        os.print("\", ");
        os.printf("\"%s\", ", reg.getName());

        if (registerAlias.containsKey(reg.theDef))
          os.print(reg.getName() + "_AliasSet, ");
        else
          os.print("Empty_AliasSet, ");

        if (registerSubRegs.containsKey(reg.theDef))
          os.printf("%s_SubRegsSet, ", reg.getName());
        else
          os.print("Empty_SubRegsSet, ");

        if (registerSuperRegs.containsKey(reg.theDef))
          os.printf("%s_SuperRegsSet", reg.getName());
        else
          os.print("Empty_SuperRegsSet");
        os.print("),\n");
      } catch (Exception e) {
        e.printStackTrace();
      }
    }
    os.println("\t};\n"); // The end of register descriptor.

    // Outputs an enumarate for the sub register index.
    ArrayList<Record> subRegIndices = CodeGenRegBank.getSubRegIndices();
    if (!subRegIndices.isEmpty()) {
      os.println("\t// Sub register indices.");
      os.println("\tpublic static final int NoSubRegister = 0;");
      for (int i = 0, e = subRegIndices.size(); i < e; ++i) {
        Record ind = subRegIndices.get(i);
        os.printf("\tpublic static final int %s = %d;\n", ind.getName(), i+1);
      }
      os.println("\tpublic static final int NUM_TARGET_NAMED_SUBREGS = 31;");
      os.println();
    }

    // Emit the subregister + index mapping function based on the information
    // calculated above.
    os.print("\tpublic int getSubReg(int regNo, int index)\n\t{\n\t");
    os.print("\tswitch(regNo)\n\t\t{\n\t\t\t");
    os.print("default: return 0;\n");

    for (CodeGenRegister reg : regs) {
      HashMap<Record, CodeGenRegister> subRegMap = reg.getSubRegs();
      if (subRegMap.isEmpty())
        continue;

      os.printf("\t\t\tcase %s:\n", reg.theDef.getName());
      os.println("\t\t\tswitch (index) {");
      os.println("\t\t\tdefault: return 0;");
      for (Map.Entry<Record, CodeGenRegister> entry : subRegMap.entrySet()) {
        os.printf("\t\t\tcase %s: return %s;\n", entry.getKey().getName(), entry.getValue().theDef.getName());
      }
      os.println("\t\t\t}");
      os.println("\t\t\t");
    }

    os.print("\t\t}\n");
    os.print("\t}\n\n");


    String className = targetName + "GenRegisterInfo";
    // emit the fields and constructors for *Target* GenRegisterInfo.
    os.printf("\tpublic %s(%sSubtarget subtarget, int mode) {\n" +
        "    super(subtarget);\n", className, targetName);
    if (!generatedInitMtds.isEmpty()) {
      generatedInitMtds.forEach(mtd-> {
        os.printf("\t\t%s();\n", mtd);
      });
    }
    os.println("\t\tinitMCRegisterInfo(registerDescriptors, registerClasses,\n" +
               "\t\t\t\tSubregHashTable, SubregHashTableSize,\n" +
               "\t\t\t\tSuperregHashTable, SuperregHashTableSize,\n" +
               "\t\t\t\tAliasesHashTable, AliasesHashTableSize,\n" +
               "\t\t\t\tRegClassInfos, mode);");
    os.println("\t}");

    os.println("\n}");
  }

  private static void addSubSuperReg(Record r, Record s,
                                     HashMap<Record, TreeSet<Record>> subRegs,
                                     HashMap<Record, TreeSet<Record>> superRegs,
                                     HashMap<Record, TreeSet<Record>> aliases) {
    if (r.equals(s)) {
      System.err.println("Error: recursive sub-register relationship between "
          + " register " + r.getName() + " and it's sub-registers?");
      System.exit(1);
    }

    if (!subRegs.containsKey(r))
      subRegs.put(r, new TreeSet<>(Record.LessRecord));

    if (!subRegs.get(r).add(s))
      return;

    addSuperReg(s, r, subRegs, superRegs, aliases);

    if (!aliases.containsKey(r))
      aliases.put(r, new TreeSet<>(Record.LessRecord));
    if (!aliases.containsKey(s))
      aliases.put(s, new TreeSet<>(Record.LessRecord));

    aliases.get(r).add(s);
    aliases.get(s).add(r);

    if (subRegs.containsKey(s)) {
      for (Record ss : subRegs.get(s)) {
        addSubSuperReg(r, ss, subRegs, superRegs, aliases);
      }
    }
  }

  private static void addSuperReg(Record r, Record s,
                                  HashMap<Record, TreeSet<Record>> subRegs,
                                  HashMap<Record, TreeSet<Record>> superRegs,
                                  HashMap<Record, TreeSet<Record>> aliases) {
    if (r.equals(s)) {
      System.err.println("Error: recursive sub-register relationship"
          + " between register " + r.getName() + " and its sub-register?");
      System.exit(1);
    }

    if (!superRegs.containsKey(r))
      superRegs.put(r, new TreeSet<>(Record.LessRecord));

    if (!subRegs.containsKey(s))
      subRegs.put(s, new TreeSet<>(Record.LessRecord));
    if (!aliases.containsKey(r))
      aliases.put(r, new TreeSet<>(Record.LessRecord));
    if (!aliases.containsKey(s))
      aliases.put(s, new TreeSet<>(Record.LessRecord));

    if (!superRegs.get(r).add(s))
      return;

    subRegs.get(s).add(r);
    aliases.get(r).add(s);
    aliases.get(s).add(r);
    if (superRegs.containsKey(s)) {
      superRegs.get(s).forEach(ss -> {
        addSuperReg(r, ss, subRegs, superRegs, aliases);
      });
    }
  }

  private static class RegisterSorter implements Comparator<Record> {
    private Map<Record, TreeSet<Record>> registerSubRegs;

    public RegisterSorter(Map<Record, TreeSet<Record>> registerSubRegs) {
      this.registerSubRegs = registerSubRegs;
    }

    @Override
    public int compare(Record o1, Record o2) {
      boolean res = registerSubRegs.containsKey(o1) && registerSubRegs.get(o1).contains(o2);
      return res ? -1 : 1;
    }

    @Override
    public boolean equals(Object obj) {
      return false;
    }
  }
}

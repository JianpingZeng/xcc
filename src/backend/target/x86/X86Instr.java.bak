package backend.target.x86;


/**
 * This file defines an enumeration about common X86 instruction.
 *
 * @author Xlous.zeng
 * @version 0.1
 */
public enum X86Instr implements X86II
{
	// Pseudo instruction.
	PHI("PHI", 0, Pseudo, NoArg),
	NOOP("nop",  0x90, RawFrm, NoArg),
	ADJCALLSTACKDOWN("ADJCALLSTACKDOWN", 0, Pseudo, NoArg),
	ADJCALLSTACKUP("ADJCALLSTACKUP", 0, Pseudo,NoArg),
	IMPLICIT_USE("IMPLICIT_USE", 0, Pseudo,NoArg),
	IMPLICIT_DEF("IMPLICIT_DEF", 0, Pseudo,NoArg),

	// Control flow instructions.
	RET("ret", 0xC3, RawFrm, NoArg),
	JMP("jmp", 0xE9, RawFrm, NoArg),
	JB("jb", 0x82, RawFrm, NoArg),
	JAE("jae", 0x83, RawFrm, NoArg),
	JE ("je" , 0x84, RawFrm, NoArg),
	JNE("jne", 0x85, RawFrm, NoArg),
	JBE("jbe", 0x86, RawFrm, NoArg),
	JA ("ja" , 0x87, RawFrm, NoArg),
	JS ("js" , 0x88, RawFrm, NoArg),
	JNS("jns", 0x89, RawFrm, NoArg),
	JL ("jl" , 0x8C, RawFrm, NoArg),
	JGE("jge", 0x8D, RawFrm, NoArg),
	JLE("jle", 0x8E, RawFrm, NoArg),
	JG ("jg" , 0x8F, RawFrm, NoArg),

	// Call instruction.
	CALLpcrel32 ("call", 0xE8, RawFrm, NoArg),
	CALLr32     ("call", 0xFF, MRMS2r, Arg32),
	CALLm32     ("call", 0xFF, MRMS2m, Arg32),

	// Miscellaneous instructions.
	LEAVE("leave", 0xC9, MRMS2m, Arg32),
	
	BSWAPr32("bswap", 0xC8, AddRegFrm, Arg32),

	XCHGrr8 ("xchg", 0x86, MRMDestReg, Arg8),        // xchg R8, R8
	XCHGrr16("xchg", 0x87, MRMDestReg, Arg16), // xchg R16, R16
	XCHGrr32("xchg", 0x87, MRMDestReg, Arg32),        // xchg R32, R32

	LEAr16("lea", 0x8D, MRMSrcMem, Arg16),  // R16 = lea [mem]
	LEAr32("lea", 0x8D, MRMSrcMem, Arg32),       // R32 = lea [mem]

	//===----------------------------------------------------------------------===//
	//  Move Instructions...
	//
	MOVrr8  ("mov", 0x88, MRMDestReg, Arg8),
	MOVrr16 ("mov", 0x89, MRMDestReg, Arg16),
	MOVrr32 ("mov", 0x89, MRMDestReg, Arg32),
	MOVir8  ("mov", 0xB0, AddRegFrm , Arg8),
	MOVir16 ("mov", 0xB8, AddRegFrm , Arg16),
	MOVir32 ("mov", 0xB8, AddRegFrm , Arg32),
	MOVim8  ("mov", 0xC6, MRMS0m    , Arg8),             // [mem] = imm8
	MOVim16 ("mov", 0xC7, MRMS0m    , Arg16),            // [mem] = imm16
	MOVim32 ("mov", 0xC7, MRMS0m    , Arg32),            // [mem] = imm32

	MOVmr8  ("mov", 0x8A, MRMSrcMem , Arg8),            // R8  = [mem]
	MOVmr16 ("mov", 0x8B, MRMSrcMem , Arg16),    // R16 = [mem]

	MOVmr32 ("mov", 0x8B, MRMSrcMem , Arg32),            // R32 = [mem]


	MOVrm8  ("mov", 0x88, MRMDestMem, Arg8),             // [mem] = R8
	MOVrm16 ("mov", 0x89, MRMDestMem, Arg16),            // [mem] = R16
	MOVrm32 ("mov", 0x89, MRMDestMem, Arg32),            // [mem] = R32

	// Extra precision multiplication
	MULr8  ("mul", 0xF6, MRMS4r, Arg8 ),               // AL,AH = AL*R8
	MULr16 ("mul", 0xF7, MRMS4r, Arg16),    // AX,DX = AX*R16
	MULr32 ("mul", 0xF7, MRMS4r, Arg32),         // EAX,EDX = EAX*R32

	// unsigned division/remainder
	DIVr8  ("div", 0xF6, MRMS6r, Arg8 ),              // AX/r8 = AL,AH
	DIVr16 ("div", 0xF7, MRMS6r, Arg16), // DX:AX/r16 = AX,DX
	DIVr32 ("div", 0xF7, MRMS6r, Arg32),     // EDX:EAX/r32 = EAX,EDX

	// signed division/remainder
	IDIVr8 ("idiv",0xF6, MRMS7r, Arg8 ),               // AX/r8 = AL,AH
	IDIVr16("idiv",0xF7, MRMS7r, Arg16),// DX:AX/r16 = AX,DX
	IDIVr32("idiv",0xF7, MRMS7r, Arg32),     // EDX:EAX/r32 = EAX,EDX

	// Sign-extenders for division
	CBW    ("cbw", 0x98, RawFrm, Arg8 ),              // AX = signext(AL)
	CWD    ("cwd", 0x99, RawFrm, Arg8 ),              // DX:AX = signext(AX)
	CDQ    ("cdq", 0x99, RawFrm, Arg8 ),             // EDX:EAX = signext(EAX)

	//===----------------------------------------------------------------------===//
	//  Two address Instructions...
	//

	// unary instructions
	NEGr8("neg", 0xF6, MRMS3r, Arg8),         // R8  = -R8  = 0-R8
	NEGr16 ("neg", 0xF7, MRMS3r, Arg16), // R16 = -R16 = 0-R16
	NEGr32 ("neg", 0xF7, MRMS3r, Arg32),         // R32 = -R32 = 0-R32
	NOTr8("not", 0xF6, MRMS2r, Arg8),         // R8  = ~R8  = R8^-1
	NOTr16 ("not", 0xF7, MRMS2r, Arg16), // R16 = ~R16 = R16^-1
	NOTr32 ("not", 0xF7, MRMS2r, Arg32),         // R32 = ~R32 = R32^-1

	INCr8("inc", 0xFE, MRMS0r, Arg8),         // R8  = R8 +1
	INCr16 ("inc", 0xFF, MRMS0r, Arg16), // R16 = R16+1
	INCr32 ("inc", 0xFF, MRMS0r, Arg32),         // R32 = R32+1
	DECr8("dec", 0xFE, MRMS1r, Arg8),         // R8  = R8 -1
	DECr16 ("dec", 0xFF, MRMS1r, Arg16), // R16 = R16-1
	DECr32 ("dec", 0xFF, MRMS1r, Arg32),         // R32 = R32-1

	// Arithmetic...
	ADDrr8   ("add", 0x00, MRMDestReg, Arg8),
	ADDrr16  ("add", 0x01, MRMDestReg, Arg16),
	ADDrr32  ("add", 0x01, MRMDestReg, Arg32),
	ADDri8   ("add", 0x80, MRMS0r   , Arg8),
	ADDri16  ("add", 0x81, MRMS0r   , Arg16),
	ADDri32  ("add", 0x81, MRMS0r   , Arg32),
	ADDri16b ("add", 0x83, MRMS0r   , Arg16),  // ADDri with sign extended 8 bit imm
	ADDri32b ("add", 0x83, MRMS0r   , Arg32),

	ADCrr32  ("adc", 0x11, MRMDestReg, Arg32),                // R32 += imm32+Carry

	SUBrr8   ("sub", 0x28, MRMDestReg, Arg8),
	SUBrr32  ("sub", 0x29, MRMDestReg, Arg32),
	SUBri8   ("sub", 0x80, MRMS5r    , Arg8),
	SUBri16  ("sub", 0x81, MRMS5r    , Arg16),
	SUBri32  ("sub", 0x81, MRMS5r    , Arg32),
	SUBri16b ("sub", 0x83, MRMS5r    , Arg16),
	SUBri32b ("sub", 0x83, MRMS5r    , Arg32),

	SBBrr32  ("sbb", 0x19, MRMDestReg, Arg32),               // R32 -= R32+Carry

	IMULrr16 ("imul", 0xAF, MRMSrcReg, Arg16),
	IMULrr32 ("imul", 0xAF, MRMSrcReg, Arg32),
	IMULri16 ("imul", 0x69, MRMSrcReg, Arg16),
	IMULri32 ("imul", 0x69, MRMSrcReg, Arg32),
	IMULri16b ("imul", 0x6B, MRMSrcReg, Arg16),
	IMULri32b ("imul", 0x6B, MRMSrcReg, Arg32),

	// Logical operators...
	ANDrr8   ("and", 0x20, MRMDestReg, Arg8),
	ANDrr16  ("and", 0x21, MRMDestReg, Arg16),
	ANDrr32  ("and", 0x21, MRMDestReg, Arg32),
	ANDri8   ("and", 0x80, MRMS4r    , Arg8),
	ANDri16  ("and", 0x81, MRMS4r    , Arg16),
	ANDri32  ("and", 0x81, MRMS4r    , Arg32),
	ANDri16b ("and", 0x83, MRMS4r    , Arg16),
	ANDri32b ("and", 0x83, MRMS4r    , Arg32),

	ORrr8    ("or" , 0x08, MRMDestReg, Arg8),
	ORrr16   ("or" , 0x09, MRMDestReg, Arg16),
	ORrr32   ("or" , 0x09, MRMDestReg, Arg32),
	ORri8    ("or" , 0x80, MRMS1r    , Arg8),
	ORri16   ("or" , 0x81, MRMS1r    , Arg16),
	ORri32   ("or" , 0x81, MRMS1r    , Arg32),
	ORri16b  ("or" , 0x83, MRMS1r    , Arg16),
	ORri32b  ("or" , 0x83, MRMS1r    , Arg32),


	XORrr8   ("xor", 0x30, MRMDestReg, Arg8),
	XORrr16  ("xor", 0x31, MRMDestReg, Arg16),
	XORrr32  ("xor", 0x31, MRMDestReg, Arg32),
	XORri8   ("xor", 0x80, MRMS6r    , Arg8),
	XORri16  ("xor", 0x81, MRMS6r    , Arg16),
	XORri32  ("xor", 0x81, MRMS6r    , Arg32),
	XORri16b ("xor", 0x83, MRMS6r    , Arg16),
	XORri32b ("xor", 0x83, MRMS6r    , Arg32),

	// Test instructions are just like AND, except they don't generate a result.
	TESTrr8  ("test", 0x84, MRMDestReg, Arg8 ),          // flags = R8  & R8
	TESTrr16 ("test", 0x85, MRMDestReg, Arg16),          // flags = R16 & R16
	TESTrr32 ("test", 0x85, MRMDestReg, Arg32),          // flags = R32 & R32
	TESTri8  ("test", 0xF6, MRMS0r    , Arg8 ),          // flags = R8  & imm8
	TESTri16 ("test", 0xF7, MRMS0r    , Arg16),          // flags = R16 & imm16
	TESTri32 ("test", 0xF7, MRMS0r    , Arg32),          // flags = R32 & imm32

	// Shift instructions
	class UsesCL { list<Register> Uses = [CL]; bit printImplicitUses = 1; }

	def SHLrr8   : I2A8 <"shl", 0xD2, MRMS4r    >        , UsesCL; // R8  <<= cl
	def SHLrr16  : I2A8 <"shl", 0xD3, MRMS4r    >, OpSize, UsesCL; // R16 <<= cl
	def SHLrr32  : I2A8 <"shl", 0xD3, MRMS4r    >        , UsesCL; // R32 <<= cl
	def SHLir8   : I2A8 <"shl", 0xC0, MRMS4r    >;                 // R8  <<= imm8
	def SHLir16  : I2A8 <"shl", 0xC1, MRMS4r    >, OpSize;         // R16 <<= imm16
	def SHLir32  : I2A8 <"shl", 0xC1, MRMS4r    >;                 // R32 <<= imm32
	def SHRrr8   : I2A8 <"shr", 0xD2, MRMS5r    >        , UsesCL; // R8  >>= cl
	def SHRrr16  : I2A8 <"shr", 0xD3, MRMS5r    >, OpSize, UsesCL; // R16 >>= cl
	def SHRrr32  : I2A8 <"shr", 0xD3, MRMS5r    >        , UsesCL; // R32 >>= cl
	def SHRir8   : I2A8 <"shr", 0xC0, MRMS5r    >;                 // R8  >>= imm8
	def SHRir16  : I2A8 <"shr", 0xC1, MRMS5r    >, OpSize;         // R16 >>= imm16
	def SHRir32  : I2A8 <"shr", 0xC1, MRMS5r    >;                 // R32 >>= imm32
	def SARrr8   : I2A8 <"sar", 0xD2, MRMS7r    >        , UsesCL; // R8  >>>= cl
	def SARrr16  : I2A8 <"sar", 0xD3, MRMS7r    >, OpSize, UsesCL; // R16 >>>= cl
	def SARrr32  : I2A8 <"sar", 0xD3, MRMS7r    >        , UsesCL; // R32 >>>= cl
	def SARir8   : I2A8 <"sar", 0xC0, MRMS7r    >;                 // R8  >>>= imm8
	def SARir16  : I2A8 <"sar", 0xC1, MRMS7r    >, OpSize;         // R16 >>>= imm16
	def SARir32  : I2A8 <"sar", 0xC1, MRMS7r    >;                 // R32 >>>= imm32

	def SHLDrr32 : I2A8 <"shld", 0xA5, MRMDestReg>, TB, UsesCL;   // R32 <<= R32,R32 cl
	def SHLDir32 : I2A8 <"shld", 0xA4, MRMDestReg>, TB;           // R32 <<= R32,R32 imm8
	def SHRDrr32 : I2A8 <"shrd", 0xAD, MRMDestReg>, TB, UsesCL;   // R32 >>= R32,R32 cl
	def SHRDir32 : I2A8 <"shrd", 0xAC, MRMDestReg>, TB;           // R32 >>= R32,R32 imm8


	// Condition code ops, incl. set if equal/not equal/...
	def SAHF     : X86Inst<"sahf" , 0x9E, RawFrm, Arg8>, Imp<[AH],[]>;  // flags = AH
	def SETBr    : X86Inst<"setb" , 0x92, MRMS0r, Arg8>, TB;            // R8 = <  unsign
	def SETAEr   : X86Inst<"setae", 0x93, MRMS0r, Arg8>, TB;            // R8 = >= unsign
	def SETEr    : X86Inst<"sete" , 0x94, MRMS0r, Arg8>, TB;            // R8 = ==
	def SETNEr   : X86Inst<"setne", 0x95, MRMS0r, Arg8>, TB;            // R8 = !=
	def SETBEr   : X86Inst<"setbe", 0x96, MRMS0r, Arg8>, TB;            // R8 = <= unsign
	def SETAr    : X86Inst<"seta" , 0x97, MRMS0r, Arg8>, TB;            // R8 = >  signed
	def SETSr    : X86Inst<"sets" , 0x98, MRMS0r, Arg8>, TB;            // R8 = <sign bit>
	def SETNSr   : X86Inst<"setns", 0x99, MRMS0r, Arg8>, TB;            // R8 = !<sign bit>
	def SETLr    : X86Inst<"setl" , 0x9C, MRMS0r, Arg8>, TB;            // R8 = <  signed
	def SETGEr   : X86Inst<"setge", 0x9D, MRMS0r, Arg8>, TB;            // R8 = >= signed
	def SETLEr   : X86Inst<"setle", 0x9E, MRMS0r, Arg8>, TB;            // R8 = <= signed
	def SETGr    : X86Inst<"setg" , 0x9F, MRMS0r, Arg8>, TB;            // R8 = <  signed

	// Conditional moves.  These are modelled as X = cmovXX Y, Z.  Eventually
	// register allocated to cmovXX XY, Z
	def CMOVErr16 : I2A16<"cmove", 0x44, MRMSrcReg>, TB, OpSize;        // if ==, R16 = R16
	def CMOVNErr32: I2A32<"cmovne",0x45, MRMSrcReg>, TB;                // if !=, R32 = R32

	// Integer comparisons
	def CMPrr8  : X86Inst<"cmp", 0x38, MRMDestReg, Arg8 >;              // compare R8, R8
	def CMPrr16 : X86Inst<"cmp", 0x39, MRMDestReg, Arg16>, OpSize;      // compare R16, R16
	def CMPrr32 : X86Inst<"cmp", 0x39, MRMDestReg, Arg32>,              // compare R32, R32
		Pattern<(isVoid (unspec2 R32, R32))>;
	def CMPri8  : X86Inst<"cmp", 0x80, MRMS7r    , Arg8 >;              // compare R8, imm8
	def CMPri16 : X86Inst<"cmp", 0x81, MRMS7r    , Arg16>, OpSize;      // compare R16, imm16
	def CMPri32 : X86Inst<"cmp", 0x81, MRMS7r    , Arg32>;              // compare R32, imm32

	// Sign/Zero extenders
	def MOVSXr16r8 : X86Inst<"movsx", 0xBE, MRMSrcReg, Arg8>, TB, OpSize; // R16 = signext(R8)
	def MOVSXr32r8 : X86Inst<"movsx", 0xBE, MRMSrcReg, Arg8>, TB;         // R32 = signext(R8)
	def MOVSXr32r16: X86Inst<"movsx", 0xBF, MRMSrcReg, Arg8>, TB;         // R32 = signext(R16)
	def MOVZXr16r8 : X86Inst<"movzx", 0xB6, MRMSrcReg, Arg8>, TB, OpSize; // R16 = zeroext(R8)
	def MOVZXr32r8 : X86Inst<"movzx", 0xB6, MRMSrcReg, Arg8>, TB;         // R32 = zeroext(R8)
	def MOVZXr32r16: X86Inst<"movzx", 0xB7, MRMSrcReg, Arg8>, TB;         // R32 = zeroext(R16)


	public String name;
	public int opCode;
	/**
	 * {@linkplain }
	 */
	public int form;
	public int argType;
	/**
	 * Does this instr have a 0x66 prefix.
	 */
	public boolean hasOpSizePrefix;
	/**
	 * Should we print implicit uses operands.
	 */
	public boolean printImplicitUses;
	/**
	 * Which prefix int does this instr have?
	 */
	public int prefix;
	/**
	 * What flavor of FP instruction is this? see {@linkplain }.
	 */
	public int fpForm;

	X86Instr(String name, int opCode,
			int format, int argType)
	{
		this(name, opCode, format, argType, false, false, 0, 0);
	}

	X86Instr(String name, int opCode,
			int format, int argType,
			boolean hasOpSizePrefix,
			boolean printImplicitUses,
			int prefix,
			int fpForm)
	{
		this.name = name;
		this.opCode = opCode;
		this.form = format;
		this.argType = argType;
		this.hasOpSizePrefix = hasOpSizePrefix;
		this.printImplicitUses = printImplicitUses;
		this.prefix = prefix;
		this.fpForm = fpForm;
	}
}

cmake_minimum_required(VERSION 2.8)

if(NOT CMAKE_java_COMPILER)
    if (Apple)
        execute_process(COMMAND /usr/libexec/java_home OUTPUT_VARIABLE CMAKE_java_COMPILER)
    endif()
endif()

project(XCC)

set(PACKAGE_NAME "xcc")
set(XCC_MAJOR_VERSION 0)
set(XCC_MINOR_VERSION 4)
set(PACKAGE_VERSION "${XCC_MAJOR_VERSION}.${XCC_MINOR_VERSION}")
set(PACKAGE_STRING "${PACKAGE_NAME}-${PACKAGE_VERSION}")

find_package(Java REQUIRED Development)
#find_package(JNI REQUIRED)
include(UseJava)

if( CMAKE_SOURCE_DIR STREQUAL CMAKE_BINARY_DIR )
    message(FATAL_ERROR "In-source build method is not supported.
please remove cache file(CMakeFiles, CMakeCache.txt) generated by
CMake-system, then cd another build directory")
endif()

if (NOT Java_FOUND)
  message(FATAL_ERROR "No Java development environment found")
endif()

# Set the XCC project source and binary directory.
set(XCC_SOURCE_DIR "${CMAKE_CURRENT_SOURCE_DIR}")
set(XCC_BINARY_DIR "${CMAKE_CURRENT_BINARY_DIR}")

set(SRC_DIR "${XCC_SOURCE_DIR}/java")
set(CLASSES_DIR "${XCC_BINARY_DIR}/classes")
set(OUT_LIB_DIR "${XCC_BINARY_DIR}/lib")
set(OUT_BIN_DIR "${XCC_BINARY_DIR}/bin")
set(OUT_INCLUDE_DIR "${XCC_BINARY_DIR}/include")
set(OUT_JAVADOC_DIR "${XCC_BINARY_DIR}/docs")
set(XCC_JAR "${PACKAGE_STRING}.jar")
set(GEN_SOURCES_DIR "${XCC_BINARY_DIR}/gen_tblgen_srcs")
set(GEN_OPTIONS_SRCS "${GEN_SOURCES_DIR}/driver")

set(JFLAGS -source 1.8 -target 1.8 -encoding UTF-8 -d ${CLASSES_DIR} -cp ${CLASSES_DIR})
set(CMAKE_RUNTIME_OUTPUT_DIRECTORY "${OUT_BIN_DIR}")
set(CMAKE_LIBRARY_OUTPUT_DIRECTORY "${OUT_LIB_DIR}")
set(CMAKE_ARCHIVE_OUTPUT_DIRECTORY "${OUT_LIB_DIR}")
set(EXCLUDE_XCC_DRIVER "${SRC_DIR}/driver")
set(TARGET_DIRECTORY "${SRC_DIR}/backend/target")

# Find the executable for displaying dot file.
set(XDOT "xdot")
set(DOT  "dot")
find_program(XDOT_PATH "${XDOT}")
find_program(DOT_PATH "${DOT}")

if ("${XDOT_PATH}" STREQUAL "XDOT_PATH-NOTFOUND")
  set(XDOT_PATH "")
endif()

if ("${DOT_PATH}" STREQUAL "DOT_PATH-NOTFOUND")
  set(DOT_PATH "")
endif()

# We should use dot+open program on MacOSX instead of xdot,
# since xdot does't display dot graph perfectly.
if (APPLE)
  set(XDOT_PATH "")
elseif(UNIX)
  set(DOT_PATH "")
endif()

if (NOT CMAKE_BUILD_TYPE)
  set(CMAKE_BUILD_TYPE "DEBUG")
endif()

#Set BUILD_MODE for llvm-lit tools.
set(BUILD_MODE ${CMAKE_BUILD_TYPE})

if (CMAKE_BUILD_TYPE EQUAL "DEBUG")
    set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -Og -Wall")
else()
    set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -O3 -Wall")
endif ()

get_filename_component(strip_javac_name "${Java_JAVAC_EXECUTABLE}" DIRECTORY)
get_filename_component(JDK_HOME "${strip_javac_name}" DIRECTORY)
if(APPLE)
    set(JDK_LIBS ${JDK_HOME}/jre/lib/server)
    set(JDK_INCLUDES ${JDK_HOME}/include ${JDK_HOME}/include/darwin)
elseif(CMAKE_SYSTEM_NAME MATCHES "Linux")
    set(JDK_LIBS ${JDK_HOME}/jre/lib/amd64/server)
    set(JDK_INCLUDES ${JDK_HOME}/include ${JDK_HOME}/include/linux)
elseif(WIN32)
    set(JDK_LIBS ${JDK_HOME}/lib ${JDK_HOME}/jre/lib)
    set(JDK_INCLUDES ${JDK_HOME}/include ${JDK_HOME}/include/win32)
endif ()

message(STATUS "JDK_HOME: ${JDK_HOME}")
message(STATUS "JDK_LIBS: ${JDK_LIBS}")
message(STATUS "JDK_INCLUDES: ${JDK_INCLUDES}")

set(XCC_ALL_TARGETS
    X86
    ARM
    RISCV
)

# Enable all targets by default.
if ((XCC_TARGETS_TO_BUILD_STREQUAL "") OR (XCC_TARGETS_TO_BUILD STREQUAL "all"))
    set(XCC_TARGETS_TO_BUILD ${XCC_ALL_TARGETS})
endif()

set(XCC_INIT_TARGET "")
set(XCC_INIT_TARGET_INFO "")
foreach(c ${XCC_TARGETS_TO_BUILD})
  list(FIND XCC_ALL_TARGETS ${c} idx)
  if( idx LESS 0 )
    message(FATAL_ERROR "The target `${c}' does not exist.
    It should be one of\n${XCC_ALL_TARGETS}")
  else()
    string(TOLOWER ${c} LOWER_TARGET)
    set(XCC_INIT_TARGET "${XCC_INIT_TARGET}\n\t\tbackend.target.${LOWER_TARGET}.${c}TargetInfo.Initiliaze${c}Target();")
    set(XCC_INIT_TARGET_INFO "${XCC_INIT_TARGET_INFO}\n\t\tbackend.target.${LOWER_TARGET}.${c}TargetInfo.Initialize${c}TargetInfo();")
  endif()
endforeach(c)

set(XCC_TARGET_ARCH "host"
  CACHE STRING "Set target to use for XCC or use \"host\" for automatic detection.")

# Add path for custom modules
set(CMAKE_MODULE_PATH
  ${CMAKE_MODULE_PATH}
  "${CMAKE_CURRENT_SOURCE_DIR}/cmake")


link_directories(${JDK_LIBS})
include_directories(${JDK_INCLUDES})
include_directories(${OUT_INCLUDE_DIR})
#file(MAKE_DIRECTORY ${OUT_JAVADOC})

set(CPUInfoUtility_PATH "${OUT_LIB_DIR}")
set(CPUInfoUtility_NAME GetCpuIDAndInfo)

# Configure the XCC_NAME, XCC_MAJOR, XCC_MINOR
# Produce ${GEN_SOURCES_DIR}/config/Config.java and Targets.java
set(CONFIG_SRC "${GEN_SOURCES_DIR}/config/Config.java")
set(TARGET_SELECT_SRC "${GEN_SOURCES_DIR}/backend/target/TargetSelect.java")
set(TARGET_SELECT_DEPENDS_ON_SRC "${SRC_DIR}/cfe/driver/CFrontEnd.java"
"${SRC_DIR}/cfe/driver/PreprocessorFactory.java"
"${SRC_DIR}/utils/llc/LLC.java"
"${SRC_DIR}/utils/llvmcheck/LLVMChecker.java")

add_custom_target(XccConfig
    COMMAND ${JAVA_COMPILE} ${JFLAGS} ${CONFIG_SRC}
    DEPENDS ${CONFIG_SRC}
    COMMENT "Compiling XCC configuration file...")

include(addXCC)

# All options referred to from HandleXCCOptions have to be specified
# BEFORE this include, otherwise options will not be correctly set on
# first cmake run
include(config-ix)

string(REPLACE "Native" ${XCC_NATIVE_ARCH}
  XCC_TARGETS_TO_BUILD "${XCC_TARGETS_TO_BUILD}")
list(REMOVE_DUPLICATES XCC_TARGETS_TO_BUILD)

# By default, we target the host, but this can be overridden at CMake
# invocation time.
set(XCC_DEFAULT_TARGET_TRIPLE "${XCC_HOST_TRIPLE}" CACHE STRING
  "Default target for which XCC will generate code." )
set(TARGET_TRIPLE "${XCC_DEFAULT_TARGET_TRIPLE}")

# Generate configuration files.
configure_file(
  ${XCC_SOURCE_DIR}/config/Config.java.in
  ${CONFIG_SRC}
  )

configure_file(
  ${XCC_SOURCE_DIR}/config/TargetSelect.java.in
  ${TARGET_SELECT_SRC}
)

configure_file(
  ${XCC_SOURCE_DIR}/config/version.h.in
  ${OUT_INCLUDE_DIR}/version.h
)

# Verify that we can find a Python 2 interpreter.  Python 3 is unsupported.
set(Python_ADDITIONAL_VERSIONS 2.7)
include(FindPythonInterp)
if( NOT PYTHONINTERP_FOUND )
  message(FATAL_ERROR
"Unable to find Python interpreter, required for builds and testing.

Please install Python or specify the PYTHON_EXECUTABLE CMake variable.")
endif()

if( ${PYTHON_VERSION_STRING} VERSION_LESS 2.7 )
  message(FATAL_ERROR "Python 2.7 or newer is required")
endif()

set(CPU_INFO_HEADER_FILE "${OUT_INCLUDE_DIR}/tools_CPUInfoUtility.h")
# Generate tools_CPUInfoUtility.h header file.
add_custom_target(GenCpuInfoHeader
    COMMAND javah -cp ${XCC_BINARY_DIR}/classes -d ${XCC_BINARY_DIR}/include tools.CPUInfoUtility
    DEPENDS XccConfig
    COMMENT "Building XccConfig and Generating header file for GetCpuIDAndInfo...")

# Add sources file to be compiled.
file(GLOB_RECURSE SRCS_NO_TARGET "${SRC_DIR}/*.java")

# The xcc driver related sources
file(GLOB_RECURSE XCC_DRIVER_SRCS ${SRC_DIR}/driver/*.java)

# Collects targets to be excluded.
foreach(t ${XCC_ALL_TARGETS})
    string(TOLOWER ${t} LOWER_TARGET)
    set(EXCLUDE_TARGET "${EXCLUDE_TARGET}|${LOWER_TARGET}")
endforeach()

set(TMP_TARGET "${EXCLUDE_TARGET}")
string(REGEX REPLACE "^\\|" "" EXCLUDE_TARGET ${TMP_TARGET})

# Remove target-specific or xcc driver related source files.
foreach (file ${SRCS_NO_TARGET})
    if ("${file}" MATCHES "(.*)${EXCLUDE_TARGET}(.*)")
        #message(STATUS "Remove Item from List:${file}")
        list (REMOVE_ITEM SRCS_NO_TARGET ${file})
    endif ()
    if ("${file}" MATCHES "(.*)${EXCLUDE_XCC_DRIVER}(.*)")
        list (REMOVE_ITEM SRCS_NO_TARGET ${file})
    endif ()
endforeach()

# Exclude the TargetSelect.java from source files list as yet.
list(REMOVE_ITEM SRCS_NO_TARGET ${TARGET_SELECT_SRC})
list(REMOVE_ITEM SRCS_NO_TARGET ${TARGET_SELECT_DEPENDS_ON_SRC})

#file(GLOB_RECURSE TROVE_SRCS "${XCC_SOURCE_DIR}/external/trove/*.java")
file(GLOB TROVE_SRCS
    external/trove/gnu/trove/*.java
    external/trove/gnu/trove/decorator/*.java
    external/trove/gnu/trove/function/*.java
    external/trove/gnu/trove/impl/*.java
    external/trove/gnu/trove/impl/hash/*.java
    external/trove/gnu/trove/impl/sync/*.java
    external/trove/gnu/trove/impl/unmodifiable/*.java
    external/trove/gnu/trove/iterator/*.java
    external/trove/gnu/trove/iterator/hash/*.java
    external/trove/gnu/trove/list/*.java
    external/trove/gnu/trove/list/array/*.java
    external/trove/gnu/trove/list/linked/*.java
    external/trove/gnu/trove/map/*.java
    external/trove/gnu/trove/map/custom_hash/*.java
    external/trove/gnu/trove/map/hash/*.java
    external/trove/gnu/trove/procedure/*.java
    external/trove/gnu/trove/procedure/array/*.java
    external/trove/gnu/trove/queue/*.java
    external/trove/gnu/trove/set/*.java
    external/trove/gnu/trove/set/hash/*.java
    external/trove/gnu/trove/stack/*.java
    external/trove/gnu/trove/stack/array/*.java
    external/trove/gnu/trove/strategy/*.java
    )

file(MAKE_DIRECTORY ${CLASSES_DIR})

# Custom target for compiling xcc/backend source files except for
# target-specific codes.
add_custom_target(CommonBackend
    COMMAND ${JAVA_COMPILE} ${JFLAGS} ${TROVE_SRCS} ${SRCS_NO_TARGET}
    DEPENDS XccConfig
    COMMENT "Building CommonBackend"
    WORKING_DIRECTORY ${CMAKE_CURRENT_SOURCE_DIR}/java)

# Set the root node of make target dependency graph
set(XCC_COMMON_DEPENDS CommonBackend)

# Checks whether there is a target unsupported
foreach(c ${XCC_TARGETS_TO_BUILD})
  list(FIND XCC_ALL_TARGETS ${c} idx)
  if (idx LESS 0)
    message(FATAL_ERROR "The target '${c}' does not exist.
    It should be one of \n${XCC_ALL_TARGETS}")
  endif()
endforeach()

# Enter the corresponding target directory
# Generates TableGen files for each target
add_subdirectory(java/backend/target)

#message(STATUS "${TARGET_SRCS}")
#message(STATUS "${TABLEGEN_OUTPUT}")

# Generates xcc options for xcc driver.
file(MAKE_DIRECTORY ${GEN_OPTIONS_SRCS})
macro(XCCTableGen ofn)
  set(local_tds "${XCC_SOURCE_DIR}/java/driver")
  add_custom_command(OUTPUT ${GEN_OPTIONS_SRCS}/${ofn}
  COMMAND java -cp ${CLASSES_DIR} utils.tablegen.TableGen
  -o ${GEN_OPTIONS_SRCS}/${ofn} ${ARGN} -I ${local_tds} ${local_tds}/Options.td
  DEPENDS CommonBackend
  COMMENT "Building ${ofn}...")
  set(TABLEGEN_OUTPUT ${TABLEGEN_OUTPUT} ${GEN_OPTIONS_SRCS}/${ofn}
  )
endmacro(XCCTableGen)

XCCTableGen(OptionInfo.java -gen-xcc-options)
add_public_tablegen_target(XCCOptionsTableGen)

# Compiling collection of generated java source code by TableGen tool.
macro(add_gen_tblgen target_name)
    if (TABLEGEN_OUTPUT)
        add_custom_target(${target_name}
            COMMAND ${JAVA_COMPILE} -cp ${CLASSES_DIR} ${JFLAGS}
            ${TABLEGEN_OUTPUT}
            ${TARGET_SRCS}
            ${TARGETS_SRC}
            ${TARGET_SELECT_SRC}
            ${TARGET_SELECT_DEPENDS_ON_SRC}
            ${XCC_DRIVER_SRCS}
            ${GEN_OPTIONS_SRCS}/OptionID.java
            ${GEN_OPTIONS_SRCS}/OptionKind.java
            ${GEN_OPTIONS_SRCS}/Group.java
            ${GEN_OPTIONS_SRCS}/GroupID.java
        DEPENDS ${BACKEND_TARGET} XCCOptionsTableGen
        COMMENT "Compiling taraget-specific source files")
    else()
        message(FATAL "failed to generate code via llvm-tblgen according to td file")
    endif(TABLEGEN_OUTPUT)
endmacro(add_gen_tblgen)

#message(STATUS "TABLEGEN_OUTPUT: ${TABLEGEN_OUTPUT}")
add_gen_tblgen(BuildTargetSpecific)

# A macro for creating jar package from class files.
macro (add_gen_jar)
    if (NOT EXISTS ${OUT_LIB_DIR})
        file(MAKE_DIRECTORY ${OUT_LIB_DIR})
    endif()
    add_custom_target(jar ALL
        COMMAND ${JAVA_ARCHIVE} -cf "${OUT_LIB_DIR}/${XCC_JAR}" -C ${CLASSES_DIR} .
        DEPENDS BuildTargetSpecific
        WORKING_DIRECTORY ${CLASSES_DIR}
        COMMENT "Building jar")
endmacro(add_gen_jar)

# Generating jar and resides it into out/lib directory.
add_gen_jar()

set(COM_SRCS ${CMAKE_CURRENT_SOURCE_DIR}/cpp/NativeLauncher.cpp)
set(XCC_SRCS ${COM_SRCS} ${XCC_SOURCE_DIR}/cpp/xcc.cpp)
set(XCC_CC_SRCS ${COM_SRCS} ${XCC_SOURCE_DIR}/cpp/xcc-cc.cpp)
set(TABLEGEN_SRCS ${COM_SRCS} ${XCC_SOURCE_DIR}/cpp/TableGen.cpp)
set(OPT_SRCS ${COM_SRCS} ${XCC_SOURCE_DIR}/cpp/Opt.cpp)
set(LLC_SRCS ${COM_SRCS} ${XCC_SOURCE_DIR}/cpp/llc.cpp)
set(LLVM_CHECKER_SRCS ${COM_SRCS} ${XCC_SOURCE_DIR}/cpp/llvm-checker.cpp)

macro(add_xcc_target name)
    add_executable(${name} ${ARGN})
    add_dependencies(${name} jar)
endmacro()

add_xcc_target(xcc ${XCC_SRCS})
add_xcc_target(xcc-cc ${XCC_CC_SRCS})
add_xcc_target(tblgen ${TABLEGEN_SRCS})
add_xcc_target(opt ${OPT_SRCS})
add_xcc_target(llc ${LLC_SRCS})
add_xcc_target(llvm-checker ${LLVM_CHECKER_SRCS})

set(CPU_ID_SRCS "${XCC_SOURCE_DIR}/cpp/GetCpuIDAndInfo.cpp")
add_library(${CPUInfoUtility_NAME} SHARED ${CPU_ID_SRCS})
add_dependencies(${CPUInfoUtility_NAME} jar)
add_dependencies(${CPUInfoUtility_NAME} GenCpuInfoHeader)

target_link_libraries(xcc jvm)
target_link_libraries(xcc-cc jvm)
target_link_libraries(tblgen jvm)
target_link_libraries(opt jvm)
target_link_libraries(llc jvm)
target_link_libraries(llvm-checker jvm)

add_executable(count ${XCC_SOURCE_DIR}/cpp/count.c)
add_executable(FileCheck  ${COM_SRCS} ${XCC_SOURCE_DIR}/cpp/FileCheck.cpp)
target_link_libraries(FileCheck jvm)
add_executable(not ${XCC_SOURCE_DIR}/cpp/not.cpp)

#add_subdirectory(java/test)
#add_subdirectory(java/utils/xcc-lit)

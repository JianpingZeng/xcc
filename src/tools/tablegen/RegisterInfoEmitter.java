package tools.tablegen;
/*
 * Xlous C language Compiler
 * Copyright (c) 2015-2017, Xlous
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied.  See the License for the specific language governing
 * permissions and limitations under the License.
 */

import tools.collect.SetMultiMap;

import java.io.PrintStream;
import java.util.*;

/**
 * @author Xlous.zeng
 * @version 0.1
 */
public final class RegisterInfoEmitter extends TableGenBackend
{
    private RecordKeeper records;
    private String targetName;
    private CodeGenTarget target;
    public RegisterInfoEmitter(RecordKeeper records) throws Exception
    {
        this.records = records;
        assert records != null;
        target = new CodeGenTarget();
        targetName = target.getName();
    }

    /**
     * Prints out all of register names as the variable name of integer type.
     * <b>Note that</b> This output source file generated by this method is
     * different with {@linkplain #run()}. This method just make
     * register name enumeration set.
     */
    public void runEnums() throws Exception
    {
        // The file path where all enum values would be written.
        String className = targetName + "GenRegisterNames";
        String filepath = "./" + className + ".java";
        try (PrintStream os = new PrintStream(filepath))
        {
            ArrayList<Record> registers = records.getAllDerivedDefinition("Register");
            if (registers == null || registers.isEmpty())
                throw new Exception(
                        "No 'Register' subclasses defined in td file!");

            emitSourceFileHeaderComment("Target Register Enum Values", os);

            int initValue = 0;
            os.printf("public interface %s \n{" + "\tint NoRegister = %d;\n",
                    className, initValue);
            initValue++;
            for (Record reg : registers)
            {
                os.printf("\tint %s = %d;", reg.getName(), initValue);
                initValue++;
                os.println();
            }
            os.println("}");
        }
    }

    @Override
    public void run() throws Exception
    {
        // The file path where all enum values would be written.
        String className = targetName + "GenRegisterInfo";
        String filepath = "./" + className + ".java";

        try (PrintStream os = new PrintStream(filepath))
        {
            emitSourceFileHeaderComment("Register Information Source Fgrament",
                    os);
            os.println("package backend.target.x86;\n");

            os.println("import backend.target.TargetRegisterInfo;");
            os.println("import backend.target.TargetRegisterClass;\n");

            os.printf("public abstract class %s extends TargetRegisterInfo " + "implements %sGenRegisterNames, %sGenInstrNames{\t",
                    className, targetName, targetName);

            // generates code for register classes.
            generateRegisterClasses(os);

            // generates fields and nested classes.

        }
    }

    private void generateRegInfoCtr(PrintStream os)
    {

    }

    private void generateRegisterClasses(PrintStream os) throws Exception
    {
        ArrayList<CodeGenRegisterClass> regClasses = target.getRegisterClasses();

        // Output register class define.
        for (CodeGenRegisterClass rc : regClasses)
        {
            String name = rc.getName();
            // output the register class definition.
            os.printf(
                    "\tpublic final static class %sClass extends TargetRegisterClass\t{",
                    name);

            os.println("// Only allow one instance for this class.");
            os.printf("\tprivate static instance = new %sClass();\n", name);
            os.println("public static %sClass getInstance() { return instance;}");

            os.printf("\tprivate %sClass(){ super(%s, %d, %d, %s); }",
                    name, rc.getName()+"VTs", rc.spillSize/8, rc.spillAlignment/8, name);
            os.println(rc.methodBodies);
            os.println("}");

            // defines a outer static variable.
            os.printf("\n\t public final static TargetRegisterClass "
                    + "%sRegisterClass = %sClass.getInstance();\n", name, name);
        }

        SetMultiMap<Record, CodeGenRegisterClass> regClassesBelongedTo = new SetMultiMap<>();

        // Output register class array declaration.
        for (CodeGenRegisterClass rc : regClasses)
        {
            String name = rc.theDef.getName();

            os.println("\n//\t" + name + " Register Class.");
            os.printf("public final static int[] %s={\n\t", name);
            for (Record r : rc.elts)
            {
                os.print(r.getName() + ", ");
                regClassesBelongedTo.put(r, rc);
            }
            os.print("\n\t};\n\n");
        }

        // Emit the ValueType arrays for each RegisterClass
        for (CodeGenRegisterClass rc : regClasses)
        {
            // Give the register class a legal C name.
            String name = rc.theDef.getName() + "VTs";
            os.printf("//\t%s Register Class Value types.\n", name);
            os.printf("public static final MVT.ValueType[] %s = {\n\t", name);
            rc.vts.forEach(vt->os.printf("MVT.ValueType.%s, ", vt));
            os.print("MVT.ValueType.Other\n\t};\n\n");
        }

        // Output RegisterClass array.
        os.println("\tpublic final static TargetRegisterClass[] registerClasses = {\n");
        regClasses.forEach(rc->
        {
            os.println(rc.getName()+"RegClass,");
        });
        os.println("\t}\n");

        // Emit the register alias set.
        HashMap<Record, HashSet<Record>> registerAlias = new HashMap<>();
        ArrayList<CodeGenRegister> regs = target.getRegisters();

        regs.forEach(cgr->
        {
            Record r = cgr.theDef;
            try
            {
                ArrayList<Record> li = r.getValueAsListOfDefs("Aliases");
                for (int i = 0, e = li.size(); i < e; i++)
                {
                    Record reg = li.get(i);
                    if (registerAlias.get(r).contains(reg))
                    {
                        System.err.println("Warning: register alias between "
                                + r.getName() + " and " + reg.getName()
                                + " specified multiple times!\n");
                    }
                    registerAlias.get(r).add(reg);
                    if (registerAlias.get(reg).contains(r))
                    {
                        System.err.println("Warning: register alias between "
                                + r.getName() + " and " + reg.getName()
                                + " specified multiple times!\n");
                    }
                    registerAlias.get(reg).add(r);
                }
            }
            catch (Exception e)
            {
                e.printStackTrace();
            }
        });

        if (!registerAlias.isEmpty())
        {
            os.println("\n\n\t// Register Alias set.");
        }
        os.println("public final static int[] empty_AliasSet = {};");

        for (Map.Entry<Record, HashSet<Record>> pair : registerAlias.entrySet())
        {
            os.println("\tint " + pair.getKey().getName() + "_AliasSet[] = { ");
            for (Record reg : pair.getValue())
            {
                os.print(reg.getName() + ", ");
            }
            os.println("};");
        }

        os.println("\n\tpublic static final TargetRegisterDesc[] registerDescriptors = {// Descriptor");
        os.println("\t{ \"NOREG\", \t0 }, ");

        // Now that register alias sets have been emitted, emit the register
        // descriptors now.
        regs.forEach(cgr->
        {
            os.print("\t{ \"");
            try
            {
                String regName = cgr.theDef.getValueAsString("Name");

                if (!regName.isEmpty())
                    os.print(regName);
                else
                    os.print(cgr.getName());

                os.print("\", \t");
                if (registerAlias.containsKey(cgr.theDef))
                    os.println(cgr.getName() + "_AliasSet }, ");
                else
                    os.println("empty_AliasSet }, ");
            }
            catch (Exception e)
            {
                e.printStackTrace();
            }
        });
        os.println("\t};"); // The end of register descriptor.


        // Emit the fields and constrctors for X86GenRegisterInfo.
        os.print("\tpublic %sGenRegisterInfo(int callFrameSetupOpCode, "
                + "int callFrameDestroyOpCode)");
        os.println();
        os.println("\t{");
        os.println("\tsuper(registerDescriptors, registerClasses, callFrameSetupOpCode, callFrameDestroyOpCode) \n\t{}");
        os.println();

        // Emit the getCalleeSavedRegs method.
        os.println("private final int[] calleeSavedRegs = {\n\t");
        ArrayList<Record> csrs = target.getCalleeSavedRegisters();
        csrs.forEach(csr->os.print(csr.getName()+", "));
        os.print("\t};\n");

        os.println("public int[] getCalleeSavedRegs() { return calleeSavedRegs; }");
        os.println();

        // Emit information about the callee saved register classes.
        os.println("private final TargetRegisterClass[] calleeSavedRegClasses = {\n\t");

        csrs.forEach(csr->
        {
            Set<CodeGenRegisterClass> rcs = regClassesBelongedTo.get(csr);
            assert rcs != null;
            CodeGenRegisterClass rc = null;
            for (CodeGenRegisterClass tmp : rcs)
            {
                if (rc == null || tmp.spillSize < rc.spillSize)
                    rc = tmp;
            }
            for (Record reg : rc.elts)
            {
                os.print(reg.getName() + ", ");

                // Keep track of which regclasses this register is in.
                regClassesBelongedTo.put(reg, rc);
            }
        });
        os.println("\n\t};\n");
        os.println("");
        os.println("\t}");
    }
}

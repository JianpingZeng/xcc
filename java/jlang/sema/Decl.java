package jlang.sema;

/*
 * Extremely C language Compiler.
 * Copyright (c) 2015-2018, Xlous Zeng.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied.  See the License for the specific language governing
 * permissions and limitations under the License.
 */

/**
 * @author Xlous.zeng
 * @version 0.1
 */

import tools.Util;
import jlang.ast.Attr;
import jlang.ast.AttrKind;
import jlang.ast.DeclPrinter;
import jlang.ast.Tree;
import jlang.ast.Tree.Expr;
import jlang.ast.Tree.LabelStmt;
import jlang.ast.Tree.StringLiteral;
import jlang.clex.IdentifierInfo;
import jlang.cparser.DeclKind;
import jlang.cparser.Declarator;
import jlang.support.Linkage;
import jlang.support.PrintingPolicy;
import jlang.support.SourceLocation;
import jlang.support.SourceRange;
import jlang.type.*;
import tools.APSInt;
import tools.OutRef;

import java.io.PrintStream;
import java.util.ArrayList;
import java.util.List;

import static jlang.cparser.DeclKind.*;
import static jlang.type.TagKind.*;

/**
 * This class encapsulate information of declaration or definition, like
 * a variable, label, typedef, function, struct, enum, field, enum constant.
 */
public abstract class Decl
{
    public enum StorageClass
    {
        SC_none,
        // for FunctionProto
        SC_static,
        SC_extern,

        // for variable
        SC_auto,
        SC_register,

        SC_PrivateExtern
    }

    /**
     * Where the declaration declared in the source code.
     */
    private SourceLocation location;

    /**
     * Tell if this declaration is invalid or not.
     */
    private boolean invalidDecl;

    /**
     * Whether this declaration was "used", meaning that a definition is
     * required.
     */
    private boolean isUsed;

    /**
     * Whether this declaration was implicitly generated by
     * the implementation rather than explicitly written by the user.
     */
    private boolean implicit;

    /**
     * This specifies what {@linkplain IdentifierNamespace} this declaration
     * lives in.
     */
    protected IdentifierNamespace identifierNamespace;

    /**
     * The declaration context which contains this decl.
     */
    protected IDeclContext dc;
    
    protected DeclKind dk;

    /**
     * Indicates whether this declaration is referenced by other expression.
     * In the other hand, it indicates if this declaration has been used.
     */
    protected boolean referenced;

    protected Decl(DeclKind kind, IDeclContext dc, SourceLocation location)
    {
        this.location = location;
        this.dc = dc;
        identifierNamespace = getIdentifierNamespaceForKind(kind);
        dk = kind;
    }

    public void setInvalidDecl(boolean invalidDecl)
    {
        this.invalidDecl = invalidDecl;
    }

    public boolean isInvalidDecl()
    {
        return invalidDecl;
    }

    public SourceLocation getLocation()
    {
        return location;
    }

    public void setLocation(SourceLocation loc)
    {
        location = loc;
    }

    public boolean isUsed()
    {
        return isUsed;
    }

    public void setUsed()
    {
        isUsed = true;
    }

    public IDeclContext getDeclContext()
    {
        return dc;
    }

    public void setDeclContext(IDeclContext ctx)
    {
        dc = ctx;
    }

    public static IdentifierNamespace
        getIdentifierNamespaceForKind(DeclKind kind)
    {
        switch (kind)
        {
            case FunctionDecl:
            case EnumConstant:
            case VarDecl:
            case TypedefDecl:
            case ParamVarDecl:
            case OriginalParamVar:
                return IdentifierNamespace.IDNS_Ordinary;
            case RecordDecl:
            case EnumDecl:
                return IdentifierNamespace.IDNS_Tag;
            case LabelDecl:
                return IdentifierNamespace.IDNS_Label;
            case FieldDecl:
                return IdentifierNamespace.IDNS_Member;

            case TranslationUnitDecl:
            default:
                return null;
        }
    }

    public static boolean isTagIdentifierNamespace(IdentifierNamespace ns)
    {
        return ns == IdentifierNamespace.IDNS_Tag;
    }

    public void setImplicit(boolean implicit)
    {
        this.implicit = implicit;
    }

    public boolean isImplicit()
    {
        return implicit;
    }

    /**
     * Source range that this declaration covers.
     * @return
     */
    public SourceRange getSourceRange()
    {
        return new SourceRange(getLocation(), getLocation());
    }

    public SourceLocation getLocStart()
    {
        return getSourceRange().getBegin();
    }

    public SourceLocation getLocEnd()
    {
        return getSourceRange().getEnd();
    }

    public String getDeclKindName()
    {
        return dk.declKindName;
    }

    public DeclKind getKind()
    {
        return dk;
    }

    protected Decl getNextRedeclaration()
    {
        return this;
    }

    /**
     * If this Decl represents a declaration for a body of code,
     *  such as a function or method definition, this method returns the
     *  top-level Stmt* of that body.  Otherwise this method returns null.
     * @return
     */
    public Tree.Stmt getBody()
    {
        return null;
    }

    public Tree.CompoundStmt getCompoundBody()
    {
        Tree.Stmt stmt = getBody();
        return stmt instanceof Tree.CompoundStmt ? (Tree.CompoundStmt)stmt : null;
    }

    public Decl getCanonicalDecl()
    {
        return this;
    }

    public boolean isCanonicalDecl()
    {
        return this == getCanonicalDecl();
    }

    public IdentifierNamespace getIdentifierNamespace()
    {
        return getIdentifierNamespaceForKind(getKind());
    }

    public boolean isSameInIdentifierNameSpace(IdentifierNamespace otherINS)
    {
        return getIdentifierNamespace() == otherINS;
    }

    private boolean hasAttrs;

    public boolean hasAttrs()
    {
        return hasAttrs;
    }

    public ArrayList<Attr> getAttrs()
    {
        if (!hasAttrs) return null;
        return getASTContext().getDeclAttrs(this);
    }

    public void setAttrs(ArrayList<Attr> alist)
    {
        Util.assertion(!hasAttrs, "hasAttrs has been set!");
        ArrayList<Attr> attrBank = getASTContext().getDeclAttrs(this);
        Util.assertion(attrBank.isEmpty(), "hasAttrs was wrong?");

        attrBank.addAll(alist);
        hasAttrs = true;
    }

    public void addAttr(Attr a)
    {
       if (hasAttrs)
           getAttrs().add(a);
       else
       {
           ArrayList<Attr> list = new ArrayList<>();
           list.add(a);
           setAttrs(list);
       }
    }

    public void dropAttrs()
    {
        if (!hasAttrs)
            return;

        hasAttrs = false;
        getASTContext().eraseDeclAttrs(this);
    }

    public void swapAttrs(Decl rhs)
    {
        boolean hasLHSAttr = hasAttrs;
        boolean hasRHSAttr = rhs.hasAttrs;

        if (!hasLHSAttr && !hasRHSAttr)
            return;

        if (!hasLHSAttr)
        {
            rhs.swapAttrs(this);
            return;
        }

        // Handle the case when both decls have attrs.
        ASTContext ctx = getASTContext();
        if (hasRHSAttr)
        {
            ArrayList<Attr> lhsVec = ctx.eraseDeclAttrs(this);
            ArrayList<Attr> rhsVec = ctx.eraseDeclAttrs(rhs);
            ctx.putDeclAttrs(this, rhsVec);
            ctx.putDeclAttrs(rhs, lhsVec);
            return;
        }

        // Otherwise, LHS has an attr and RHS doesn't.
        ArrayList<Attr> lhsVec = ctx.eraseDeclAttrs(this);
        ctx.putDeclAttrs(rhs, lhsVec);
        hasAttrs = false;
        rhs.hasAttrs = true;
    }

    public boolean hasAttr(AttrKind kind)
    {
        if (getAttrs() == null || getAttrs().isEmpty())
            return false;

        for (Attr a : getAttrs())
        {
            if (a.getKind() == kind)
                return true;
        }
        return false;
    }

    public Attr getAttr(AttrKind kind)
    {
        if (getAttrs() == null || getAttrs().isEmpty())
            return null;

        for (Attr a : getAttrs())
        {
            if (a.getKind() == kind)
                return a;
        }
        return null;
    }

    /**
     * This class represents the Translation unit declaration in each source
     * file or header file.
     * @return
     */
    public TranslationUnitDecl getTranslationUnitDecl()
    {
        if (this instanceof TranslationUnitDecl)
            return (Decl.TranslationUnitDecl)this;

        IDeclContext dc = getDeclContext();
        Util.assertion(dc != null, "This decl is not contained in a translation unit");

        while (!dc.isTranslationUnit())
        {
            dc = dc.getParent();
            Util.assertion(dc != null, "This decl is not contained in a translation unit");
        }
        return (Decl.TranslationUnitDecl)dc;
    }

    public ASTContext getASTContext()
    {
        return getTranslationUnitDecl().getASTContext();
    }

    public void setReferenced(boolean val)
    {
        referenced = val;
    }

    public boolean isReferenced()
    {
        return referenced;
    }

    public void print(PrintStream os)
    {
        print(os, 0);
    }

    public void print(PrintStream os, int indentation)
    {
        print(os, null, indentation);
    }

    public void print(PrintStream os, PrintingPolicy policy)
    {
        print(os, policy, 0);
    }

    public static void printGroup(ArrayList<Decl> decls,
            PrintStream os,
            PrintingPolicy policy,
            int indentation)
    {
        if (decls.size() == 1)
        {
            decls.get(0).print(os, policy, indentation);
            return;
        }

        int i = 0;
        TagDecl td = decls.get(0) instanceof TagDecl ? (TagDecl)decls.get(0):null;
        if (td != null)
            i++;

        PrintingPolicy subPolicy = new PrintingPolicy(policy);
        if (td != null && td.isCompleteDefinition())
        {
            td.print(os, policy, indentation);
            os.print(" ");
            subPolicy.suppressTag = true;
        }

        boolean isFirst = true;
        for (int e = decls.size(); i != e; i++)
        {
            if (isFirst)
            {
                subPolicy.suppressSpecifiers = false;
                isFirst = false;
            }
            else
            {
                if (!isFirst)
                    os.print(", ");
                subPolicy.suppressSpecifiers = true;
            }

            decls.get(i).print(os, policy, indentation);
        }
    }

    /**
     * Print this declaration into the given printing stream with given print
     * policy.
     * @param os
     * @param policy
     */
    public void print(PrintStream os, PrintingPolicy policy, int indentation)
    {
        DeclPrinter printer = new DeclPrinter(os, getASTContext(), policy, indentation);
        printer.visit(this);
    }

    public void dump()
    {}

    /**
     * The top level declaration context.
     */
    public static class TranslationUnitDecl extends Decl implements IDeclContext
    {
        private ASTContext ctx;
        private DeclContext dc;

        private TranslationUnitDecl(ASTContext ctx)
        {
            super(TranslationUnitDecl, null, new SourceLocation());
            this.ctx = ctx;
            dc = new DeclContext(TranslationUnitDecl, this);
        }

        public static TranslationUnitDecl create(ASTContext ctx)
        {
            return new TranslationUnitDecl(ctx);
        }

        public ASTContext getASTContext()
        {
            return ctx;
        }

        @Override
        public DeclKind getKind()
        {
            return dc.getKind();
        }

        @Override
        public String getDeclKindName()
        {
            return dc.getDeclKindName();
        }

        @Override
        public ASTContext getParentASTContext()
        {
            return dc.getParentASTContext();
        }

        @Override
        public IDeclContext getParent()
        {
            return dc.getParent();
        }

        @Override
        public void addDecl(Decl decl)
        {
            dc.addDecl(decl);
        }

        @Override
        public void addHiddenDecl(Decl d)
        {
            dc.addHiddenDecl(d);
        }

        @Override
        public void removeDecl(Decl decl)
        {
            dc.removeDecl(decl);
        }

        @Override
        public boolean isFunction()
        {
            return dc.isFunction();
        }

        @Override
        public boolean isFileContext()
        {
            return dc.isFileContext();
        }

        @Override
        public boolean isTranslationUnit()
        {
            return dc.isTranslationUnit();
        }

        @Override
        public boolean isRecord()
        {
            return dc.isRecord();
        }

        @Override
        public boolean isTransparentContext()
        {
            return dc.isTransparentContext();
        }

        @Override
        public IDeclContext getLookupContext()
        {
            return dc.getLookupContext();
        }

        @Override
        public boolean isDeclInContext(Decl decl)
        {
            return dc.isDeclInContext(decl);
        }

        @Override
        public boolean isEmpty()
        {
            return dc.isEmpty();
        }

        @Override
        public List<Decl> getDeclsInContext()
        {
            return dc.getDeclsInContext();
        }

        @Override
        public int getDeclCounts()
        {
            return dc.getDeclCounts();
        }

        @Override
        public Decl getDeclAt(int idx)
        {
            return dc.getDeclAt(idx);
        }

        @Override
        public NamedDecl[] lookup(IdentifierInfo name)
        {
            return dc.lookup(name);
        }

        @Override
        public void makeDeclVisibleInContext(NamedDecl nd)
        {
            dc.makeDeclVisibleInContext(nd);
        }

        @Override
        public IDeclContext getPrimaryContext()
        {
            return dc.getPrimaryContext();
        }
    }

    /**
     * This class represents a declaration with a getIdentifier, for example,
     * {@linkplain VarDecl}, {@linkplain LabelDecl} and {@linkplain TypeDecl}.
     */
    public static class NamedDecl extends Decl
    {
        IdentifierInfo name;

        NamedDecl(DeclKind kind, IDeclContext context,
                IdentifierInfo name, SourceLocation location)
        {
            super(kind, context, location);
            this.name = name;
        }

        public String getNameAsString()
        {
            Util.assertion( name != null);
            return getIdentifier().getName();
        }

        public boolean hasLinkage()
        {
            if (this instanceof VarDecl)
            {
                VarDecl vd = (VarDecl)this;
                return vd.hasExternalStorage() || vd.isFileVarDecl();
            }
            return (this instanceof FunctionDecl);
        }

        /**
         * et the identifier that names this declaration,
         * if there is one. This will return NULL if this declaration has
         * no asmName
         * @return
         */
        public IdentifierInfo getIdentifier()
        {
            return name;
        }

        public Linkage getLinkage()
        {
            LinkageInfo info = getLVForDecl(this, LVFlags.createOnlyDeclLinkage());
            return info.getLinkage();
        }

        private static LinkageInfo getLVForDecl(NamedDecl decl, LVFlags flags)
        {
            if (decl.getDeclContext().isFileContext())
            {
                if (decl instanceof VarDecl)
                {
                    Decl.VarDecl var = (Decl.VarDecl) decl;
                    // Explicitly declared static.
                    if (var.getStorageClass() == StorageClass.SC_static)
                        return LinkageInfo.internal();

                    if (var.getStorageClass() == StorageClass.SC_none)
                        return LinkageInfo.external();

                    if (var.getStorageClass() == StorageClass.SC_extern)
                        return LinkageInfo.external();
                }
                else if (decl instanceof FunctionDecl)
                {
                    Decl.FunctionDecl fnDecl = (Decl.FunctionDecl) decl;

                    // Explicitly declared static.
                    if (fnDecl.getStorageClass() == StorageClass.SC_static)
                        return LinkageInfo.internal();

                    return LinkageInfo.external();
                }
                else if (decl instanceof FieldDecl)
                {
                    //   - a data member of an anonymous union.
                    Decl.FieldDecl field = (Decl.FieldDecl) decl;
                    if (((RecordDecl) field.getDeclContext()).isAnonymousStructOrUnion())
                        return LinkageInfo.internal();
                }

                // Set up the defaults.

                // C99 6.2.2p5:
                //   If the declaration of an identifier for an object has file
                //   scope and no storage-class specifier, its linkage is
                //   external.
                return new LinkageInfo();
            }
            if (decl.getDeclContext().isFunction())
            {
                if (decl instanceof VarDecl)
                {
                    Decl.VarDecl var = (Decl.VarDecl) decl;
                    if (var.getStorageClass() == StorageClass.SC_extern)
                        return LinkageInfo.uniqueExternal();

                    return new LinkageInfo();
                }
            }
            return LinkageInfo.none();
        }

        public boolean declarationReplaces(NamedDecl oldDecl)
        {
            Util.assertion(getIdentifier().equals(oldDecl.getIdentifier()),                     "Declaration asmName mismatch!");

            if (this instanceof FunctionDecl)
            {
                return ((Decl.FunctionDecl)this).getPreviousDeclaration().equals(oldDecl);
            }

            // For non-function declarations, if the declarations are of the
            // same kind then this must be a redeclaration, or semantic analysis
            // would not have given us the new declaration.
            return getKind() == oldDecl.getKind();
        }
    }

    /**
     * Represents a labelled statement in source code.
     */
    public static class LabelDecl extends NamedDecl
    {
        LabelStmt stmt;

        private SourceLocation locStart;

        LabelDecl(IdentifierInfo name,
                IDeclContext context,
                Tree.LabelStmt stmt,
                SourceLocation identLoc)
        {
            this(name, context, stmt, identLoc, null);
        }

        LabelDecl(IdentifierInfo name,
                IDeclContext context,
                Tree.LabelStmt stmt,
                SourceLocation identLoc,
                SourceLocation startLoc)
        {
            super(DeclKind.LabelDecl, context, name, identLoc);
            this.stmt = stmt;
            locStart = startLoc;
        }

        public void setStmt(Tree.LabelStmt stmt)
        {
            this.stmt = stmt;
        }

        public Tree.LabelStmt getStmt()
        {
            return stmt;
        }

        public boolean isGnuLabel()
        {
            return locStart != null;
        }

        public void setLocStart(SourceLocation loc)
        {
            locStart = loc;
        }

        @Override
        public SourceRange getSourceRange()
        {
            return new SourceRange(locStart, getLocation());
        }
    }

    /**
     * Represents the declaration of a variable (in which case it is an lvalue)
     * or a function (in which case it is a function designator) or an enum constant.
     */
    public static abstract class ValueDecl extends NamedDecl
    {
        private QualType declType;

        protected ValueDecl(DeclKind kind,
                IDeclContext context,
                IdentifierInfo name,
                SourceLocation location,
                QualType type)
        {
            super(kind, context, name, location);
            declType = type;
        }

        public QualType getType() { return declType; }
        public void setType(QualType type) {declType = type; }
    }

    /**
     * Represents a ValueDecl that came out of a declarator.
     */
    public static abstract class DeclaratorDecl extends ValueDecl
    {
        private DeclaratorDecl declInfo;

        protected DeclaratorDecl(
                DeclKind kind,
                IDeclContext context,
                IdentifierInfo name,
                SourceLocation location,
                QualType type)
        {
            super(kind, context, name, location, type);
        }

        public SourceLocation getTypeSpecStartLoc()
        {
            return new SourceLocation();
        }
    }

    /**
     * This class is created by {@linkplain Sema#actOnField(Scope, Decl,
     * SourceLocation, Declarator, Expr)}
     * to represents a member of a struct or union.
     */
    public static class FieldDecl extends DeclaratorDecl
    {
        /**
         * It indicates the initializer of member of a struct/union or bitfield
         * expression.
         */
        private Tree.Expr init;
        /**
         * Indicates the {@linkplain #init} is an initializer or a bitfield.
         */
        private boolean hasInit;

        /**
         * A cached index into this field in corresponding record decl.
         */
        private int cachedFieldIndex;

        FieldDecl(IDeclContext context,
                IdentifierInfo name,
                SourceLocation location,
                QualType type,
                Expr init,
                boolean hasInit)
        {
            super(FieldDecl, context, name, location, type);
            this.init = init;
            this.hasInit = hasInit;
            Util.assertion(!(init != null && hasInit), "got initializer for bitfield");
        }

        /**
         * Determines if this is a bitfield.
         * @return
         */
        public boolean isBitField() { return init != null && !hasInit; }

        public Tree.Expr getBitWidth() { return isBitField()? init: null; }

        public long getBitWidthValue()
        {
            Util.assertion(isBitField(), "not a bitfield");
            Tree.Expr bitWidth = getBitWidth();
            return bitWidth.evaluateKnownConstInt().getZExtValue();
        }

        public RecordDecl getParent()
        {
            return (RecordDecl)getDeclContext();
        }

        public int getFieldIndex()
        {
            if (cachedFieldIndex != 0) return cachedFieldIndex;

            final RecordDecl rd = getParent();
            int index = 0;
            int i = 0, e = rd.getDeclCounts();
            while (true)
            {
                Util.assertion(i!=e, "failed to find field in parent!");
                if (rd.getDeclAt(i).equals(this))
                    break;

                ++i;
                ++index;
            }

            cachedFieldIndex = index + 1;
            return index;
        }
        /**
         * Determines whether this bitfield is a unnamed bitfield.
         * @return
         */
        public boolean isUnamaedBitField()
        {
            return !hasInit && init != null && getIdentifier() == null;
        }

        public boolean isAnonymousStructOrUnion()
        {
            if (!isImplicit() || getIdentifier() != null)
                return false;

            if (getType().isRecordType())
                return ((RecordType) getType().getType()).getDecl().isAnonymousStructOrUnion();

            return false;
        }
    }

    public enum DefinitionKind
    {
        /**
         * This declaration is only a declaration.
         */
        DeclarationOnly,

        /**
         * This declaration is a tentative declaration.
         */
        TentativeDefinition,

        /**
         * This declaration is a definitely declaration.
         */
        Definition;
    }

    /**
     * An instance of this class is created to represent a variable
     * declaration or definition.
     */
    public static class VarDecl extends DeclaratorDecl implements Redeclarable<VarDecl>
    {
        StorageClass sc;

        /**
         * The initializer for this variable.
         */
        Tree.Expr init;

        private boolean wasEvaluated;
        private APValue evaluatedValue;
        private boolean isEvaluating;

        /**
         * Points to the next redeclaration in the chain.
         *
         * If nextIsPrevious() is true, this is a link to the previous declaration
         * of this same Decl. If nextIsLatest() is true, this is the first
         * declaration and Link points to the latest declaration. For example:
         * <pre>
         *  #1 int f(int x, int y = 1); // &lt;pointer to #3, true&gt;
         *  #2 int f(int x = 0, int y); // &lt;pointer to #1, false&gt;
         *  #3 int f(int x, int y) { return x + y; } // &lt;pointer to #2, false&gt;
         * </pre>
         * If there is only one declaration, it is &lt;pointer to self, true&gt;
         */
        private DeclLink<VarDecl> redeclLink;

        public VarDecl(DeclKind kind,
                IDeclContext context,
                IdentifierInfo name,
                SourceLocation location,
                QualType type, StorageClass sc)
        {
            super(kind, context, name, location, type);
            this.sc = sc;
            wasEvaluated = false;
            evaluatedValue = null;
            isEvaluating = false;
            redeclLink = new DeclLink.LatestDeclLink<>(this);
        }

        @Override
        public VarDecl getNextRedeclaration()
        {
            return getRedeclLink().getNext();
        }

        /**
         * Returns true if this variable just declared in function rathere than
         * parameter list. Note that this includes static variables
         * inside of functions. It also includes variables inside blocks
         *
         * void foo() { int x; static int y; extern int z; }
         * @return
         */
        public boolean isLocalVarDecl()
        {
            if (getKind() != DeclKind.VarDecl)
                return false;
            if (getDeclContext() != null)
                return getDeclContext().isFunction();
            return false;
        }

        /**
         * Returns true if this variable declared in a function scope
         * but excludes the case that variable declared in blocks.
         * @return
         */
        public boolean isFunctionVarDecl()
        {
            if (getKind() != DeclKind.VarDecl)
                return false;
            if (getDeclContext() != null)
                return getDeclContext().isFunction();
            return false;
        }

        /**
         * Returns true if a variable with function scope
         * is a non-static local variable.
         */
        public boolean hasLocalStorage()
        {
            if (sc == StorageClass.SC_none)
                return !isFileVarDecl();
            return sc.ordinal() >= StorageClass.SC_auto.ordinal();
        }

        public boolean isStaticLocal()
        {
            return sc == StorageClass.SC_static && !isFileVarDecl();
        }

        public boolean isFileVarDecl()
        {
            if (getKind() != DeclKind.VarDecl)
                return false;

            return getDeclContext().isFileContext();

        }

        public boolean hasGlobalStorage()
        {
            return !hasLocalStorage();
        }

        /**
         * Check whether this declaration is a definition. If this could be
         * a tentative definition (in C)
         * @return
         */
        public DefinitionKind isThisDeclarationADefinition()
        {
            // C99 6.7p5:
            //   A definition of an identifier is a declaration for that identifier that
            //   [...] causes storage to be reserved for that object.
            // Note: that applies for all non-file-scope objects.
            // C99 6.9.2p1:
            //   If the declaration of an identifier for an object has file scope and an
            //   initializer, the declaration is an external definition for the identifier
            if (hasInit())
                return DefinitionKind.Definition;

            if (sc == StorageClass.SC_extern)
                return DefinitionKind.DeclarationOnly;

            // C99 6.9.2p2:
            //   A declaration of an object that has file scope without an initializer,
            //   and without a storage class specifier or the scs 'static', constitutes
            //   a tentative definition.
            if (isFileVarDecl())
                return DefinitionKind.TentativeDefinition;

            // What's left is (in C, block-scope) declarations without initializers or
            // external storage. These are definitions.
            return DefinitionKind.Definition;
        }

        public boolean hasInit()
        {
            return init!=null;
        }

        public Tree.Expr getInit()
        {
            return init;
        }

        /**
         * Determines whether if a variable has extern qualified.
         * @return
         */
        public boolean hasExternalStorage()
        {
            return sc == StorageClass.SC_extern;
        }

        public void setInit(Tree.Expr init)
        {
            this.init = init;
        }

        public boolean isEvaluatingValue()
        {
            return isEvaluating;
        }

        public void setEvaluatingValue()
        {
            isEvaluating = true;
        }

        public void setEvaluatedValue(final  APValue val)
        {
            isEvaluating = false;
            wasEvaluated = true;
            evaluatedValue = val;
        }

        public APValue getEvaluatedValue()
        {
            if (wasEvaluated)
                return evaluatedValue;
            return null;
        }

        public StorageClass getStorageClass()
        {
            return sc;
        }

        /**
         *  Returns true for local variable declarations.  Note that
         * this includes static variables inside of functions.
         * <pre>
         *   void foo() { int x; static int y; extern int z; }
         * </pre>
         * @return
         */
        public boolean isBlockVarDecl()
        {
            if (getKind() != VarDecl)
                return false;
            IDeclContext dc = getDeclContext();
            if (dc != null)
                return !dc.isFileContext();
            return false;
        }

        /**
         * Determine whether this is a tentative definition of a variable in C.
         * @return
         */
        public boolean isTentativeDefinition()
        {
            if (!isFileVarDecl())
                return false;
            OutRef<VarDecl> def = new OutRef<>();
            return (getDefinition(def) == null && (sc == StorageClass.SC_none
                    || sc == StorageClass.SC_static));
        }

        public Expr getDefinition(OutRef<VarDecl> def)
        {
            RedeclIterator<VarDecl> itr = getRedeclIterator();
            Decl.VarDecl current = null;
            while (itr.hasNext() && (current = itr.getNext()).getInit() == null);

            if (itr.hasNext())
            {
                def.set(current);
                return current.getInit();
            }
            return null;
        }

        public VarDecl getCanonicalDecl()
        {
            return getFirstDeclaration();
        }

        @Override
        public VarDecl getPreviousDeclaration()
        {
            if(redeclLink.nextIsPrevious())
                return redeclLink.getNext();
            return null;
        }
        @Override
        public VarDecl getFirstDeclaration()
        {
            Decl.VarDecl cur = this;
            Decl.VarDecl prev;
            while ((prev = cur.getPreviousDeclaration()) != null)
            {
                cur = prev.getPreviousDeclaration();
            }
            return cur;
        }
        @Override
        public void setPreviousDeclaration(VarDecl prevDecl)
        {
            VarDecl first;
            if (prevDecl != null)
            {
                redeclLink = new DeclLink.PreviousDeclLink<VarDecl>(prevDecl);
                first = prevDecl.getFirstDeclaration();
                Util.assertion(first.redeclLink.nextIsLatest(), "Expected first!");
            }
            else
            {
                first = this;
            }
            first.redeclLink = new DeclLink.LatestDeclLink<>(this);
        }

        @Override
        public DeclLink<VarDecl> getRedeclLink()
        {
            return redeclLink;
        }

        @Override
        public RedeclIterator<VarDecl> getRedeclIterator()
        {
            return new <VarDecl>RedeclIterator(this);
        }

        public DefinitionKind hasDefinition()
        {
            DefinitionKind kind = DefinitionKind.DeclarationOnly;

            RedeclIterator<VarDecl> itr = getRedeclIterator();
            while (itr.hasNext())
            {
                DefinitionKind k = itr.getNext().isThisDeclarationADefinition();
                if (k.compareTo(kind) > 0)
                    kind = k;
            }
            return kind;
        }

        public static String getStorageClassSpecifierString(StorageClass sc)
        {
            switch (sc)
            {
                default:
                case SC_none:
                    return "";
                case SC_auto:
                    return "auto";
                case SC_extern:
                    return "extern";
                case SC_register:
                    return "register";
                case SC_static:
                    return "static";

            }
        }
    }

    /**
     * Represent a parameter to a function.
     */
    public static class ParamVarDecl extends VarDecl
    {
        private int scopeDepth;

        public ParamVarDecl(
                DeclKind dk,
                IDeclContext context,
                IdentifierInfo name,
                SourceLocation location,
                QualType type,
                StorageClass sc)
        {
            super(dk, context, name, location, type, sc);
        }

        public static ParamVarDecl create(
                IDeclContext context,
                IdentifierInfo name,
                SourceLocation location,
                QualType type,
                StorageClass sc)
        {
            return new ParamVarDecl(ParamVarDecl, context, name, location, type, sc);
        }

        public void setScopeInfo(int depth, int protoTypeIndex)
        {
            scopeDepth = depth;
        }

        /**
         * Sets the function declaration that owns this
         * ParmVarDecl. Since ParmVarDecls are often created before the
         * FunctionDecls that own them, this routine is required to update
         * the DeclContext appropriately.
         */
        public void setOwningFunction(IDeclContext fd)
        {
            setDeclContext(fd);
        }
    }

    public static class OriginalParamVarDecl extends ParamVarDecl
    {
        protected QualType originalType;

        public OriginalParamVarDecl(
                IDeclContext dc,
                SourceLocation loc,
                IdentifierInfo id,
                QualType ty,
                QualType originalType,
                StorageClass sc)
        {
            super(OriginalParamVar, dc, id, loc, ty, sc);
            this.originalType = originalType;
        }

        public static OriginalParamVarDecl create(
                IDeclContext dc,
                SourceLocation loc,
                IdentifierInfo id,
                QualType ty,
                QualType originalType,
                StorageClass sc)
        {
            return new OriginalParamVarDecl(dc, loc, id, ty, originalType, sc);
        }

        public QualType getOriginalType()
        {
            return originalType;
        }

        public void setOriginalType(QualType ty)
        {
            originalType = ty;
        }
    }

    /**
     * An instance of this class is created to represent a function declaration
     * or definition.
     * <p>
     * Since a given function can be declared several times in a program,
     * there may be several FunctionDecls that correspond to that
     * function. Only one of those FunctionDecls will be found when
     * traversing the list of declarations in the context of the
     * FunctionDecl (e.g., the translation unit); this FunctionDecl
     * contains all of the information known about the function. Other,
     * previous declarations of the function are available via the
     * getPreviousDeclaration() chain.
     * </p>
     */
    public static class FunctionDecl extends DeclaratorDecl
            implements IDeclContext, Redeclarable<FunctionDecl>
    {
        /**
         * A array of ParamVarDecl.
         */
        private ParamVarDecl[] paramInfo;

        private Tree.Stmt body;
        private StorageClass sc;
        private boolean isInlineSpecified;
        private boolean hasImplicitReturnZero;
        private boolean hasInheritedPrototype;
        private SourceLocation endRangeLoc;

        private DeclContext dc;
        private boolean isPure;
        private boolean c99InlineDefinition;
        private boolean hasWrittenPrototype;

        /**
         * Points to the next redeclaration in the chain.
         *
         * If nextIsPrevious() is true, this is a link to the previous declaration
         * of this same Decl. If nextIsLatest() is true, this is the first
         * declaration and Link points to the latest declaration. For example:
         * <pre>
         *  #1 int f(int x, int y = 1); // &lt;pointer to #3, true&gt;
         *  #2 int f(int x = 0, int y); // &lt;pointer to #1, false&gt;
         *  #3 int f(int x, int y) { return x + y; } // &lt;pointer to #2, false&gt;
         * </pre>
         * If there is only one declaration, it is &lt;pointer to self, true&gt;
         */
        private DeclLink<FunctionDecl> redeclLink;

        public FunctionDecl(IdentifierInfo name,
                IDeclContext context,
                SourceLocation location,
                QualType type,
                StorageClass sc,
                boolean isInline)
        {
            this(name, context, location, type, sc, isInline, false);
        }

        FunctionDecl(IdentifierInfo name,
                IDeclContext context,
                SourceLocation location,
                QualType type,
                StorageClass sc,
                boolean isInline,
                boolean hasWrittenPrototype)
        {
            super(FunctionDecl, context, name, location, type);
            this.sc = sc;
            this.isInlineSpecified = isInline;
            paramInfo = null;
            endRangeLoc = SourceLocation.NOPOS;
            body = null;
            redeclLink = new DeclLink.LatestDeclLink<>(this);
            this.hasWrittenPrototype = hasWrittenPrototype;
            dc = new DeclContext(FunctionDecl, this);
        }

        @Override
        public FunctionDecl getNextRedeclaration()
        {
            return getRedeclLink().getNext();
        }

        @Override
        public SourceRange getSourceRange()
        {
            return new SourceRange(getLocation(), endRangeLoc);
        }

        public QualType getReturnType()
        {
            return getType().getType().getAsFunctionType().getResultType();
        }

        @Override
        public FunctionDecl getCanonicalDecl()
        {
            return this;
        }

        public void setParams(ArrayList<ParamVarDecl> params)
        {
            paramInfo = new ParamVarDecl[params.size()];
            params.toArray(paramInfo);
        }

        public int getNumParams()
        {
            return paramInfo.length;
        }

        public ParamVarDecl getParamDecl(int idx)
        {
            Util.assertion( idx>=0 && idx< getNumParams());
            return paramInfo[idx];
        }

        public ParamVarDecl[] getParamInfo()
        {
            return paramInfo;
        }

        /**
         * Returns true if the function has body (definition).
         * @return
         */
        public boolean hasBody()
        {
            return hasBody(new OutRef<>());
        }

        public boolean hasBody(OutRef<FunctionDecl> def)
        {
            RedeclIterator<FunctionDecl> itr = getRedeclIterator();
            while (itr.hasNext())
            {
                Decl.FunctionDecl fd = itr.getNext();
                if (fd != null && fd.body != null)
                {
                    def.set(fd);
                    return true;
                }
            }
            return false;
        }

        /**
         * Determines whether this function has definition body.
         * @return
         */
        public boolean isDefined()
        {
            return isDefined(new OutRef<>());
        }

        public boolean isDefined(OutRef<FunctionDecl> def)
        {
            RedeclIterator<FunctionDecl> itr = getRedeclIterator();
            while (itr.hasNext())
            {
                Decl.FunctionDecl fd = itr.getNext();
                if (fd != null && fd.body != null)
                {
                    def.set(fd);
                    return true;
                }
            }
            return false;
        }

        @Override
        public Tree.Stmt getBody()
        {
            OutRef<FunctionDecl> def = new OutRef<>();
            return getBody(def);
        }

        public Tree.Stmt getBody(OutRef<FunctionDecl> def)
        {
            RedeclIterator<FunctionDecl> itr = getRedeclIterator();
            while (itr.hasNext())
            {
                Decl.FunctionDecl fd = itr.getNext();
                if (fd != null && fd.body != null)
                {
                    def.set(fd);
                    return fd.body;
                }
            }
            return null;
        }

        public void setBody(Tree.Stmt b)
        {
            body = b;
            if (b != null)
                endRangeLoc = b.getLocEnd();
        }

        /**
         * Determines whether this function is "main", which is the
         * entry point into an executable environment.
         * @return
         */
        public boolean isMain()
        {
            return getDeclContext().getLookupContext().isTranslationUnit()
                    && getIdentifier() != null && getIdentifier().isStr("main");
        }

        /**
         * Determines if this function is a global function.
         * @return
         */
        public boolean isGlobal()
        {
            return !(sc == StorageClass.SC_static);
        }

        public StorageClass getStorageClass()
        {
            return sc;
        }

        public void setStorageClass(StorageClass sc)
        {
            this.sc = sc;
        }

        public boolean isInlineSpecified()
        {
            return isInlineSpecified;
        }

        public void setInlineSpecified(boolean val)
        {
            isInlineSpecified = val;
        }

        public boolean hasImplicitReturnZero()
        {
            return hasImplicitReturnZero;
        }

        public void setHasImplicitReturnZero(boolean b)
        {
            hasImplicitReturnZero = b;
        }

        @Override
        public FunctionDecl getPreviousDeclaration()
        {
            if(redeclLink.nextIsPrevious())
                return redeclLink.getNext();
            return null;
        }
        @Override
        public FunctionDecl getFirstDeclaration()
        {
            FunctionDecl cur = this;
            FunctionDecl prev;
            while ((prev = cur.getPreviousDeclaration()) != null)
            {
                cur = prev.getPreviousDeclaration();
            }
            return cur;
        }
        @Override
        public void setPreviousDeclaration(FunctionDecl prevDecl)
        {
            FunctionDecl first;
            if (prevDecl != null)
            {
                redeclLink = new DeclLink.PreviousDeclLink<FunctionDecl>(prevDecl);
                first = prevDecl.getFirstDeclaration();
                Util.assertion(first.redeclLink.nextIsLatest(), "Expected first!");
            }
            else
            {
                first = this;
            }
            first.redeclLink = new DeclLink.LatestDeclLink<>(this);
        }

        @Override
        public DeclLink<FunctionDecl> getRedeclLink()
        {
            return redeclLink;
        }

        @Override
        public RedeclIterator<FunctionDecl> getRedeclIterator()
        {
            return new <FunctionDecl>RedeclIterator(this);
        }

        @Override
        public DeclKind getKind()
        {
            return dc.getKind();
        }

        @Override
        public ASTContext getParentASTContext()
        {
            return dc.getParentASTContext();
        }

        @Override
        public IDeclContext getParent()
        {
            return dc.getParent();
        }

        @Override
        public void addDecl(Decl decl)
        {
            dc.addDecl(decl);
        }

        @Override
        public void addHiddenDecl(Decl d)
        {
            dc.addHiddenDecl(d);
        }

        @Override
        public void removeDecl(Decl decl)
        {
            dc.removeDecl(decl);
        }

        @Override
        public boolean isFunction()
        {
            return dc.isFunction();
        }

        @Override
        public boolean isFileContext()
        {
            return dc.isFileContext();
        }

        @Override
        public boolean isTranslationUnit()
        {
            return dc.isTranslationUnit();
        }

        @Override
        public boolean isRecord()
        {
            return dc.isRecord();
        }

        @Override
        public boolean isTransparentContext()
        {
            return dc.isTransparentContext();
        }

        @Override
        public IDeclContext getLookupContext()
        {
            return dc.getLookupContext();
        }

        @Override
        public boolean isDeclInContext(Decl decl)
        {
            return dc.isDeclInContext(decl);
        }

        @Override
        public Decl getDeclAt(int idx)
        {
            return dc.getDeclAt(idx);
        }

        @Override
        public boolean isEmpty()
        {
            return dc.isEmpty();
        }

        @Override
        public List<Decl> getDeclsInContext()
        {
            return dc.getDeclsInContext();
        }

        @Override
        public int getDeclCounts()
        {
            return dc.getDeclCounts();
        }

        @Override
        public NamedDecl[] lookup(IdentifierInfo name)
        {
            return dc.lookup(name);
        }

        @Override
        public void makeDeclVisibleInContext(NamedDecl nd)
        {
            dc.makeDeclVisibleInContext(nd);
        }

        @Override
        public IDeclContext getPrimaryContext()
        {
            return dc.getPrimaryContext();
        }

        /**
         * Returns whether this specific
         * declaration of the function is also a definition. This does not
         * determine whether the function has been defined (e.g., in a
         * previous definition); for that information, use getBody.
         * @return
         */
        public boolean isThisDeclarationADefinition()
        {
            return body != null;
        }

        public boolean isPure()
        {
            return isPure;
        }

        public void setPure(boolean pure)
        {
            isPure = pure;
        }

        public void setRangeEnd(SourceLocation locEnd)
        {
            endRangeLoc = locEnd;
        }

        public void setC99InlineDefinition(boolean val)
        {
            c99InlineDefinition = val;
        }

        public boolean isC99InlineDefinition()
        {
            return c99InlineDefinition;
        }

        public boolean hasPrototype()
        {
            return hasWrittenPrototype || hasInheritedPrototype;
        }

        public boolean hasWrittenPrototype()
        {
            return hasWrittenPrototype;
        }

        public void setHasWrittenPrototype(boolean value)
        {
            hasWrittenPrototype = value;
        }

        /**
         * Returns the minimum number of arguments needed to call this function.
         * This may be fewer than the number of parameters in function prototype
         * (C++).
         * @return
         */
        public int getMinRequiredArguments()
        {
            return getNumParams();
        }
    }

    /**
     * Represents a declaration of a type.
     */
    public static class TypeDecl extends NamedDecl
    {
        /**
         * This indicates the type object that represents this typeDecl.
         */
        protected Type typeForDecl;

        protected TypeDecl(
                DeclKind kind,
                IDeclContext context,
                IdentifierInfo name,
                SourceLocation loc)
        {
            super(kind, context, name, loc);
        }

        public Type getTypeForDecl()
        {
            return typeForDecl;
        }

        public void setTypeForDecl(Type t)
        {
            typeForDecl = t;
        }
    }

    /**
     * Represents a declaration of a typedef name.
     */
    public static class TypeDefDecl extends TypedefNameDecl
    {
        /**
         * This is the type that this typedef decl is set to.
         */
        private QualType underlyingType;

        public TypeDefDecl(
                IDeclContext context,
                IdentifierInfo id,
                SourceLocation loc,
                QualType type)
        {
            super(TypedefDecl, context, id, loc);
            underlyingType = type;
        }

        public QualType getUnderlyingType()
        {
            return underlyingType;
        }

        public void setUnderlyingType(QualType ty)
        {
            underlyingType = ty;
        }
    }

    /**
     * Base class for declarations which introduce a typedef-name.
     */
    public static class TypedefNameDecl extends TypeDecl
    {
        private QualType type;

        public TypedefNameDecl(
                DeclKind kind,
                IDeclContext context,
                IdentifierInfo name,
                SourceLocation loc)
        {
            super(kind, context, name, loc);
        }

        public QualType getUnderlyingType()
        {
            return type;
        }
    }

    /**
     * Represents the declaration of a struct/union/enum.
     */
    public static class TagDecl extends TypeDecl implements
            IDeclContext, Redeclarable<TagDecl>
    {
        /**
         * True if this is a definition ("struct foo {};"), false if
         * it is a declaration ("struct foo;").
         */
        protected boolean isDefinition;

        /**
         * True if this is currently being defined but not completed.
         */
        protected boolean isBeingDefined;
        protected IDeclContext declContext;
        protected TagKind tagKind;

        /**
         * True if this tc is free standing, e.g. "struct X;".
         */
        protected boolean isFreeStanding;

        private SourceLocation tagKkeywordLoc;
        private SourceLocation rbraceLoc;
	    /**
         * If a TagDecl is anonymous and part of a typedef,
         * this points to the TypedefDecl. Used for mangling.
         */
        private TypeDefDecl typedefAnonDecl;

        private DeclContext dc;

        /**
         * Points to the next redeclaration in the chain.
         *
         * If nextIsPrevious() is true, this is a link to the previous declaration
         * of this same Decl. If nextIsLatest() is true, this is the first
         * declaration and Link points to the latest declaration. For example:
         * <pre>
         *  #1 int f(int x, int y = 1); // &lt;pointer to #3, true&gt;
         *  #2 int f(int x = 0, int y); // &lt;pointer to #1, false&gt;
         *  #3 int f(int x, int y) { return x + y; } // &lt;pointer to #2, false&gt;
         * </pre>
         * If there is only one declaration, it is &lt;pointer to self, true&gt;
         */
        private DeclLink<TagDecl> redeclLink;

        public TagDecl(DeclKind kind,
                TagKind tagKind,
                IDeclContext context,
                IdentifierInfo name,
                SourceLocation loc,
                TagDecl prevDecl,
                SourceLocation tkl)
        {
            super(kind, context, name, loc);
            isDefinition = false;
            this.tagKind = tagKind;
            tagKkeywordLoc = tkl;
            dc = new DeclContext(kind, this);
            redeclLink = new DeclLink.LatestDeclLink<TagDecl>(this);
            Util.assertion(kind != DeclKind.EnumDecl || tagKind == TTK_enum,                     "EnumDecl not matched with TTK_enum");

            setPreviousDeclaration(prevDecl);
        }

        public TagDecl(DeclKind kind,
                TagKind tagKind,
                IDeclContext context,
                IdentifierInfo name,
                SourceLocation loc,
                TagDecl prevDecl)
        {
            this(kind, tagKind, context, name, loc, prevDecl, new SourceLocation());;
        }


        @Override
        public TagDecl getNextRedeclaration()
        {
            return getRedeclLink().getNext();
        }

        public void startDefinition()
        {
            if (getTypeForDecl() instanceof TagType)
            {
                TagType tt = (TagType)getTypeForDecl();
                tt.getDecl().setBeingDefined();
                tt.setDecl(this);
            }
        }

        public void setLexicalDeclaration(IDeclContext curContext)
        {
            if (declContext == curContext)
                return;

            this.declContext = curContext;
        }

        /**
         * True if this is a definition ("struct foo {};"), false if
         * it is a declaration ("struct foo;").
         */
        public final boolean isCompleteDefinition()
        {
            return isDefinition;
        }

        @Override
        public TagDecl getCanonicalDecl()
        {
            return getFirstDeclaration();
        }

        /**
         * Sets the flag of {@linkplain this#isDefinition} for completing
         * the definition of this forward declaration.
         */
        public void completeDefinition()
        {
            isDefinition = true;
            isBeingDefined = false;
            TagType tt = typeForDecl instanceof TagType ? (TagType)typeForDecl:null;

            if (tt != null)
            {
                Util.assertion(tt.getDecl() == this, "Attempt to redefine a stmtClass definition?");
            }
        }

        public void setFreeStanding(boolean isFreeStanding)
        {
            this.isFreeStanding = isFreeStanding;
        }

        public boolean isFreeStanding()
        {
            return isFreeStanding;
        }

        public TagKind getTagKind()
        {
            return tagKind;
        }

        public boolean isStruct()
        {
            return tagKind == TTK_struct;
        }

        public boolean isUnion()
        {
            return tagKind == TTK_union;
        }

        public boolean isEnum()
        {
            return tagKind == TTK_enum;
        }

        public void setRBraceLoc(SourceLocation rbraceloc)
        {
            this.rbraceLoc = rbraceloc;
        }

        public String getKindName()
        {
            switch (tagKind)
            {
                case TTK_enum: return "enum";
                case TTK_struct: return "struct";
                case TTK_union: return "union";
                default: return null;
            }
        }

        public TagDecl getDefinition()
        {
            if (isDefinition)
                return this;

            RedeclIterator<TagDecl> itr = getRedeclIterator();
            while (itr.hasNext())
            {
                TagDecl td = itr.getNext();
                if (td.isDefinition)
                    return td;
            }
            return null;
        }

        public TypeDefDecl getTypedefAnonDecl()
        {
            return typedefAnonDecl;
        }

        public void setTypedefAnonDecl(TypeDefDecl typedefAnonDecl)
        {
            this.typedefAnonDecl = typedefAnonDecl;
        }

        public void setBeingDefined()
        {
            isBeingDefined = true;
        }

        public boolean isBeingDefined()
        {
            return isBeingDefined;
        }

        @Override
        public TagDecl getPreviousDeclaration()
        {
            if(redeclLink.nextIsPrevious())
                return redeclLink.getNext();
            return null;
        }
        @Override
        public TagDecl getFirstDeclaration()
        {
            TagDecl cur = this;
            TagDecl prev;
            while ((prev = cur.getPreviousDeclaration()) != null)
            {
                cur = prev.getPreviousDeclaration();
            }
            return cur;
        }
        @Override
        public void setPreviousDeclaration(TagDecl prevDecl)
        {
            TagDecl first;
            if (prevDecl != null)
            {
                redeclLink = new DeclLink.PreviousDeclLink<TagDecl>(prevDecl);
                first = prevDecl.getFirstDeclaration();
                Util.assertion(first.redeclLink.nextIsLatest(), "Expected first!");
            }
            else
            {
                first = this;
            }
            first.redeclLink = new DeclLink.LatestDeclLink<>(this);
        }

        @Override
        public DeclLink<TagDecl> getRedeclLink()
        {
            return redeclLink;
        }

        @Override
        public RedeclIterator<TagDecl> getRedeclIterator()
        {
            return new <TagDecl>RedeclIterator(this);
        }

        @Override
        public DeclKind getKind()
        {
            return dc.getKind();
        }

        @Override
        public ASTContext getParentASTContext()
        {
            return dc.getParentASTContext();
        }

        @Override
        public IDeclContext getParent()
        {
            return dc.getParent();
        }

        @Override
        public void addDecl(Decl decl)
        {
            dc.addDecl(decl);
        }

        @Override
        public void addHiddenDecl(Decl d)
        {
            dc.addHiddenDecl(d);
        }

        @Override
        public void removeDecl(Decl decl)
        {
            dc.removeDecl(decl);
        }

        @Override
        public boolean isFunction()
        {
            return dc.isFunction();
        }

        @Override
        public boolean isFileContext()
        {
            return dc.isFileContext();
        }

        @Override
        public boolean isTranslationUnit()
        {
            return dc.isTranslationUnit();
        }

        @Override
        public boolean isRecord()
        {
            return dc.isRecord();
        }

        @Override
        public boolean isTransparentContext()
        {
            return dc.isTransparentContext();
        }

        @Override
        public IDeclContext getLookupContext()
        {
            return dc.getLookupContext();
        }

        @Override
        public boolean isDeclInContext(Decl decl)
        {
            return dc.isDeclInContext(decl);
        }

        @Override
        public Decl getDeclAt(int idx)
        {
            return dc.getDeclAt(idx);
        }

        @Override
        public boolean isEmpty()
        {
            return dc.isEmpty();
        }

        @Override
        public List<Decl> getDeclsInContext()
        {
            return dc.getDeclsInContext();
        }

        @Override
        public int getDeclCounts()
        {
            return dc.getDeclCounts();
        }

        @Override
        public NamedDecl[] lookup(IdentifierInfo name)
        {
            return dc.lookup(name);
        }

        @Override
        public void makeDeclVisibleInContext(NamedDecl nd)
        {
            dc.makeDeclVisibleInContext(nd);
        }

        @Override
        public IDeclContext getPrimaryContext()
        {
            return dc.getPrimaryContext();
        }

        @Override
        public String toString()
        {
            return getKindName() + (name != null?name.getName():"anon " + super.toString());
        }
    }

    /**
     * Represents a struct/union. For example:
     * <pre>
     *   struct X;      // forward declaration
     *   union Y {int A, B; };  // has body definition.
     * </pre>
     * This decl will be marked invalid if "any" member is invalid.
     */
    public static class RecordDecl extends TagDecl
    {
        /**
         * This is true if this struct ends with a flexible
         * array member (e.g. int X[]) or if this union contains a struct that does.
         * If so, this cannot be contained in arrays or other structs as a member.
         */
        private boolean hasFlexibleArrayMember;
        /**
         * Whether this is the type of an anonymous struct or union.
         */
        private boolean anonymousStructOrUnion;
        /**
         * This is true if this struct has at least one
         * member containing an object
         */
        private boolean hasObjectMember;

        public RecordDecl(
                IdentifierInfo name,
                TagKind tagKind,
                IDeclContext context,
                SourceLocation loc,
                RecordDecl prevDecl)
        {
            super(RecordDecl, tagKind, context, name, loc, prevDecl);
            hasFlexibleArrayMember = false;
            anonymousStructOrUnion = false;
            hasObjectMember = false;
        }

        public FieldDecl getDeclAt(int index)
        {
            List<Decl> list = getDeclsInContext();
            Util.assertion( index>= 0&&index<list.size());
            return (FieldDecl) list.get(index);
        }

        public int getNumFields()
        {
            return getDeclsInContext().size();
        }

	    /**
         * Whether this is an anonymous struct or union.
         * To be an anonymous struct or union, it must have been
         * declared without a asmName and there must be no objects of this
         * type declared, e.g.,
         * <code>
         *   union { int i; float f; };
         * </code>
         * is an anonymous union but neither of the following are:
         * <code>
         *  union X { int i; float f; };
         *  union { int i; float f; } obj;
         * </code>
         * @return
         */
        public boolean isAnonymousStructOrUnion()
        {
            return anonymousStructOrUnion;
        }

        public boolean hasFlexibleArrayNumber()
        {
            return hasFlexibleArrayMember;
        }

        public void setHasFlexibleArrayMember(boolean val)
        {
            hasFlexibleArrayMember = val;
        }

        public boolean hasObjectMember()
        {
            return hasObjectMember;
        }

        public void setHasObjectMember(boolean v)
        {
            hasObjectMember = v;
        }

        @Override
        public RecordDecl getDefinition()
        {
            TagDecl td = super.getDefinition();
            return td instanceof RecordDecl ? (RecordDecl)td : null;
        }

        @Override
        public void completeDefinition()
        {
            Util.assertion(!isCompleteDefinition(), "Cannot redefine a record!");
            super.completeDefinition();
        }

        @Override
        public String toString()
        {
            return name != null ? name.getName() : super.toString();
        }
    }

    /**
     * Represents an enumeration declaration.
     * As an extension, we allows forward declared enums.
     */
    public static class EnumDecl extends TagDecl
    {
        /**
         * The integer type that values of this type should promote to.
         * In C, enumerators are generally of an integer tyep directly.
         */
        private QualType integerType;

        private EnumDecl(
                IdentifierInfo name,
                IDeclContext context,
                SourceLocation loc,
                EnumDecl prevDecl)
        {
            super(EnumDecl, TTK_enum, context, name, loc, prevDecl);
            integerType = new QualType();
        }

        public static EnumDecl create(ASTContext ctx, IdentifierInfo name,
                IDeclContext context, SourceLocation loc, EnumDecl prevDecl)
        {
            Decl.EnumDecl ed = new EnumDecl(name, context, loc, prevDecl);
            ctx.getTypeDeclType(ed, prevDecl);
            return ed;
        }

        /**
         * When instantiating an instance, the {@linkplain EnumDecl} corresponds to
         * a forward-declared enum.
         * <br>
         * This function is used to mark this declaration as has completed. It's
         * enumerator have already been added.
         * @param newType  Indicates that underlying jlang.type of this forward declaration.
         */
        public void completeDefinition(QualType newType)
        {
            Util.assertion(!isCompleteDefinition(), "Cannot redefine enums!");
            integerType = newType;
            super.completeDefinition();
        }

        public QualType getIntegerType()
        {
            return integerType;
        }

        public void setIntegerType(QualType enumUnderlying)
        {
            integerType = enumUnderlying;
        }
    }

    /**
     * An instance of this object exists for each enum constant
     * that is defined.  For example, in "enum X {a,b}", each of a/b are
     * EnumConstantDecl's, X is an instance of EnumDecl, and the jlang.type of a/b is a
     * TagType for the X EnumDecl.
     */
    public static class EnumConstantDecl extends  ValueDecl
    {
        /**
         * An integral constant expression.
         */
        private Tree.Stmt init;
        /**
         * The value.
         */
        private APSInt val;

        EnumConstantDecl(
                IdentifierInfo name,
                IDeclContext context,
                SourceLocation location,
                QualType type,
                Tree.Stmt init)
        {
            this(name, context, location, type, init, null);
        }

        EnumConstantDecl(
                IdentifierInfo name,
                IDeclContext context,
                SourceLocation location,
                QualType type,
                Tree.Stmt init,
                APSInt val)
        {
            super(DeclKind.EnumConstant, context, name, location, type);
            this.init = init;
            this.val = val;
        }

        public Expr getInitExpr()
        {
            return (Tree.Expr)init;
        }

        public APSInt getInitValue()
        {
            return val;
        }

        public void setInitExpr(Tree.Expr e)
        {
            init = e;
        }

        public void setInitValue(APSInt e)
        {
            val = e;
        }
    }

    /**
     * This represents a inline asm declaration in the file scope.
     */
    public static class FileScopeAsmDecl extends Decl
    {
        private StringLiteral asmString;

        protected FileScopeAsmDecl(
                IDeclContext dc,
                SourceLocation location,
                StringLiteral asmStr)
        {
            super(DeclKind.FileScopeAsmDecl, dc, location);
            asmString = asmStr;
        }

        public StringLiteral getAsmString()
        {
            return asmString;
        }

        public void setAsmString(StringLiteral str)
        {
            asmString = str;
        }
    }
}